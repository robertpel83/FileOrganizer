<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>OpenCV: cv::DualQuat&lt; _Tp &gt; Class Template Reference</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
          distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
          distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.6.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d2/d75/namespacecv.html">cv</a></li><li class="navelem"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d2/d8b/classcv_1_1DualQuat-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cv::DualQuat&lt; _Tp &gt; Class Template Reference<div class="ingroups"><a class="el" href="../../d0/de1/group__core.html">Core functionality</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;opencv2/core/dualquaternion.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a46806b056f582b8a01376a9e4f206c98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a46806b056f582b8a01376a9e4f206c98">DualQuat</a> ()</td></tr>
<tr class="separator:a46806b056f582b8a01376a9e4f206c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0240c655a7264bf51ec577832b8ea664"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a0240c655a7264bf51ec577832b8ea664">DualQuat</a> (const _Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#aea1571d04e7a8413d694c86ccb65a4ca">w</a>, const _Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a85106b84b92f42e36c550865935377a0">x</a>, const _Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a0d5bdf3d341452e406d2ab9878e435a9">y</a>, const _Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#ad26885c85d72c4b9bc42d229b76e3790">z</a>, const _Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a26df9a4cba469c1308b777b2a80d380c">w_</a>, const _Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a5d5a3b9f89b32fc12ebd6f75f2392221">x_</a>, const _Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a0112c38fdb2e93d6bade42a1234447d5">y_</a>, const _Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a38eccd00b69906fa7c72a7a81b8f5c0e">z_</a>)</td></tr>
<tr class="memdesc:a0240c655a7264bf51ec577832b8ea664"><td class="mdescLeft">&#160;</td><td class="mdescRight">create from eight same type numbers.  <a href="#a0240c655a7264bf51ec577832b8ea664">More...</a><br /></td></tr>
<tr class="separator:a0240c655a7264bf51ec577832b8ea664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087c15b9ffa06f4ea5eb6223742dff02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a087c15b9ffa06f4ea5eb6223742dff02">DualQuat</a> (const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 8 &gt; &amp;q)</td></tr>
<tr class="memdesc:a087c15b9ffa06f4ea5eb6223742dff02"><td class="mdescLeft">&#160;</td><td class="mdescRight">create from a double or float vector.  <a href="#a087c15b9ffa06f4ea5eb6223742dff02">More...</a><br /></td></tr>
<tr class="separator:a087c15b9ffa06f4ea5eb6223742dff02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe17c67111b841c3cbb4798cc4183f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#affe17c67111b841c3cbb4798cc4183f2">conjugate</a> () const</td></tr>
<tr class="memdesc:affe17c67111b841c3cbb4798cc4183f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the conjugate of a dual quaternion. </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} \sigma^* &amp;= (p + \epsilon q)^* &amp;= (p^* + \epsilon q^*) \end{split} \end{equation} \]
</p>
  <a href="#affe17c67111b841c3cbb4798cc4183f2">More...</a><br /></td></tr>
<tr class="separator:affe17c67111b841c3cbb4798cc4183f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167be7d41482406ede53614790bccaf0"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a167be7d41482406ede53614790bccaf0">dot</a> (<a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; p) const</td></tr>
<tr class="memdesc:a167be7d41482406ede53614790bccaf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the dot product of two dual quaternion.  <a href="#a167be7d41482406ede53614790bccaf0">More...</a><br /></td></tr>
<tr class="separator:a167be7d41482406ede53614790bccaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af979a281d9545f7600e96f943f653799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#af979a281d9545f7600e96f943f653799">exp</a> () const</td></tr>
<tr class="memdesc:af979a281d9545f7600e96f943f653799"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of exponential function value  <a href="#af979a281d9545f7600e96f943f653799">More...</a><br /></td></tr>
<tr class="separator:af979a281d9545f7600e96f943f653799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c4352024df650aca349ada165434d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a38c4352024df650aca349ada165434d1">getDualPart</a> () const</td></tr>
<tr class="memdesc:a38c4352024df650aca349ada165434d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a quaternion which represent the dual part of dual quaternion. The definition of dual part is in <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a4e430e338126681e1961ee68a7be7ca5" title="create Dual Quaternion from two same type quaternions p and q. A Dual Quaternion  has the form:  wher...">createFromQuat()</a>.  <a href="#a38c4352024df650aca349ada165434d1">More...</a><br /></td></tr>
<tr class="separator:a38c4352024df650aca349ada165434d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665f8d810b024494a63394e846dd5ff3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a665f8d810b024494a63394e846dd5ff3">getRealPart</a> () const</td></tr>
<tr class="memdesc:a665f8d810b024494a63394e846dd5ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a quaternion which represent the real part of dual quaternion. The definition of real part is in <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a4e430e338126681e1961ee68a7be7ca5" title="create Dual Quaternion from two same type quaternions p and q. A Dual Quaternion  has the form:  wher...">createFromQuat()</a>.  <a href="#a665f8d810b024494a63394e846dd5ff3">More...</a><br /></td></tr>
<tr class="separator:a665f8d810b024494a63394e846dd5ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab829bfbdc0221d95c579b93b77c89e32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#ab829bfbdc0221d95c579b93b77c89e32">getRotation</a> (<a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>) const</td></tr>
<tr class="memdesc:ab829bfbdc0221d95c579b93b77c89e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the rotation in quaternion form.  <a href="#ab829bfbdc0221d95c579b93b77c89e32">More...</a><br /></td></tr>
<tr class="separator:ab829bfbdc0221d95c579b93b77c89e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a547bd8520e383742fef102cfa78a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a37a547bd8520e383742fef102cfa78a8">getTranslation</a> (<a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>) const</td></tr>
<tr class="memdesc:a37a547bd8520e383742fef102cfa78a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the translation vector. The rotation \(r\) in this dual quaternion \(\sigma\) is applied before translation \(t\). The dual quaternion \(\sigma\) is defined as </p><p class="formulaDsp">
\[\begin{equation} \begin{split} \sigma &amp;= p + \epsilon q \\ &amp;= r + \frac{\epsilon}{2}{t}r. \end{split} \end{equation}\]
</p>
<p> Thus, the translation can be obtained as follows </p><p class="formulaDsp">
\[t = 2qp^*.\]
</p>
  <a href="#a37a547bd8520e383742fef102cfa78a8">More...</a><br /></td></tr>
<tr class="separator:a37a547bd8520e383742fef102cfa78a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251f740b34b08760d0ef2da3c80d8e4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a251f740b34b08760d0ef2da3c80d8e4d">inv</a> (<a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>) const</td></tr>
<tr class="memdesc:a251f740b34b08760d0ef2da3c80d8e4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">if \(\sigma = p + \epsilon q\) is a dual quaternion, p is not zero, the inverse dual quaternion is </p><p class="formulaDsp">
\[\sigma^{-1} = \frac{\sigma^*}{||\sigma||^2}, \]
</p>
<p> or equivalentlly, </p><p class="formulaDsp">
\[\sigma^{-1} = p^{-1} - \epsilon p^{-1}qp^{-1}.\]
</p>
  <a href="#a251f740b34b08760d0ef2da3c80d8e4d">More...</a><br /></td></tr>
<tr class="separator:a251f740b34b08760d0ef2da3c80d8e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbd9da54eba93738f815fbb047a5e42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a5fbd9da54eba93738f815fbb047a5e42">log</a> (<a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>) const</td></tr>
<tr class="memdesc:a5fbd9da54eba93738f815fbb047a5e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of logarithm function value  <a href="#a5fbd9da54eba93738f815fbb047a5e42">More...</a><br /></td></tr>
<tr class="separator:a5fbd9da54eba93738f815fbb047a5e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d27eb5d46951ed32cb80c81de22518"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a29d27eb5d46951ed32cb80c81de22518">norm</a> () const</td></tr>
<tr class="memdesc:a29d27eb5d46951ed32cb80c81de22518"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the norm \(||\sigma||\) of dual quaternion \(\sigma = p + \epsilon q\). </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} ||\sigma|| &amp;= \sqrt{\sigma * \sigma^*} \\ &amp;= ||p|| + \epsilon \frac{p \cdot q}{||p||}. \end{split} \end{equation} \]
</p>
<p> Generally speaking, the norm of a not unit dual quaternion is a dual number. For convenience, we return it in the form of a dual quaternion , i.e. </p><p class="formulaDsp">
\[ ||\sigma|| = [||p||, 0, 0, 0, \frac{p \cdot q}{||p||}, 0, 0, 0].\]
</p>
  <a href="#a29d27eb5d46951ed32cb80c81de22518">More...</a><br /></td></tr>
<tr class="separator:a29d27eb5d46951ed32cb80c81de22518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fb64a8e458fd953bb085da63a76ddf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a49fb64a8e458fd953bb085da63a76ddf">normalize</a> () const</td></tr>
<tr class="memdesc:a49fb64a8e458fd953bb085da63a76ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a normalized dual quaternion. A dual quaternion can be expressed as </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} \sigma &amp;= p + \epsilon q\\ &amp;=||\sigma||\left(r+\frac{1}{2}tr\right) \end{split} \end{equation} \]
</p>
<p> where \(r, t\) represents the rotation (ordinary quaternion) and translation (pure ordinary quaternion) respectively, and \(||\sigma||\) is the norm of dual quaternion(a dual number). A dual quaternion is unit if and only if </p><p class="formulaDsp">
\[ ||p||=1, p \cdot q=0 \]
</p>
<p> where \(\cdot\) means dot product. The process of normalization is </p><p class="formulaDsp">
\[ \sigma_{u}=\frac{\sigma}{||\sigma||} \]
</p>
<p> Next, we simply proof \(\sigma_u\) is a unit dual quaternion: </p><p class="formulaDsp">
\[ \renewcommand{\Im}{\operatorname{Im}} \begin{equation} \begin{split} \sigma_{u}=\frac{\sigma}{||\sigma||}&amp;=\frac{p + \epsilon q}{||p||+\epsilon\frac{p\cdot q}{||p||}}\\ &amp;=\frac{p}{||p||}+\epsilon\left(\frac{q}{||p||}-p\frac{p\cdot q}{||p||^3}\right)\\ &amp;=\frac{p}{||p||}+\epsilon\frac{1}{||p||^2}\left(qp^{*}-p\cdot q\right)\frac{p}{||p||}\\ &amp;=\frac{p}{||p||}+\epsilon\frac{1}{||p||^2}\Im(qp^*)\frac{p}{||p||}.\\ \end{split} \end{equation} \]
</p>
<p> As expected, the real part is a rotation and dual part is a pure quaternion.  <a href="#a49fb64a8e458fd953bb085da63a76ddf">More...</a><br /></td></tr>
<tr class="separator:a49fb64a8e458fd953bb085da63a76ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc08afc805ba106adc3eb95f937c57b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#acc08afc805ba106adc3eb95f937c57b9">operator*</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;) const</td></tr>
<tr class="memdesc:acc08afc805ba106adc3eb95f937c57b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator of two dual quaternions q and p. Multiplies values on either side of the operator.  <a href="#acc08afc805ba106adc3eb95f937c57b9">More...</a><br /></td></tr>
<tr class="separator:acc08afc805ba106adc3eb95f937c57b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778574f3ba3a70a0a289d8bdf30f9768"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a778574f3ba3a70a0a289d8bdf30f9768">operator*=</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;)</td></tr>
<tr class="memdesc:a778574f3ba3a70a0a289d8bdf30f9768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator of two quaternions. It multiplies right operand with the left operand and assign the result to left operand.  <a href="#a778574f3ba3a70a0a289d8bdf30f9768">More...</a><br /></td></tr>
<tr class="separator:a778574f3ba3a70a0a289d8bdf30f9768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea611b0ab50f84aec8e5c7216eac5dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a9ea611b0ab50f84aec8e5c7216eac5dd">operator*=</a> (const _Tp s)</td></tr>
<tr class="memdesc:a9ea611b0ab50f84aec8e5c7216eac5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication assignment operator of a quaternions and a scalar. It multiplies right operand with the left operand and assign the result to left operand.  <a href="#a9ea611b0ab50f84aec8e5c7216eac5dd">More...</a><br /></td></tr>
<tr class="separator:a9ea611b0ab50f84aec8e5c7216eac5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72001dc5a287b17ba232f2ce8858e4a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a72001dc5a287b17ba232f2ce8858e4a1">operator+</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;) const</td></tr>
<tr class="memdesc:a72001dc5a287b17ba232f2ce8858e4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator of two dual quaternions p and q. It returns a new dual quaternion that each value is the sum of \(p_i\) and \(q_i\).  <a href="#a72001dc5a287b17ba232f2ce8858e4a1">More...</a><br /></td></tr>
<tr class="separator:a72001dc5a287b17ba232f2ce8858e4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf776e6bb2db59b1bb41c020f009974d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#abf776e6bb2db59b1bb41c020f009974d">operator+=</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;)</td></tr>
<tr class="memdesc:abf776e6bb2db59b1bb41c020f009974d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition assignment operator of two dual quaternions p and q. It adds right operand to the left operand and assign the result to left operand.  <a href="#abf776e6bb2db59b1bb41c020f009974d">More...</a><br /></td></tr>
<tr class="separator:abf776e6bb2db59b1bb41c020f009974d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ed942ec933ed12ad97af39b28bb812"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#ac5ed942ec933ed12ad97af39b28bb812">operator-</a> () const</td></tr>
<tr class="memdesc:ac5ed942ec933ed12ad97af39b28bb812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return opposite dual quaternion \(-p\) which satisfies \(p + (-p) = 0.\).  <a href="#ac5ed942ec933ed12ad97af39b28bb812">More...</a><br /></td></tr>
<tr class="separator:ac5ed942ec933ed12ad97af39b28bb812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e94de472b406de14e26bc7101e02e69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a9e94de472b406de14e26bc7101e02e69">operator-</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;) const</td></tr>
<tr class="memdesc:a9e94de472b406de14e26bc7101e02e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator of two dual quaternions p and q. It returns a new dual quaternion that each value is the sum of \(p_i\) and \(-q_i\).  <a href="#a9e94de472b406de14e26bc7101e02e69">More...</a><br /></td></tr>
<tr class="separator:a9e94de472b406de14e26bc7101e02e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cbd80551d0536f26c64465afe1596f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#ab0cbd80551d0536f26c64465afe1596f">operator-=</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;)</td></tr>
<tr class="memdesc:ab0cbd80551d0536f26c64465afe1596f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction assignment operator of two dual quaternions p and q. It subtracts right operand from the left operand and assign the result to left operand.  <a href="#ab0cbd80551d0536f26c64465afe1596f">More...</a><br /></td></tr>
<tr class="separator:ab0cbd80551d0536f26c64465afe1596f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34475d73ee90a3f5ac490a23b42784c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a34475d73ee90a3f5ac490a23b42784c0">operator/</a> (const _Tp s) const</td></tr>
<tr class="memdesc:a34475d73ee90a3f5ac490a23b42784c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator of a dual quaternions and a scalar. It divides left operand with the right operand and assign the result to left operand.  <a href="#a34475d73ee90a3f5ac490a23b42784c0">More...</a><br /></td></tr>
<tr class="separator:a34475d73ee90a3f5ac490a23b42784c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659fa8c0cc1375cc94344ab1adda466a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a659fa8c0cc1375cc94344ab1adda466a">operator/</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;) const</td></tr>
<tr class="memdesc:a659fa8c0cc1375cc94344ab1adda466a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator of two dual quaternions p and q. Divides left hand operand by right hand operand.  <a href="#a659fa8c0cc1375cc94344ab1adda466a">More...</a><br /></td></tr>
<tr class="separator:a659fa8c0cc1375cc94344ab1adda466a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321d607b60af29cb6b3f30a4ae38a014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a321d607b60af29cb6b3f30a4ae38a014">operator/=</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;)</td></tr>
<tr class="memdesc:a321d607b60af29cb6b3f30a4ae38a014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator of two dual quaternions p and q; It divides left operand with the right operand and assign the result to left operand.  <a href="#a321d607b60af29cb6b3f30a4ae38a014">More...</a><br /></td></tr>
<tr class="separator:a321d607b60af29cb6b3f30a4ae38a014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15efdbcef04faaf1c97fd1cdf1177c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt; _Tp &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a15efdbcef04faaf1c97fd1cdf1177c02">operator/=</a> (const _Tp s)</td></tr>
<tr class="memdesc:a15efdbcef04faaf1c97fd1cdf1177c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division assignment operator of a dual quaternions and a scalar. It divides left operand with the right operand and assign the result to left operand.  <a href="#a15efdbcef04faaf1c97fd1cdf1177c02">More...</a><br /></td></tr>
<tr class="separator:a15efdbcef04faaf1c97fd1cdf1177c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4019b91de3aeee1d7aa49f69564111aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a4019b91de3aeee1d7aa49f69564111aa">operator==</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;) const</td></tr>
<tr class="memdesc:a4019b91de3aeee1d7aa49f69564111aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if two dual quaternions p and q are nearly equal, i.e. when the absolute value of each \(p_i\) and \(q_i\) is less than CV_DUAL_QUAT_EPS.  <a href="#a4019b91de3aeee1d7aa49f69564111aa">More...</a><br /></td></tr>
<tr class="separator:a4019b91de3aeee1d7aa49f69564111aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584044c5eb948719c7ad58e6afbd8f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a584044c5eb948719c7ad58e6afbd8f26">power</a> (const _Tp t, <a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>) const</td></tr>
<tr class="memdesc:a584044c5eb948719c7ad58e6afbd8f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of \(p^t\) where p is a dual quaternion. This could be calculated as: </p><p class="formulaDsp">
\[ p^t = \exp(t\ln p) \]
</p>
  <a href="#a584044c5eb948719c7ad58e6afbd8f26">More...</a><br /></td></tr>
<tr class="separator:a584044c5eb948719c7ad58e6afbd8f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf28786137d7280555776d4e477b7a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#acdf28786137d7280555776d4e477b7a3">power</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;q, <a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>) const</td></tr>
<tr class="memdesc:acdf28786137d7280555776d4e477b7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of \(p^q\) where p and q are dual quaternions. This could be calculated as: </p><p class="formulaDsp">
\[ p^q = \exp(q\ln p) \]
</p>
  <a href="#acdf28786137d7280555776d4e477b7a3">More...</a><br /></td></tr>
<tr class="separator:acdf28786137d7280555776d4e477b7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14d558e309dcfa633fdf6aacdb36f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d99/classcv_1_1Affine3.html">Affine3</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#ab14d558e309dcfa633fdf6aacdb36f61">toAffine3</a> (<a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>) const</td></tr>
<tr class="memdesc:ab14d558e309dcfa633fdf6aacdb36f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform this dual quaternion to a instance of <a class="el" href="../../dd/d99/classcv_1_1Affine3.html" title="Affine transform. ">Affine3</a>.  <a href="#ab14d558e309dcfa633fdf6aacdb36f61">More...</a><br /></td></tr>
<tr class="separator:ab14d558e309dcfa633fdf6aacdb36f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5b3b4e905fa97a98a6510b73d46f07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/de1/classcv_1_1Matx.html">Matx</a>&lt; _Tp, 4, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a8a5b3b4e905fa97a98a6510b73d46f07">toMat</a> (<a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>) const</td></tr>
<tr class="memdesc:a8a5b3b4e905fa97a98a6510b73d46f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform this dual quaternion to a affine transformation matrix the form of matrix, see <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a43cca8c473dc36aa1c7d949e47014569" title="Transform this dual quaternion to an affine transformation matrix . Dual quaternion consists of a rot...">createFromMat()</a>.  <a href="#a8a5b3b4e905fa97a98a6510b73d46f07">More...</a><br /></td></tr>
<tr class="separator:a8a5b3b4e905fa97a98a6510b73d46f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89bd865b964f19bce31447817bcaa19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#af89bd865b964f19bce31447817bcaa19">toVec</a> () const</td></tr>
<tr class="memdesc:af89bd865b964f19bce31447817bcaa19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform this dual quaternion to a vector.  <a href="#af89bd865b964f19bce31447817bcaa19">More...</a><br /></td></tr>
<tr class="separator:af89bd865b964f19bce31447817bcaa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af0d95a14ad9b103a6fa49e85c21059c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#af0d95a14ad9b103a6fa49e85c21059c7">createFromAffine3</a> (const <a class="el" href="../../dd/d99/classcv_1_1Affine3.html">Affine3</a>&lt; _Tp &gt; &amp;R)</td></tr>
<tr class="memdesc:af0d95a14ad9b103a6fa49e85c21059c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">create dual quaternion from an affine matrix. The definition of affine matrix can refer to <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a43cca8c473dc36aa1c7d949e47014569" title="Transform this dual quaternion to an affine transformation matrix . Dual quaternion consists of a rot...">createFromMat()</a>  <a href="#af0d95a14ad9b103a6fa49e85c21059c7">More...</a><br /></td></tr>
<tr class="separator:af0d95a14ad9b103a6fa49e85c21059c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712a9d8703cefb274ac30fb5259e6290"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a712a9d8703cefb274ac30fb5259e6290">createFromAngleAxisTrans</a> (const _Tp angle, const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 3 &gt; &amp;axis, const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 3 &gt; &amp;translation)</td></tr>
<tr class="memdesc:a712a9d8703cefb274ac30fb5259e6290"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a dual quaternion from a rotation angle \(\theta\), a rotation axis \(\boldsymbol{u}\) and a translation \(\boldsymbol{t}\). It generates a dual quaternion \(\sigma\) in the form of </p><p class="formulaDsp">
\[\begin{equation} \begin{split} \sigma &amp;= r + \frac{\epsilon}{2}\boldsymbol{t}r \\ &amp;= [\cos(\frac{\theta}{2}), \boldsymbol{u}\sin(\frac{\theta}{2})] + \frac{\epsilon}{2}[0, \boldsymbol{t}][[\cos(\frac{\theta}{2}), \boldsymbol{u}\sin(\frac{\theta}{2})]]\\ &amp;= \cos(\frac{\theta}{2}) + \boldsymbol{u}\sin(\frac{\theta}{2}) + \frac{\epsilon}{2}(-(\boldsymbol{t} \cdot \boldsymbol{u})\sin(\frac{\theta}{2}) + \boldsymbol{t}\cos(\frac{\theta}{2}) + \boldsymbol{u} \times \boldsymbol{t} \sin(\frac{\theta}{2})). \end{split} \end{equation}\]
</p>
  <a href="#a712a9d8703cefb274ac30fb5259e6290">More...</a><br /></td></tr>
<tr class="separator:a712a9d8703cefb274ac30fb5259e6290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cca8c473dc36aa1c7d949e47014569"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a43cca8c473dc36aa1c7d949e47014569">createFromMat</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> _R)</td></tr>
<tr class="memdesc:a43cca8c473dc36aa1c7d949e47014569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform this dual quaternion to an affine transformation matrix \(M\). Dual quaternion consists of a rotation \(r=[a,b,c,d]\) and a translation \(t=[\Delta x,\Delta y,\Delta z]\). The affine transformation matrix \(M\) has the form </p><p class="formulaDsp">
\[ \begin{bmatrix} 1-2(e_2^2 +e_3^2) &amp;2(e_1e_2-e_0e_3) &amp;2(e_0e_2+e_1e_3) &amp;\Delta x\\ 2(e_0e_3+e_1e_2) &amp;1-2(e_1^2+e_3^2) &amp;2(e_2e_3-e_0e_1) &amp;\Delta y\\ 2(e_1e_3-e_0e_2) &amp;2(e_0e_1+e_2e_3) &amp;1-2(e_1^2-e_2^2) &amp;\Delta z\\ 0&amp;0&amp;0&amp;1 \end{bmatrix} \]
</p>
<p> if A is a matrix consisting of n points to be transformed, this could be achieved by </p><p class="formulaDsp">
\[ new\_A = M * A \]
</p>
<p> where A has the form </p><p class="formulaDsp">
\[ \begin{bmatrix} x_0&amp; x_1&amp; x_2&amp;...&amp;x_n\\ y_0&amp; y_1&amp; y_2&amp;...&amp;y_n\\ z_0&amp; z_1&amp; z_2&amp;...&amp;z_n\\ 1&amp;1&amp;1&amp;...&amp;1 \end{bmatrix} \]
</p>
<p> where the same subscript represent the same point. The size of A should be \([4,n]\). and the same size for matrix new_A.  <a href="#a43cca8c473dc36aa1c7d949e47014569">More...</a><br /></td></tr>
<tr class="separator:a43cca8c473dc36aa1c7d949e47014569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d7c9b2644edbc60363b27af5ac1769"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a38d7c9b2644edbc60363b27af5ac1769">createFromPitch</a> (const _Tp angle, const _Tp d, const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 3 &gt; &amp;axis, const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 3 &gt; &amp;moment)</td></tr>
<tr class="memdesc:a38d7c9b2644edbc60363b27af5ac1769"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dual quaternion is a vector in form of </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} \sigma &amp;=\boldsymbol{p} + \epsilon \boldsymbol{q}\\ &amp;= \cos\hat{\frac{\theta}{2}}+\overline{\hat{l}}\sin\frac{\hat{\theta}}{2} \end{split} \end{equation} \]
</p>
<p> where \(\hat{\theta}\) is dual angle and \(\overline{\hat{l}}\) is dual axis: </p><p class="formulaDsp">
\[ \hat{\theta}=\theta + \epsilon d,\\ \overline{\hat{l}}= \hat{l} +\epsilon m. \]
</p>
<p> In this representation, \(\theta\) is rotation angle and \((\hat{l},m)\) is the screw axis, d is the translation distance along the axis.  <a href="#a38d7c9b2644edbc60363b27af5ac1769">More...</a><br /></td></tr>
<tr class="separator:a38d7c9b2644edbc60363b27af5ac1769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e430e338126681e1961ee68a7be7ca5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a4e430e338126681e1961ee68a7be7ca5">createFromQuat</a> (const <a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt; _Tp &gt; &amp;realPart, const <a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt; _Tp &gt; &amp;dualPart)</td></tr>
<tr class="memdesc:a4e430e338126681e1961ee68a7be7ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">create Dual Quaternion from two same type quaternions p and q. A Dual Quaternion \(\sigma\) has the form: </p><p class="formulaDsp">
\[\sigma = p + \epsilon q\]
</p>
<p> where p and q are defined as follows: </p><p class="formulaDsp">
\[\begin{equation} \begin{split} p &amp;= w + x\boldsymbol{i} + y\boldsymbol{j} + z\boldsymbol{k}\\ q &amp;= w\_ + x\_\boldsymbol{i} + y\_\boldsymbol{j} + z\_\boldsymbol{k}. \end{split} \end{equation} \]
</p>
<p> The p and q are the real part and dual part respectively.  <a href="#a4e430e338126681e1961ee68a7be7ca5">More...</a><br /></td></tr>
<tr class="separator:a4e430e338126681e1961ee68a7be7ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb103c1e9acdc2bcb5d521fbcbe8ba1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a5fb103c1e9acdc2bcb5d521fbcbe8ba1">dqblend</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;q1, const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;q2, const _Tp t, <a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>)</td></tr>
<tr class="memdesc:a5fb103c1e9acdc2bcb5d521fbcbe8ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method of Dual Quaternion linear Blending(DQB) is to compute a transformation between dual quaternion \(q_1\) and \(q_2\) and can be defined as: </p><p class="formulaDsp">
\[ DQB(t;{\boldsymbol{q}}_1,{\boldsymbol{q}}_2)= \frac{(1-t){\boldsymbol{q}}_1+t{\boldsymbol{q}}_2}{||(1-t){\boldsymbol{q}}_1+t{\boldsymbol{q}}_2||}. \]
</p>
<p> where \(q_1\) and \(q_2\) are unit dual quaternions representing the input transformations. If you want to use DQB that works for more than two rigid transformations, see <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a1c156a294204b9981fdda1883d4746e0">gdqblend</a>.  <a href="#a5fb103c1e9acdc2bcb5d521fbcbe8ba1">More...</a><br /></td></tr>
<tr class="separator:a5fb103c1e9acdc2bcb5d521fbcbe8ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c156a294204b9981fdda1883d4746e0"><td class="memTemplParams" colspan="2">template&lt;int cn&gt; </td></tr>
<tr class="memitem:a1c156a294204b9981fdda1883d4746e0"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a1c156a294204b9981fdda1883d4746e0">gdqblend</a> (const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;, cn &gt; &amp;dualquat, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> weights, <a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>)</td></tr>
<tr class="memdesc:a1c156a294204b9981fdda1883d4746e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generalized Dual Quaternion linear Blending works for more than two rigid transformations. If these transformations are expressed as unit dual quaternions \(q_1,...,q_n\) with convex weights \(w = (w_1,...,w_n)\), the generalized DQB is simply </p><p class="formulaDsp">
\[ gDQB(\boldsymbol{w};{\boldsymbol{q}}_1,...,{\boldsymbol{q}}_n)=\frac{w_1{\boldsymbol{q}}_1+...+w_n{\boldsymbol{q}}_n} {||w_1{\boldsymbol{q}}_1+...+w_n{\boldsymbol{q}}_n||}. \]
</p>
<p>.  <a href="#a1c156a294204b9981fdda1883d4746e0">More...</a><br /></td></tr>
<tr class="separator:a1c156a294204b9981fdda1883d4746e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcc8a1f54fc481673f18abc66d3ea20"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#acfcc8a1f54fc481673f18abc66d3ea20">gdqblend</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> dualquat, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> weights, <a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>)</td></tr>
<tr class="memdesc:acfcc8a1f54fc481673f18abc66d3ea20"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generalized Dual Quaternion linear Blending works for more than two rigid transformations. If these transformations are expressed as unit dual quaternions \(q_1,...,q_n\) with convex weights \(w = (w_1,...,w_n)\), the generalized DQB is simply </p><p class="formulaDsp">
\[ gDQB(\boldsymbol{w};{\boldsymbol{q}}_1,...,{\boldsymbol{q}}_n)=\frac{w_1{\boldsymbol{q}}_1+...+w_n{\boldsymbol{q}}_n} {||w_1{\boldsymbol{q}}_1+...+w_n{\boldsymbol{q}}_n||}. \]
</p>
<p>.  <a href="#acfcc8a1f54fc481673f18abc66d3ea20">More...</a><br /></td></tr>
<tr class="separator:acfcc8a1f54fc481673f18abc66d3ea20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41a6b3392b05be90d7f4b501e4776e2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#ac41a6b3392b05be90d7f4b501e4776e2">sclerp</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;q1, const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;q2, const _Tp t, bool directChange=true, <a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit=<a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a>)</td></tr>
<tr class="memdesc:ac41a6b3392b05be90d7f4b501e4776e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The screw linear interpolation(ScLERP) is an extension of spherical linear interpolation of dual quaternion. If \(\sigma_1\) and \(\sigma_2\) are two dual quaternions representing the initial and final pose. The interpolation of ScLERP function can be defined as: </p><p class="formulaDsp">
\[ ScLERP(t;\sigma_1,\sigma_2) = \sigma_1 * (\sigma_1^{-1} * \sigma_2)^t, t\in[0,1] \]
</p>
<p>.  <a href="#ac41a6b3392b05be90d7f4b501e4776e2">More...</a><br /></td></tr>
<tr class="separator:ac41a6b3392b05be90d7f4b501e4776e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aea1571d04e7a8413d694c86ccb65a4ca"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#aea1571d04e7a8413d694c86ccb65a4ca">w</a></td></tr>
<tr class="separator:aea1571d04e7a8413d694c86ccb65a4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26df9a4cba469c1308b777b2a80d380c"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a26df9a4cba469c1308b777b2a80d380c">w_</a></td></tr>
<tr class="separator:a26df9a4cba469c1308b777b2a80d380c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85106b84b92f42e36c550865935377a0"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a85106b84b92f42e36c550865935377a0">x</a></td></tr>
<tr class="separator:a85106b84b92f42e36c550865935377a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5a3b9f89b32fc12ebd6f75f2392221"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a5d5a3b9f89b32fc12ebd6f75f2392221">x_</a></td></tr>
<tr class="separator:a5d5a3b9f89b32fc12ebd6f75f2392221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5bdf3d341452e406d2ab9878e435a9"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a0d5bdf3d341452e406d2ab9878e435a9">y</a></td></tr>
<tr class="separator:a0d5bdf3d341452e406d2ab9878e435a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0112c38fdb2e93d6bade42a1234447d5"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a0112c38fdb2e93d6bade42a1234447d5">y_</a></td></tr>
<tr class="separator:a0112c38fdb2e93d6bade42a1234447d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26885c85d72c4b9bc42d229b76e3790"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#ad26885c85d72c4b9bc42d229b76e3790">z</a></td></tr>
<tr class="separator:ad26885c85d72c4b9bc42d229b76e3790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38eccd00b69906fa7c72a7a81b8f5c0e"><td class="memItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a38eccd00b69906fa7c72a7a81b8f5c0e">z_</a></td></tr>
<tr class="separator:a38eccd00b69906fa7c72a7a81b8f5c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac74101d333e3652e09de0f2340f9786d"><td class="memItemLeft" align="right" valign="top">static constexpr _Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#ac74101d333e3652e09de0f2340f9786d">CV_DUAL_QUAT_EPS</a> = (_Tp)1.e-6</td></tr>
<tr class="separator:ac74101d333e3652e09de0f2340f9786d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a81613a490924aa120746b082479635a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81613a490924aa120746b082479635a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a81613a490924aa120746b082479635a0">conjugate</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;dq)</td></tr>
<tr class="memdesc:a81613a490924aa120746b082479635a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the conjugate of a dual quaternion. </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} \sigma^* &amp;= (p + \epsilon q)^* &amp;= (p^* + \epsilon q^*) \end{split} \end{equation} \]
</p>
  <a href="#a81613a490924aa120746b082479635a0">More...</a><br /></td></tr>
<tr class="separator:a81613a490924aa120746b082479635a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ea7ff7f278a9cc7522f790e21ca283"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a68ea7ff7f278a9cc7522f790e21ca283"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a68ea7ff7f278a9cc7522f790e21ca283">cv::operator*</a> (const T s, const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:a68ea7ff7f278a9cc7522f790e21ca283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator of a scalar and a dual quaternions. It multiplies right operand with the left operand and assign the result to left operand.  <a href="#a68ea7ff7f278a9cc7522f790e21ca283">More...</a><br /></td></tr>
<tr class="separator:a68ea7ff7f278a9cc7522f790e21ca283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01da07f1b74f7cfed4951d3706b56980"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01da07f1b74f7cfed4951d3706b56980"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a01da07f1b74f7cfed4951d3706b56980">cv::operator*</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;, const T s)</td></tr>
<tr class="memdesc:a01da07f1b74f7cfed4951d3706b56980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator of a dual quaternions and a scalar. It multiplies right operand with the left operand and assign the result to left operand.  <a href="#a01da07f1b74f7cfed4951d3706b56980">More...</a><br /></td></tr>
<tr class="separator:a01da07f1b74f7cfed4951d3706b56980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db15a6b7f7799eef3a204f21590091"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4db15a6b7f7799eef3a204f21590091"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#af4db15a6b7f7799eef3a204f21590091">cv::operator+</a> (const T s, const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:af4db15a6b7f7799eef3a204f21590091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator of a scalar and a dual quaternions. Adds right hand operand from left hand operand.  <a href="#af4db15a6b7f7799eef3a204f21590091">More...</a><br /></td></tr>
<tr class="separator:af4db15a6b7f7799eef3a204f21590091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571778a813a3fe0bc244d6da8aa28837"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a571778a813a3fe0bc244d6da8aa28837"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a571778a813a3fe0bc244d6da8aa28837">cv::operator+</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;, const T s)</td></tr>
<tr class="memdesc:a571778a813a3fe0bc244d6da8aa28837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator of a dual quaternions and a scalar. Adds right hand operand from left hand operand.  <a href="#a571778a813a3fe0bc244d6da8aa28837">More...</a><br /></td></tr>
<tr class="separator:a571778a813a3fe0bc244d6da8aa28837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51131916f59c701667ce3e76a8778345"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51131916f59c701667ce3e76a8778345"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a51131916f59c701667ce3e76a8778345">cv::operator-</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;, const T s)</td></tr>
<tr class="memdesc:a51131916f59c701667ce3e76a8778345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator of a dual quaternion and a scalar. Subtracts right hand operand from left hand operand.  <a href="#a51131916f59c701667ce3e76a8778345">More...</a><br /></td></tr>
<tr class="separator:a51131916f59c701667ce3e76a8778345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b5e2f3f8b78af1187d0d69a2a3b327"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9b5e2f3f8b78af1187d0d69a2a3b327"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#ab9b5e2f3f8b78af1187d0d69a2a3b327">cv::operator-</a> (const T s, const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:ab9b5e2f3f8b78af1187d0d69a2a3b327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator of a scalar and a dual quaternions. Subtracts right hand operand from left hand operand.  <a href="#ab9b5e2f3f8b78af1187d0d69a2a3b327">More...</a><br /></td></tr>
<tr class="separator:ab9b5e2f3f8b78af1187d0d69a2a3b327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2b6d317096dc817507948e7bce50b8"><td class="memTemplParams" colspan="2">template&lt;typename S &gt; </td></tr>
<tr class="memitem:a0f2b6d317096dc817507948e7bce50b8"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a0f2b6d317096dc817507948e7bce50b8">cv::operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; S &gt; &amp;)</td></tr>
<tr class="separator:a0f2b6d317096dc817507948e7bce50b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788fb4de177d8741ecdcd1077c512554"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a788fb4de177d8741ecdcd1077c512554"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a788fb4de177d8741ecdcd1077c512554">exp</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;dq)</td></tr>
<tr class="memdesc:a788fb4de177d8741ecdcd1077c512554"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of exponential function value  <a href="#a788fb4de177d8741ecdcd1077c512554">More...</a><br /></td></tr>
<tr class="separator:a788fb4de177d8741ecdcd1077c512554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d16beba80dafe4489a150c7f9be0118"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d16beba80dafe4489a150c7f9be0118"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a9d16beba80dafe4489a150c7f9be0118">inv</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;dq, <a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit)</td></tr>
<tr class="memdesc:a9d16beba80dafe4489a150c7f9be0118"><td class="mdescLeft">&#160;</td><td class="mdescRight">if \(\sigma = p + \epsilon q\) is a dual quaternion, p is not zero, the inverse dual quaternion is </p><p class="formulaDsp">
\[\sigma^{-1} = \frac{\sigma^*}{||\sigma||^2}, \]
</p>
<p> or equivalentlly, </p><p class="formulaDsp">
\[\sigma^{-1} = p^{-1} - \epsilon p^{-1}qp^{-1}.\]
</p>
  <a href="#a9d16beba80dafe4489a150c7f9be0118">More...</a><br /></td></tr>
<tr class="separator:a9d16beba80dafe4489a150c7f9be0118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc83f28ffe66945a74e73a11a087c69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fc83f28ffe66945a74e73a11a087c69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a0fc83f28ffe66945a74e73a11a087c69">log</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;dq, <a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit)</td></tr>
<tr class="memdesc:a0fc83f28ffe66945a74e73a11a087c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of logarithm function value  <a href="#a0fc83f28ffe66945a74e73a11a087c69">More...</a><br /></td></tr>
<tr class="separator:a0fc83f28ffe66945a74e73a11a087c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458cd35347fe1729f9180644c83dc192"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a458cd35347fe1729f9180644c83dc192"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a458cd35347fe1729f9180644c83dc192">power</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;dq, const T t, <a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit)</td></tr>
<tr class="memdesc:a458cd35347fe1729f9180644c83dc192"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of \(p^t\) where p is a dual quaternion. This could be calculated as: </p><p class="formulaDsp">
\[ p^t = \exp(t\ln p) \]
</p>
  <a href="#a458cd35347fe1729f9180644c83dc192">More...</a><br /></td></tr>
<tr class="separator:a458cd35347fe1729f9180644c83dc192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcc7470f4f339ee60dbfa6bf1634731"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fcc7470f4f339ee60dbfa6bf1634731"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a6fcc7470f4f339ee60dbfa6bf1634731">power</a> (const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;p, const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;q, <a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a> assumeUnit)</td></tr>
<tr class="memdesc:a6fcc7470f4f339ee60dbfa6bf1634731"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the value of \(p^q\) where p and q are dual quaternions. This could be calculated as: </p><p class="formulaDsp">
\[ p^q = \exp(q\ln p) \]
</p>
  <a href="#a6fcc7470f4f339ee60dbfa6bf1634731">More...</a><br /></td></tr>
<tr class="separator:a6fcc7470f4f339ee60dbfa6bf1634731"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Tp&gt;<br />
class cv::DualQuat&lt; _Tp &gt;</h3>

<p>Dual quaternions were introduced to describe rotation together with translation while ordinary quaternions can only describe rotation. It can be used for shortest path pose interpolation, local pose optimization or volumetric deformation. More details can be found</p><ul>
<li><a href="https://en.wikipedia.org/wiki/Dual_quaternion">https://en.wikipedia.org/wiki/Dual_quaternion</a></li>
<li><a href="https://borodust.org/public/shared/beginner_dual_quats.pdf">"A beginners guide to dual-quaternions: what they are, how they work, and how to use them for 3D character hierarchies", Ben Kenwright, 2012</a></li>
<li><a href="http://web.cs.iastate.edu/~cs577/handouts/dual-quaternion.pdf">"Dual Quaternions", Yan-Bin Jia, 2013</a></li>
<li><a href="https://www.cs.utah.edu/~ladislav/kavan08geometric/kavan08geometric">"Geometric Skinning with Approximate Dual Quaternion Blending", Kavan, 2008</a></li>
<li><a href="http://rodolphe-vaillant.fr/?e=29">http://rodolphe-vaillant.fr/?e=29</a></li>
</ul>
<p>A unit dual quaternion can be classically represented as: </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} \sigma &amp;= \left(r+\frac{\epsilon}{2}tr\right)\\ &amp;= [w, x, y, z, w\_, x\_, y\_, z\_] \end{split} \end{equation} \]
</p>
<p> where \(r, t\) represents the rotation (ordinary unit quaternion) and translation (pure ordinary quaternion) respectively.</p>
<p>A general dual quaternions which consist of two quaternions is usually represented in form of: </p><p class="formulaDsp">
\[ \sigma = p + \epsilon q \]
</p>
<p> where the introduced dual unit \(\epsilon\) satisfies \(\epsilon^2 = \epsilon^3 =...=0\), and \(p, q\) are quaternions.</p>
<p>Alternatively, dual quaternions can also be interpreted as four components which are all <a href="https://www.cs.utah.edu/~ladislav/kavan08geometric/kavan08geometric">dual numbers</a>: </p><p class="formulaDsp">
\[ \sigma = \hat{q}_w + \hat{q}_xi + \hat{q}_yj + \hat{q}_zk \]
</p>
<p> If we set \(\hat{q}_x, \hat{q}_y\) and \(\hat{q}_z\) equal to 0, a dual quaternion is transformed to a dual number. see <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a49fb64a8e458fd953bb085da63a76ddf" title="return a normalized dual quaternion. A dual quaternion can be expressed as  where  represents the rot...">normalize()</a>.</p>
<p>If you want to create a dual quaternion, you can use:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d2/d75/namespacecv.html">cv</a>;</div><div class="line"><span class="keywordtype">double</span> angle = <a class="code" href="../../db/de0/group__core__utils.html#ga677b89fae9308b340ddaebf0dba8455f">CV_PI</a>;</div><div class="line"></div><div class="line"><span class="comment">// create from eight number</span></div><div class="line"><a class="code" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuatd</a> dq1(1, 2, 3, 4, 5, 6, 7, 8); <span class="comment">//p = [1,2,3,4]. q=[5,6,7,8]</span></div><div class="line"></div><div class="line"><span class="comment">// create from Vec</span></div><div class="line"><a class="code" href="../../d6/dcf/classcv_1_1Vec.html">Vec&lt;double, 8&gt;</a> v{1,2,3,4,5,6,7,8};</div><div class="line"><a class="code" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuatd</a> dq_v{v};</div><div class="line"></div><div class="line"><span class="comment">// create from two quaternion</span></div><div class="line"><a class="code" href="../../da/d4a/classcv_1_1Quat.html">Quatd</a> p(1, 2, 3, 4);</div><div class="line"><a class="code" href="../../da/d4a/classcv_1_1Quat.html">Quatd</a> q(5, 6, 7, 8);</div><div class="line"><a class="code" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuatd</a> dq2 = <a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#a4e430e338126681e1961ee68a7be7ca5">DualQuatd::createFromQuat</a>(p, q);</div><div class="line"></div><div class="line"><span class="comment">// create from an angle, an axis and a translation</span></div><div class="line"><a class="code" href="../../d6/dcf/classcv_1_1Vec.html">Vec3d</a> axis{0, 0, 1};</div><div class="line"><a class="code" href="../../d6/dcf/classcv_1_1Vec.html">Vec3d</a> trans{3, 4, 5};</div><div class="line"><a class="code" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuatd</a> dq3 = <a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#a712a9d8703cefb274ac30fb5259e6290">DualQuatd::createFromAngleAxisTrans</a>(angle, axis, trans);</div><div class="line"></div><div class="line"><span class="comment">// If you already have an instance of class Affine3, then you can use</span></div><div class="line"><a class="code" href="../../dd/d99/classcv_1_1Affine3.html">Affine3d</a> R = dq3.<a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#ab14d558e309dcfa633fdf6aacdb36f61">toAffine3</a>();</div><div class="line"><a class="code" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuatd</a> dq4 = <a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#af0d95a14ad9b103a6fa49e85c21059c7">DualQuatd::createFromAffine3</a>(R);</div><div class="line"></div><div class="line"><span class="comment">// or create directly by affine transformation matrix Rt</span></div><div class="line"><span class="comment">// see createFromMat() in detail for the form of Rt</span></div><div class="line"><a class="code" href="../../de/de1/classcv_1_1Matx.html">Matx44d</a> Rt = dq3.<a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#a8a5b3b4e905fa97a98a6510b73d46f07">toMat</a>();</div><div class="line"><a class="code" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuatd</a> dq5 = <a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#a43cca8c473dc36aa1c7d949e47014569">DualQuatd::createFromMat</a>(Rt);</div><div class="line"></div><div class="line"><span class="comment">// Any rotation + translation movement can</span></div><div class="line"><span class="comment">// be expressed as a rotation + translation around the same line in space (expressed by Plucker</span></div><div class="line"><span class="comment">// coords), and here&#39;s a way to represent it this way.</span></div><div class="line"><a class="code" href="../../d6/dcf/classcv_1_1Vec.html">Vec3d</a> axis{1, 1, 1}; <span class="comment">// axis will be normalized in createFromPitch</span></div><div class="line"><a class="code" href="../../d6/dcf/classcv_1_1Vec.html">Vec3d</a> trans{3, 4 ,5};</div><div class="line">axis = axis / <a class="code" href="../../d0/de1/group__core.html#ga9070b6a3f093dd952d973819b06f4906">std::sqrt</a>(axis.dot(axis));<span class="comment">// The formula for computing moment that I use below requires a normalized axis</span></div><div class="line"><a class="code" href="../../d6/dcf/classcv_1_1Vec.html">Vec3d</a> moment = 1.0 / 2 * (trans.cross(axis) + axis.cross(trans.cross(axis)) *</div><div class="line">                           <a class="code" href="../../d0/de1/group__core.html#gaf0f2fe47183d063fb7415097fbadb570">std::cos</a>(rotation_angle / 2) / <a class="code" href="../../d0/de1/group__core.html#ga53a8656033a51db64caa72ee9d4e93b4">std::sin</a>(rotation_angle / 2));</div><div class="line"><span class="keywordtype">double</span> d = trans.<a class="code" href="../../de/de1/classcv_1_1Matx.html#aff0ce90dadd68822c348b0bbae4a5f2a">dot</a>(qaxis);</div><div class="line"><a class="code" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuatd</a> dq6 = <a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#a38d7c9b2644edbc60363b27af5ac1769">DualQuatd::createFromPitch</a>(angle, d, axis, moment);</div></div><!-- fragment --><p>A point \(v=(x, y, z)\) in form of dual quaternion is \([1+\epsilon v]=[1,0,0,0,0,x,y,z]\). The transformation of a point \(v_1\) to another point \(v_2\) under the dual quaternion \(\sigma\) is </p><p class="formulaDsp">
\[ 1 + \epsilon v_2 = \sigma * (1 + \epsilon v_1) * \sigma^{\star} \]
</p>
<p> where \(\sigma^{\star}=p^*-\epsilon q^*.\)</p>
<p>A line in the \(Pl\ddot{u}cker\) coordinates \((\hat{l}, m)\) defined by the dual quaternion \(l=\hat{l}+\epsilon m\). To transform a line, </p><p class="formulaDsp">
\[l_2 = \sigma * l_1 * \sigma^*,\]
</p>
<p> where \(\sigma=r+\frac{\epsilon}{2}rt\) and \(\sigma^*=p^*+\epsilon q^*\).</p>
<p>To extract the Vec&lt;double, 8&gt; or Vec&lt;float, 8&gt;, see <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#af89bd865b964f19bce31447817bcaa19" title="Transform this dual quaternion to a vector. ">toVec()</a>;</p>
<p>To extract the affine transformation matrix, see <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a8a5b3b4e905fa97a98a6510b73d46f07" title="Transform this dual quaternion to a affine transformation matrix the form of matrix, see createFromMat(). ">toMat()</a>;</p>
<p>To extract the instance of <a class="el" href="../../dd/d99/classcv_1_1Affine3.html" title="Affine transform. ">Affine3</a>, see <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#ab14d558e309dcfa633fdf6aacdb36f61" title="Transform this dual quaternion to a instance of Affine3. ">toAffine3()</a>;</p>
<p>If two quaternions \(q_0, q_1\) are needed to be interpolated, you can use <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#ac41a6b3392b05be90d7f4b501e4776e2" title="The screw linear interpolation(ScLERP) is an extension of spherical linear interpolation of dual quat...">sclerp()</a> </p><div class="fragment"><div class="line"><a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#ac41a6b3392b05be90d7f4b501e4776e2">DualQuatd::sclerp</a>(q0, q1, t)</div></div><!-- fragment --><p> or <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a5fb103c1e9acdc2bcb5d521fbcbe8ba1" title="The method of Dual Quaternion linear Blending(DQB) is to compute a transformation between dual quater...">dqblend()</a>. </p><div class="fragment"><div class="line"><a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#a5fb103c1e9acdc2bcb5d521fbcbe8ba1">DualQuatd::dqblend</a>(q0, q1, t)</div></div><!-- fragment --><p> With more than two dual quaternions to be blended, you can use generalize linear dual quaternion blending with the corresponding weights, i.e. <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a1c156a294204b9981fdda1883d4746e0" title="The generalized Dual Quaternion linear Blending works for more than two rigid transformations. If these transformations are expressed as unit dual quaternions  with convex weights , the generalized DQB is simply . ">gdqblend()</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a46806b056f582b8a01376a9e4f206c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46806b056f582b8a01376a9e4f206c98">&#9670;&nbsp;</a></span>DualQuat() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::<a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0240c655a7264bf51ec577832b8ea664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0240c655a7264bf51ec577832b8ea664">&#9670;&nbsp;</a></span>DualQuat() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::<a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a> </td>
          <td>(</td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>w_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>x_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>y_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>z_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create from eight same type numbers. </p>

</div>
</div>
<a id="a087c15b9ffa06f4ea5eb6223742dff02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087c15b9ffa06f4ea5eb6223742dff02">&#9670;&nbsp;</a></span>DualQuat() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::<a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create from a double or float vector. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="affe17c67111b841c3cbb4798cc4183f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe17c67111b841c3cbb4798cc4183f2">&#9670;&nbsp;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::conjugate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the conjugate of a dual quaternion. </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} \sigma^* &amp;= (p + \epsilon q)^* &amp;= (p^* + \epsilon q^*) \end{split} \end{equation} \]
</p>
 </p>

</div>
</div>
<a id="af0d95a14ad9b103a6fa49e85c21059c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d95a14ad9b103a6fa49e85c21059c7">&#9670;&nbsp;</a></span>createFromAffine3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::createFromAffine3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d99/classcv_1_1Affine3.html">Affine3</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create dual quaternion from an affine matrix. The definition of affine matrix can refer to <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a43cca8c473dc36aa1c7d949e47014569" title="Transform this dual quaternion to an affine transformation matrix . Dual quaternion consists of a rot...">createFromMat()</a> </p>

</div>
</div>
<a id="a712a9d8703cefb274ac30fb5259e6290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712a9d8703cefb274ac30fb5259e6290">&#9670;&nbsp;</a></span>createFromAngleAxisTrans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::createFromAngleAxisTrans </td>
          <td>(</td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a dual quaternion from a rotation angle \(\theta\), a rotation axis \(\boldsymbol{u}\) and a translation \(\boldsymbol{t}\). It generates a dual quaternion \(\sigma\) in the form of </p><p class="formulaDsp">
\[\begin{equation} \begin{split} \sigma &amp;= r + \frac{\epsilon}{2}\boldsymbol{t}r \\ &amp;= [\cos(\frac{\theta}{2}), \boldsymbol{u}\sin(\frac{\theta}{2})] + \frac{\epsilon}{2}[0, \boldsymbol{t}][[\cos(\frac{\theta}{2}), \boldsymbol{u}\sin(\frac{\theta}{2})]]\\ &amp;= \cos(\frac{\theta}{2}) + \boldsymbol{u}\sin(\frac{\theta}{2}) + \frac{\epsilon}{2}(-(\boldsymbol{t} \cdot \boldsymbol{u})\sin(\frac{\theta}{2}) + \boldsymbol{t}\cos(\frac{\theta}{2}) + \boldsymbol{u} \times \boldsymbol{t} \sin(\frac{\theta}{2})). \end{split} \end{equation}\]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>rotation angle. </td></tr>
    <tr><td class="paramname">axis</td><td>rotation axis. </td></tr>
    <tr><td class="paramname">translation</td><td>a vector of length 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Axis will be normalized in this function. And translation is applied after the rotation. Use <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a4e430e338126681e1961ee68a7be7ca5">createFromQuat</a>(r, r * t / 2) to create a dual quaternion which translation is applied before rotation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a> </dd></dl>

</div>
</div>
<a id="a43cca8c473dc36aa1c7d949e47014569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cca8c473dc36aa1c7d949e47014569">&#9670;&nbsp;</a></span>createFromMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::createFromMat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a>&#160;</td>
          <td class="paramname"><em>_R</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform this dual quaternion to an affine transformation matrix \(M\). Dual quaternion consists of a rotation \(r=[a,b,c,d]\) and a translation \(t=[\Delta x,\Delta y,\Delta z]\). The affine transformation matrix \(M\) has the form </p><p class="formulaDsp">
\[ \begin{bmatrix} 1-2(e_2^2 +e_3^2) &amp;2(e_1e_2-e_0e_3) &amp;2(e_0e_2+e_1e_3) &amp;\Delta x\\ 2(e_0e_3+e_1e_2) &amp;1-2(e_1^2+e_3^2) &amp;2(e_2e_3-e_0e_1) &amp;\Delta y\\ 2(e_1e_3-e_0e_2) &amp;2(e_0e_1+e_2e_3) &amp;1-2(e_1^2-e_2^2) &amp;\Delta z\\ 0&amp;0&amp;0&amp;1 \end{bmatrix} \]
</p>
<p> if A is a matrix consisting of n points to be transformed, this could be achieved by </p><p class="formulaDsp">
\[ new\_A = M * A \]
</p>
<p> where A has the form </p><p class="formulaDsp">
\[ \begin{bmatrix} x_0&amp; x_1&amp; x_2&amp;...&amp;x_n\\ y_0&amp; y_1&amp; y_2&amp;...&amp;y_n\\ z_0&amp; z_1&amp; z_2&amp;...&amp;z_n\\ 1&amp;1&amp;1&amp;...&amp;1 \end{bmatrix} \]
</p>
<p> where the same subscript represent the same point. The size of A should be \([4,n]\). and the same size for matrix new_A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_R</td><td>4x4 matrix that represents rotations and translation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Translation is applied after the rotation. Use createFromQuat(r, r * t / 2) to create a dual quaternion which translation is applied before rotation. </dd></dl>

</div>
</div>
<a id="a38d7c9b2644edbc60363b27af5ac1769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d7c9b2644edbc60363b27af5ac1769">&#9670;&nbsp;</a></span>createFromPitch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::createFromPitch </td>
          <td>(</td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; _Tp, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>moment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A dual quaternion is a vector in form of </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} \sigma &amp;=\boldsymbol{p} + \epsilon \boldsymbol{q}\\ &amp;= \cos\hat{\frac{\theta}{2}}+\overline{\hat{l}}\sin\frac{\hat{\theta}}{2} \end{split} \end{equation} \]
</p>
<p> where \(\hat{\theta}\) is dual angle and \(\overline{\hat{l}}\) is dual axis: </p><p class="formulaDsp">
\[ \hat{\theta}=\theta + \epsilon d,\\ \overline{\hat{l}}= \hat{l} +\epsilon m. \]
</p>
<p> In this representation, \(\theta\) is rotation angle and \((\hat{l},m)\) is the screw axis, d is the translation distance along the axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>rotation angle. </td></tr>
    <tr><td class="paramname">d</td><td>translation along the rotation axis. </td></tr>
    <tr><td class="paramname">axis</td><td>rotation axis represented by quaternion with w = 0. </td></tr>
    <tr><td class="paramname">moment</td><td>the moment of line, and it should be orthogonal to axis. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Translation is applied after the rotation. Use createFromQuat(r, r * t / 2) to create a dual quaternion which translation is applied before rotation. </dd></dl>

</div>
</div>
<a id="a4e430e338126681e1961ee68a7be7ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e430e338126681e1961ee68a7be7ca5">&#9670;&nbsp;</a></span>createFromQuat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::createFromQuat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>realPart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>dualPart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create Dual Quaternion from two same type quaternions p and q. A Dual Quaternion \(\sigma\) has the form: </p><p class="formulaDsp">
\[\sigma = p + \epsilon q\]
</p>
<p> where p and q are defined as follows: </p><p class="formulaDsp">
\[\begin{equation} \begin{split} p &amp;= w + x\boldsymbol{i} + y\boldsymbol{j} + z\boldsymbol{k}\\ q &amp;= w\_ + x\_\boldsymbol{i} + y\_\boldsymbol{j} + z\_\boldsymbol{k}. \end{split} \end{equation} \]
</p>
<p> The p and q are the real part and dual part respectively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">realPart</td><td>a quaternion, real part of dual quaternion. </td></tr>
    <tr><td class="paramname">dualPart</td><td>a quaternion, dual part of dual quaternion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a> </dd></dl>

</div>
</div>
<a id="a167be7d41482406ede53614790bccaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167be7d41482406ede53614790bccaf0">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the dot product of two dual quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>other dual quaternion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fb103c1e9acdc2bcb5d521fbcbe8ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb103c1e9acdc2bcb5d521fbcbe8ba1">&#9670;&nbsp;</a></span>dqblend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::dqblend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The method of Dual Quaternion linear Blending(DQB) is to compute a transformation between dual quaternion \(q_1\) and \(q_2\) and can be defined as: </p><p class="formulaDsp">
\[ DQB(t;{\boldsymbol{q}}_1,{\boldsymbol{q}}_2)= \frac{(1-t){\boldsymbol{q}}_1+t{\boldsymbol{q}}_2}{||(1-t){\boldsymbol{q}}_1+t{\boldsymbol{q}}_2||}. \]
</p>
<p> where \(q_1\) and \(q_2\) are unit dual quaternions representing the input transformations. If you want to use DQB that works for more than two rigid transformations, see <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a1c156a294204b9981fdda1883d4746e0">gdqblend</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>a unit dual quaternion representing the input transformations. </td></tr>
    <tr><td class="paramname">q2</td><td>a unit dual quaternion representing the input transformations. </td></tr>
    <tr><td class="paramname">t</td><td>parameter \(t\in[0,1]\). </td></tr>
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, this dual quaternion assume to be a unit dual quaternion and this function will save some computations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a1c156a294204b9981fdda1883d4746e0" title="The generalized Dual Quaternion linear Blending works for more than two rigid transformations. If these transformations are expressed as unit dual quaternions  with convex weights , the generalized DQB is simply . ">gdqblend</a> </dd></dl>

</div>
</div>
<a id="af979a281d9545f7600e96f943f653799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af979a281d9545f7600e96f943f653799">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::exp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the value of exponential function value </p>

</div>
</div>
<a id="a1c156a294204b9981fdda1883d4746e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c156a294204b9981fdda1883d4746e0">&#9670;&nbsp;</a></span>gdqblend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;int cn&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::gdqblend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt;, cn &gt; &amp;&#160;</td>
          <td class="paramname"><em>dualquat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a>&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The generalized Dual Quaternion linear Blending works for more than two rigid transformations. If these transformations are expressed as unit dual quaternions \(q_1,...,q_n\) with convex weights \(w = (w_1,...,w_n)\), the generalized DQB is simply </p><p class="formulaDsp">
\[ gDQB(\boldsymbol{w};{\boldsymbol{q}}_1,...,{\boldsymbol{q}}_n)=\frac{w_1{\boldsymbol{q}}_1+...+w_n{\boldsymbol{q}}_n} {||w_1{\boldsymbol{q}}_1+...+w_n{\boldsymbol{q}}_n||}. \]
</p>
<p>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dualquat</td><td>vector of dual quaternions </td></tr>
    <tr><td class="paramname">weights</td><td>vector of weights, the size of weights should be the same as dualquat, and the weights should satisfy \(\sum_0^n w_{i} = 1\) and \(w_i&gt;0\). </td></tr>
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, these dual quaternions assume to be unit quaternions and this function will save some computations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the type of weights' element should be the same as the date type of dual quaternion inside the dualquat. </dd></dl>

</div>
</div>
<a id="acfcc8a1f54fc481673f18abc66d3ea20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcc8a1f54fc481673f18abc66d3ea20">&#9670;&nbsp;</a></span>gdqblend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::gdqblend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a>&#160;</td>
          <td class="paramname"><em>dualquat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a>&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The generalized Dual Quaternion linear Blending works for more than two rigid transformations. If these transformations are expressed as unit dual quaternions \(q_1,...,q_n\) with convex weights \(w = (w_1,...,w_n)\), the generalized DQB is simply </p><p class="formulaDsp">
\[ gDQB(\boldsymbol{w};{\boldsymbol{q}}_1,...,{\boldsymbol{q}}_n)=\frac{w_1{\boldsymbol{q}}_1+...+w_n{\boldsymbol{q}}_n} {||w_1{\boldsymbol{q}}_1+...+w_n{\boldsymbol{q}}_n||}. \]
</p>
<p>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dualquat</td><td>The dual quaternions which have 8 channels and 1 row or 1 col. </td></tr>
    <tr><td class="paramname">weights</td><td>vector of weights, the size of weights should be the same as dualquat, and the weights should satisfy \(\sum_0^n w_{i} = 1\) and \(w_i&gt;0\). </td></tr>
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, these dual quaternions assume to be unit quaternions and this function will save some computations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the type of weights' element should be the same as the date type of dual quaternion inside the dualquat. </dd></dl>

</div>
</div>
<a id="a38c4352024df650aca349ada165434d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c4352024df650aca349ada165434d1">&#9670;&nbsp;</a></span>getDualPart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::getDualPart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a quaternion which represent the dual part of dual quaternion. The definition of dual part is in <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a4e430e338126681e1961ee68a7be7ca5" title="create Dual Quaternion from two same type quaternions p and q. A Dual Quaternion  has the form:  wher...">createFromQuat()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a4e430e338126681e1961ee68a7be7ca5" title="create Dual Quaternion from two same type quaternions p and q. A Dual Quaternion  has the form:  wher...">createFromQuat</a>, <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a665f8d810b024494a63394e846dd5ff3" title="return a quaternion which represent the real part of dual quaternion. The definition of real part is ...">getRealPart</a> </dd></dl>

</div>
</div>
<a id="a665f8d810b024494a63394e846dd5ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665f8d810b024494a63394e846dd5ff3">&#9670;&nbsp;</a></span>getRealPart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::getRealPart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a quaternion which represent the real part of dual quaternion. The definition of real part is in <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a4e430e338126681e1961ee68a7be7ca5" title="create Dual Quaternion from two same type quaternions p and q. A Dual Quaternion  has the form:  wher...">createFromQuat()</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a4e430e338126681e1961ee68a7be7ca5" title="create Dual Quaternion from two same type quaternions p and q. A Dual Quaternion  has the form:  wher...">createFromQuat</a>, <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a38c4352024df650aca349ada165434d1" title="return a quaternion which represent the dual part of dual quaternion. The definition of dual part is ...">getDualPart</a> </dd></dl>

</div>
</div>
<a id="ab829bfbdc0221d95c579b93b77c89e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab829bfbdc0221d95c579b93b77c89e32">&#9670;&nbsp;</a></span>getRotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::getRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the rotation in quaternion form. </p>

</div>
</div>
<a id="a37a547bd8520e383742fef102cfa78a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a547bd8520e383742fef102cfa78a8">&#9670;&nbsp;</a></span>getTranslation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt;_Tp, 3&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::getTranslation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the translation vector. The rotation \(r\) in this dual quaternion \(\sigma\) is applied before translation \(t\). The dual quaternion \(\sigma\) is defined as </p><p class="formulaDsp">
\[\begin{equation} \begin{split} \sigma &amp;= p + \epsilon q \\ &amp;= r + \frac{\epsilon}{2}{t}r. \end{split} \end{equation}\]
</p>
<p> Thus, the translation can be obtained as follows </p><p class="formulaDsp">
\[t = 2qp^*.\]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, this dual quaternion assume to be a unit dual quaternion and this function will save some computations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This dual quaternion's translation is applied after the rotation. </dd></dl>

</div>
</div>
<a id="a251f740b34b08760d0ef2da3c80d8e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251f740b34b08760d0ef2da3c80d8e4d">&#9670;&nbsp;</a></span>inv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::inv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>if \(\sigma = p + \epsilon q\) is a dual quaternion, p is not zero, the inverse dual quaternion is </p><p class="formulaDsp">
\[\sigma^{-1} = \frac{\sigma^*}{||\sigma||^2}, \]
</p>
<p> or equivalentlly, </p><p class="formulaDsp">
\[\sigma^{-1} = p^{-1} - \epsilon p^{-1}qp^{-1}.\]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, this dual quaternion assume to be a unit dual quaternion and this function will save some computations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fbd9da54eba93738f815fbb047a5e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbd9da54eba93738f815fbb047a5e42">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::log </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the value of logarithm function value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, this dual quaternion assume to be a unit dual quaternion and this function will save some computations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29d27eb5d46951ed32cb80c81de22518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d27eb5d46951ed32cb80c81de22518">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the norm \(||\sigma||\) of dual quaternion \(\sigma = p + \epsilon q\). </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} ||\sigma|| &amp;= \sqrt{\sigma * \sigma^*} \\ &amp;= ||p|| + \epsilon \frac{p \cdot q}{||p||}. \end{split} \end{equation} \]
</p>
<p> Generally speaking, the norm of a not unit dual quaternion is a dual number. For convenience, we return it in the form of a dual quaternion , i.e. </p><p class="formulaDsp">
\[ ||\sigma|| = [||p||, 0, 0, 0, \frac{p \cdot q}{||p||}, 0, 0, 0].\]
</p>
 </p>
<dl class="section note"><dt>Note</dt><dd>The data type of dual number is dual quaternion. </dd></dl>

</div>
</div>
<a id="a49fb64a8e458fd953bb085da63a76ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fb64a8e458fd953bb085da63a76ddf">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::normalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a normalized dual quaternion. A dual quaternion can be expressed as </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} \sigma &amp;= p + \epsilon q\\ &amp;=||\sigma||\left(r+\frac{1}{2}tr\right) \end{split} \end{equation} \]
</p>
<p> where \(r, t\) represents the rotation (ordinary quaternion) and translation (pure ordinary quaternion) respectively, and \(||\sigma||\) is the norm of dual quaternion(a dual number). A dual quaternion is unit if and only if </p><p class="formulaDsp">
\[ ||p||=1, p \cdot q=0 \]
</p>
<p> where \(\cdot\) means dot product. The process of normalization is </p><p class="formulaDsp">
\[ \sigma_{u}=\frac{\sigma}{||\sigma||} \]
</p>
<p> Next, we simply proof \(\sigma_u\) is a unit dual quaternion: </p><p class="formulaDsp">
\[ \renewcommand{\Im}{\operatorname{Im}} \begin{equation} \begin{split} \sigma_{u}=\frac{\sigma}{||\sigma||}&amp;=\frac{p + \epsilon q}{||p||+\epsilon\frac{p\cdot q}{||p||}}\\ &amp;=\frac{p}{||p||}+\epsilon\left(\frac{q}{||p||}-p\frac{p\cdot q}{||p||^3}\right)\\ &amp;=\frac{p}{||p||}+\epsilon\frac{1}{||p||^2}\left(qp^{*}-p\cdot q\right)\frac{p}{||p||}\\ &amp;=\frac{p}{||p||}+\epsilon\frac{1}{||p||^2}\Im(qp^*)\frac{p}{||p||}.\\ \end{split} \end{equation} \]
</p>
<p> As expected, the real part is a rotation and dual part is a pure quaternion. </p>

</div>
</div>
<a id="acc08afc805ba106adc3eb95f937c57b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc08afc805ba106adc3eb95f937c57b9">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication operator of two dual quaternions q and p. Multiplies values on either side of the operator. </p>
<p>Rule of dual quaternion multiplication: The dual quaternion can be written as an ordered pair of quaternions [A, B]. Thus </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} p * q &amp;= [A, B][C, D]\\ &amp;=[AC, AD + BC] \end{split} \end{equation} \]
</p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> q{5, 6, 7, 8, 9, 10, 11, 12};</div><div class="line">std::cout &lt;&lt; p * q &lt;&lt; std::endl; <span class="comment">//[-60, 12, 30, 24, -216, 80, 124, 120]</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a778574f3ba3a70a0a289d8bdf30f9768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778574f3ba3a70a0a289d8bdf30f9768">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt;&amp; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication assignment operator of two quaternions. It multiplies right operand with the left operand and assign the result to left operand. </p>
<p>Rule of dual quaternion multiplication: The dual quaternion can be written as an ordered pair of quaternions [A, B]. Thus </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} p * q &amp;= [A, B][C, D]\\ &amp;=[AC, AD + BC] \end{split} \end{equation} \]
</p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> q{5, 6, 7, 8, 9, 10, 11, 12};</div><div class="line">p *= q;</div><div class="line">std::cout &lt;&lt; p &lt;&lt; std::endl; <span class="comment">//[-60, 12, 30, 24, -216, 80, 124, 120]</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a9ea611b0ab50f84aec8e5c7216eac5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea611b0ab50f84aec8e5c7216eac5dd">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication assignment operator of a quaternions and a scalar. It multiplies right operand with the left operand and assign the result to left operand. </p>
<p>Rule of dual quaternion multiplication with a scalar: </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} p * s &amp;= [w, x, y, z, w\_, x\_, y\_, z\_] * s\\ &amp;=[w s, x s, y s, z s, w\_ \space s, x\_ \space s, y\_ \space s, z\_ \space s]. \end{split} \end{equation} \]
</p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><span class="keywordtype">double</span> s = 2.0;</div><div class="line">p *= s;</div><div class="line">std::cout &lt;&lt; p &lt;&lt; std::endl; <span class="comment">//[2, 4, 6, 8, 10, 12, 14, 16]</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>the type of scalar should be equal to the dual quaternion. </dd></dl>

</div>
</div>
<a id="a72001dc5a287b17ba232f2ce8858e4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72001dc5a287b17ba232f2ce8858e4a1">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition operator of two dual quaternions p and q. It returns a new dual quaternion that each value is the sum of \(p_i\) and \(q_i\). </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> q{5, 6, 7, 8, 9, 10, 11, 12};</div><div class="line">std::cout &lt;&lt; p + q &lt;&lt; std::endl; <span class="comment">//[6, 8, 10, 12, 14, 16, 18, 20]</span></div></div><!-- fragment --> 
</div>
</div>
<a id="abf776e6bb2db59b1bb41c020f009974d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf776e6bb2db59b1bb41c020f009974d">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt;&amp; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addition assignment operator of two dual quaternions p and q. It adds right operand to the left operand and assign the result to left operand. </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> q{5, 6, 7, 8, 9, 10, 11, 12};</div><div class="line">p += q; <span class="comment">// equivalent to p = p + q</span></div><div class="line">std::cout &lt;&lt; p &lt;&lt; std::endl; <span class="comment">//[6, 8, 10, 12, 14, 16, 18, 20]</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ac5ed942ec933ed12ad97af39b28bb812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ed942ec933ed12ad97af39b28bb812">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return opposite dual quaternion \(-p\) which satisfies \(p + (-p) = 0.\). </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> q{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line">std::cout &lt;&lt; -q &lt;&lt; std::endl; <span class="comment">// [-1, -2, -3, -4, -5, -6, -7, -8]</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a9e94de472b406de14e26bc7101e02e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e94de472b406de14e26bc7101e02e69">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction operator of two dual quaternions p and q. It returns a new dual quaternion that each value is the sum of \(p_i\) and \(-q_i\). </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> q{5, 6, 7, 8, 9, 10, 11, 12};</div><div class="line">std::cout &lt;&lt; p - q &lt;&lt; std::endl; <span class="comment">//[-4, -4, -4, -4, 4, -4, -4, -4]</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ab0cbd80551d0536f26c64465afe1596f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0cbd80551d0536f26c64465afe1596f">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt;&amp; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtraction assignment operator of two dual quaternions p and q. It subtracts right operand from the left operand and assign the result to left operand. </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> q{5, 6, 7, 8, 9, 10, 11, 12};</div><div class="line">p -= q; <span class="comment">// equivalent to p = p - q</span></div><div class="line">std::cout &lt;&lt; p &lt;&lt; std::endl; <span class="comment">//[-4, -4, -4, -4, 4, -4, -4, -4]</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a34475d73ee90a3f5ac490a23b42784c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34475d73ee90a3f5ac490a23b42784c0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Division operator of a dual quaternions and a scalar. It divides left operand with the right operand and assign the result to left operand. </p>
<p>Rule of dual quaternion division with a scalar: </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} p / s &amp;= [w, x, y, z, w\_, x\_, y\_, z\_] / s\\ &amp;=[w/s, x/s, y/s, z/s, w\_/s, x\_/s, y\_/s, z\_/s]. \end{split} \end{equation} \]
</p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><span class="keywordtype">double</span> s = 2.0;</div><div class="line">p /= s; <span class="comment">// equivalent to p = p / s</span></div><div class="line">std::cout &lt;&lt; p &lt;&lt; std::endl; <span class="comment">//[0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4]</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>the type of scalar should be equal to this dual quaternion. </dd></dl>

</div>
</div>
<a id="a659fa8c0cc1375cc94344ab1adda466a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659fa8c0cc1375cc94344ab1adda466a">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Division operator of two dual quaternions p and q. Divides left hand operand by right hand operand. </p>
<p>Rule of dual quaternion division with a dual quaternion: </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} p / q &amp;= p * q.inv()\\ \end{split} \end{equation} \]
</p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> q{5, 6, 7, 8, 9, 10, 11, 12};</div><div class="line">std::cout &lt;&lt; p / q &lt;&lt; std::endl; <span class="comment">// equivalent to p * q.inv()</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a321d607b60af29cb6b3f30a4ae38a014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321d607b60af29cb6b3f30a4ae38a014">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt;&amp; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Division assignment operator of two dual quaternions p and q; It divides left operand with the right operand and assign the result to left operand. </p>
<p>Rule of dual quaternion division with a quaternion: </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} p / q&amp;= p * q.inv()\\ \end{split} \end{equation} \]
</p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> q{5, 6, 7, 8, 9, 10, 11, 12};</div><div class="line">p /= q; <span class="comment">// equivalent to p = p * q.inv()</span></div><div class="line">std::cout &lt;&lt; p &lt;&lt; std::endl;</div></div><!-- fragment --> 
</div>
</div>
<a id="a15efdbcef04faaf1c97fd1cdf1177c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15efdbcef04faaf1c97fd1cdf1177c02">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../da/d4a/classcv_1_1Quat.html">Quat</a>&lt;_Tp&gt;&amp; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Division assignment operator of a dual quaternions and a scalar. It divides left operand with the right operand and assign the result to left operand. </p>
<p>Rule of dual quaternion division with a scalar: </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} p / s &amp;= [w, x, y, z, w\_, x\_, y\_ ,z\_] / s\\ &amp;=[w / s, x / s, y / s, z / s, w\_ / \space s, x\_ / \space s, y\_ / \space s, z\_ / \space s]. \end{split} \end{equation} \]
</p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><span class="keywordtype">double</span> s = 2.0;;</div><div class="line">p /= s; <span class="comment">// equivalent to p = p / s</span></div><div class="line">std::cout &lt;&lt; p &lt;&lt; std::endl; <span class="comment">//[0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>the type of scalar should be equal to the dual quaternion. </dd></dl>

</div>
</div>
<a id="a4019b91de3aeee1d7aa49f69564111aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4019b91de3aeee1d7aa49f69564111aa">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return true if two dual quaternions p and q are nearly equal, i.e. when the absolute value of each \(p_i\) and \(q_i\) is less than CV_DUAL_QUAT_EPS. </p>

</div>
</div>
<a id="a584044c5eb948719c7ad58e6afbd8f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a584044c5eb948719c7ad58e6afbd8f26">&#9670;&nbsp;</a></span>power() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::power </td>
          <td>(</td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the value of \(p^t\) where p is a dual quaternion. This could be calculated as: </p><p class="formulaDsp">
\[ p^t = \exp(t\ln p) \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>index of power function. </td></tr>
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, this dual quaternion assume to be a unit dual quaternion and this function will save some computations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdf28786137d7280555776d4e477b7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf28786137d7280555776d4e477b7a3">&#9670;&nbsp;</a></span>power() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::power </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the value of \(p^q\) where p and q are dual quaternions. This could be calculated as: </p><p class="formulaDsp">
\[ p^q = \exp(q\ln p) \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>a dual quaternion </td></tr>
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, this dual quaternion assume to be a dual unit quaternion and this function will save some computations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41a6b3392b05be90d7f4b501e4776e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41a6b3392b05be90d7f4b501e4776e2">&#9670;&nbsp;</a></span>sclerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::sclerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directChange</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The screw linear interpolation(ScLERP) is an extension of spherical linear interpolation of dual quaternion. If \(\sigma_1\) and \(\sigma_2\) are two dual quaternions representing the initial and final pose. The interpolation of ScLERP function can be defined as: </p><p class="formulaDsp">
\[ ScLERP(t;\sigma_1,\sigma_2) = \sigma_1 * (\sigma_1^{-1} * \sigma_2)^t, t\in[0,1] \]
</p>
<p>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>a dual quaternion represents a initial pose. </td></tr>
    <tr><td class="paramname">q2</td><td>a dual quaternion represents a final pose. </td></tr>
    <tr><td class="paramname">t</td><td>interpolation parameter </td></tr>
    <tr><td class="paramname">directChange</td><td>if true, it always return the shortest path. </td></tr>
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, this dual quaternion assume to be a unit dual quaternion and this function will save some computations.</td></tr>
  </table>
  </dd>
</dl>
<p>For example </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> angle1 = <a class="code" href="../../db/de0/group__core__utils.html#ga677b89fae9308b340ddaebf0dba8455f">CV_PI</a> / 2;</div><div class="line"><a class="code" href="../../dc/d84/group__core__basic.html#ga370d94209693b5b13437ab4991cabf73">Vec3d</a> axis{0, 0, 1};</div><div class="line"><a class="code" href="../../dc/d84/group__core__basic.html#ga370d94209693b5b13437ab4991cabf73">Vec3d</a> t(0, 0, 3);</div><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> initial = <a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#a712a9d8703cefb274ac30fb5259e6290">DualQuatd::createFromAngleAxisTrans</a>(angle1, axis, t);</div><div class="line"><span class="keywordtype">double</span> angle2 = <a class="code" href="../../db/de0/group__core__utils.html#ga677b89fae9308b340ddaebf0dba8455f">CV_PI</a>;</div><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> <span class="keyword">final</span> = <a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#a712a9d8703cefb274ac30fb5259e6290">DualQuatd::createFromAngleAxisTrans</a>(angle2, axis, t);</div><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> inter = <a class="code" href="../../d4/db4/classcv_1_1DualQuat.html#ac41a6b3392b05be90d7f4b501e4776e2">DualQuatd::sclerp</a>(initial, <span class="keyword">final</span>, 0.5);</div></div><!-- fragment --> 
</div>
</div>
<a id="ab14d558e309dcfa633fdf6aacdb36f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14d558e309dcfa633fdf6aacdb36f61">&#9670;&nbsp;</a></span>toAffine3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d99/classcv_1_1Affine3.html">Affine3</a>&lt;_Tp&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::toAffine3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform this dual quaternion to a instance of <a class="el" href="../../dd/d99/classcv_1_1Affine3.html" title="Affine transform. ">Affine3</a>. </p>

</div>
</div>
<a id="a8a5b3b4e905fa97a98a6510b73d46f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5b3b4e905fa97a98a6510b73d46f07">&#9670;&nbsp;</a></span>toMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de1/classcv_1_1Matx.html">Matx</a>&lt;_Tp, 4, 4&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::toMat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em> = <code><a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea786f758552bf7be9ee5f12ca2157cf8f">QUAT_ASSUME_NOT_UNIT</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform this dual quaternion to a affine transformation matrix the form of matrix, see <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html#a43cca8c473dc36aa1c7d949e47014569" title="Transform this dual quaternion to an affine transformation matrix . Dual quaternion consists of a rot...">createFromMat()</a>. </p>

</div>
</div>
<a id="af89bd865b964f19bce31447817bcaa19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89bd865b964f19bce31447817bcaa19">&#9670;&nbsp;</a></span>toVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/dcf/classcv_1_1Vec.html">Vec</a>&lt;_Tp, 8&gt; <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::toVec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform this dual quaternion to a vector. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a81613a490924aa120746b082479635a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81613a490924aa120746b082479635a0">&#9670;&nbsp;</a></span>conjugate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; conjugate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the conjugate of a dual quaternion. </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} \sigma^* &amp;= (p + \epsilon q)^* &amp;= (p^* + \epsilon q^*) \end{split} \end{equation} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dq</td><td>a dual quaternion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68ea7ff7f278a9cc7522f790e21ca283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ea7ff7f278a9cc7522f790e21ca283">&#9670;&nbsp;</a></span>cv::operator* <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; cv::operator* </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator of a scalar and a dual quaternions. It multiplies right operand with the left operand and assign the result to left operand. </p>
<p>Rule of dual quaternion multiplication with a scalar: </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} p * s &amp;= [w, x, y, z, w\_, x\_, y\_, z\_] * s\\ &amp;=[w s, x s, y s, z s, w\_ \space s, x\_ \space s, y\_ \space s, z\_ \space s]. \end{split} \end{equation} \]
</p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><span class="keywordtype">double</span> s = 2.0;</div><div class="line">std::cout &lt;&lt; s * p &lt;&lt; std::endl; <span class="comment">//[2, 4, 6, 8, 10, 12, 14, 16]</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>the type of scalar should be equal to the dual quaternion. </dd></dl>

</div>
</div>
<a id="a01da07f1b74f7cfed4951d3706b56980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01da07f1b74f7cfed4951d3706b56980">&#9670;&nbsp;</a></span>cv::operator* <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; cv::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication operator of a dual quaternions and a scalar. It multiplies right operand with the left operand and assign the result to left operand. </p>
<p>Rule of dual quaternion multiplication with a scalar: </p><p class="formulaDsp">
\[ \begin{equation} \begin{split} p * s &amp;= [w, x, y, z, w\_, x\_, y\_, z\_] * s\\ &amp;=[w s, x s, y s, z s, w\_ \space s, x\_ \space s, y\_ \space s, z\_ \space s]. \end{split} \end{equation} \]
</p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><span class="keywordtype">double</span> s = 2.0;</div><div class="line">std::cout &lt;&lt; p * s &lt;&lt; std::endl; <span class="comment">//[2, 4, 6, 8, 10, 12, 14, 16]</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>the type of scalar should be equal to the dual quaternion. </dd></dl>

</div>
</div>
<a id="af4db15a6b7f7799eef3a204f21590091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4db15a6b7f7799eef3a204f21590091">&#9670;&nbsp;</a></span>cv::operator+ <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; cv::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator of a scalar and a dual quaternions. Adds right hand operand from left hand operand. </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><span class="keywordtype">double</span> scalar = 2.0;</div><div class="line">std::cout &lt;&lt; scalar + p &lt;&lt; std::endl; <span class="comment">//[3.0, 2, 3, 4, 5, 6, 7, 8]</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>the type of scalar should be equal to the dual quaternion. </dd></dl>

</div>
</div>
<a id="a571778a813a3fe0bc244d6da8aa28837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571778a813a3fe0bc244d6da8aa28837">&#9670;&nbsp;</a></span>cv::operator+ <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; cv::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Addition operator of a dual quaternions and a scalar. Adds right hand operand from left hand operand. </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><span class="keywordtype">double</span> scalar = 2.0;</div><div class="line">std::cout &lt;&lt; p + scalar &lt;&lt; std::endl; <span class="comment">//[3.0, 2, 3, 4, 5, 6, 7, 8]</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>the type of scalar should be equal to the dual quaternion. </dd></dl>

</div>
</div>
<a id="a51131916f59c701667ce3e76a8778345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51131916f59c701667ce3e76a8778345">&#9670;&nbsp;</a></span>cv::operator- <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; cv::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator of a dual quaternion and a scalar. Subtracts right hand operand from left hand operand. </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><span class="keywordtype">double</span> scalar = 2.0;</div><div class="line">std::cout &lt;&lt; p - scalar &lt;&lt; std::endl; <span class="comment">//[-1, 2, 3, 4, 5, 6, 7, 8]</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>the type of scalar should be equal to the dual quaternion. </dd></dl>

</div>
</div>
<a id="ab9b5e2f3f8b78af1187d0d69a2a3b327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b5e2f3f8b78af1187d0d69a2a3b327">&#9670;&nbsp;</a></span>cv::operator- <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; cv::operator- </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction operator of a scalar and a dual quaternions. Subtracts right hand operand from left hand operand. </p>
<p>For example </p><div class="fragment"><div class="line"><a class="code" href="../../d0/de1/group__core.html#ga1713065384a5cd1ce3ecdff9ebf5cf6b">DualQuatd</a> p{1, 2, 3, 4, 5, 6, 7, 8};</div><div class="line"><span class="keywordtype">double</span> scalar = 2.0;</div><div class="line">std::cout &lt;&lt; scalar - p &lt;&lt; std::endl; <span class="comment">//[1.0, -2, -3, -4, -5, -6, -7, -8]</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>the type of scalar should be equal to the dual quaternion. </dd></dl>

</div>
</div>
<a id="a0f2b6d317096dc817507948e7bce50b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2b6d317096dc817507948e7bce50b8">&#9670;&nbsp;</a></span>cv::operator<<</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; cv::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; S &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a788fb4de177d8741ecdcd1077c512554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788fb4de177d8741ecdcd1077c512554">&#9670;&nbsp;</a></span>exp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; exp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the value of exponential function value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dq</td><td>a dual quaternion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d16beba80dafe4489a150c7f9be0118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d16beba80dafe4489a150c7f9be0118">&#9670;&nbsp;</a></span>inv</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; inv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if \(\sigma = p + \epsilon q\) is a dual quaternion, p is not zero, the inverse dual quaternion is </p><p class="formulaDsp">
\[\sigma^{-1} = \frac{\sigma^*}{||\sigma||^2}, \]
</p>
<p> or equivalentlly, </p><p class="formulaDsp">
\[\sigma^{-1} = p^{-1} - \epsilon p^{-1}qp^{-1}.\]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dq</td><td>a dual quaternion. </td></tr>
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, dual quaternion dq assume to be a unit dual quaternion and this function will save some computations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fc83f28ffe66945a74e73a11a087c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc83f28ffe66945a74e73a11a087c69">&#9670;&nbsp;</a></span>log</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; log </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the value of logarithm function value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dq</td><td>a dual quaternion. </td></tr>
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, dual quaternion dq assume to be a unit dual quaternion and this function will save some computations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a458cd35347fe1729f9180644c83dc192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458cd35347fe1729f9180644c83dc192">&#9670;&nbsp;</a></span>power <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; power </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the value of \(p^t\) where p is a dual quaternion. This could be calculated as: </p><p class="formulaDsp">
\[ p^t = \exp(t\ln p) \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dq</td><td>a dual quaternion. </td></tr>
    <tr><td class="paramname">t</td><td>index of power function. </td></tr>
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, dual quaternion dq assume to be a unit dual quaternion and this function will save some computations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fcc7470f4f339ee60dbfa6bf1634731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcc7470f4f339ee60dbfa6bf1634731">&#9670;&nbsp;</a></span>power <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt;T&gt; power </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">DualQuat</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/de1/group__core.html#ga935c8234953e2a2c8557c019ad8d509e">QuatAssumeType</a>&#160;</td>
          <td class="paramname"><em>assumeUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the value of \(p^q\) where p and q are dual quaternions. This could be calculated as: </p><p class="formulaDsp">
\[ p^q = \exp(q\ln p) \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a dual quaternion. </td></tr>
    <tr><td class="paramname">q</td><td>a dual quaternion. </td></tr>
    <tr><td class="paramname">assumeUnit</td><td>if <a class="el" href="../../d0/de1/group__core.html#gga935c8234953e2a2c8557c019ad8d509ea87af033c2248f7a0b4548ffa56afc697">QUAT_ASSUME_UNIT</a>, dual quaternion p assume to be a dual unit quaternion and this function will save some computations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac74101d333e3652e09de0f2340f9786d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74101d333e3652e09de0f2340f9786d">&#9670;&nbsp;</a></span>CV_DUAL_QUAT_EPS</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr _Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::CV_DUAL_QUAT_EPS = (_Tp)1.e-6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea1571d04e7a8413d694c86ccb65a4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1571d04e7a8413d694c86ccb65a4ca">&#9670;&nbsp;</a></span>w</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::w</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26df9a4cba469c1308b777b2a80d380c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26df9a4cba469c1308b777b2a80d380c">&#9670;&nbsp;</a></span>w_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::w_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85106b84b92f42e36c550865935377a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85106b84b92f42e36c550865935377a0">&#9670;&nbsp;</a></span>x</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::x</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d5a3b9f89b32fc12ebd6f75f2392221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5a3b9f89b32fc12ebd6f75f2392221">&#9670;&nbsp;</a></span>x_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::x_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d5bdf3d341452e406d2ab9878e435a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5bdf3d341452e406d2ab9878e435a9">&#9670;&nbsp;</a></span>y</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::y</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0112c38fdb2e93d6bade42a1234447d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0112c38fdb2e93d6bade42a1234447d5">&#9670;&nbsp;</a></span>y_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::y_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad26885c85d72c4b9bc42d229b76e3790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26885c85d72c4b9bc42d229b76e3790">&#9670;&nbsp;</a></span>z</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::z</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38eccd00b69906fa7c72a7a81b8f5c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38eccd00b69906fa7c72a7a81b8f5c0e">&#9670;&nbsp;</a></span>z_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp <a class="el" href="../../d4/db4/classcv_1_1DualQuat.html">cv::DualQuat</a>&lt; _Tp &gt;::z_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>opencv2/core/<a class="el" href="../../d2/dfa/dualquaternion_8hpp.html">dualquaternion.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 5 2022 16:20:00 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
