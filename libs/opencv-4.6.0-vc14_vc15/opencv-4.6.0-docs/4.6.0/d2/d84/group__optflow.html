<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.13" name="generator"/>
<title>OpenCV: Optical Flow Algorithms</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script src="../../jquery.js" type="text/javascript"></script>
<script src="../../dynsections.js" type="text/javascript"></script>
<script src="../../tutorial-utils.js" type="text/javascript"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script src="../../search/searchdata.js" type="text/javascript"></script>
<script src="../../search/search.js" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
          distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
          distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js" type="text/javascript"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellpadding="0" cellspacing="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
    <span id="projectnumber">4.6.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script src="../../menudata.js" type="text/javascript"></script>
<script src="../../menu.js" type="text/javascript"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Optical Flow Algorithms</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d59/classcv_1_1optflow_1_1DenseRLOFOpticalFlow.html">cv::optflow::DenseRLOFOpticalFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Fast dense optical flow computation based on robust local optical flow (RLOF) algorithms and sparse-to-dense interpolation scheme.  <a href="../../df/d59/classcv_1_1optflow_1_1DenseRLOFOpticalFlow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d4d/classcv_1_1optflow_1_1DualTVL1OpticalFlow.html">cv::optflow::DualTVL1OpticalFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">"Dual TV L1" Optical Flow <a class="el" href="../../d3/d46/classcv_1_1Algorithm.html" title="This is a base class for all more or less complex algorithms in OpenCV. ">Algorithm</a>.  <a href="../../dc/d4d/classcv_1_1optflow_1_1DualTVL1OpticalFlow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dba/classcv_1_1optflow_1_1GPCDetails.html">cv::optflow::GPCDetails</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dfe/classcv_1_1optflow_1_1GPCForest.html">cv::optflow::GPCForest&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html">cv::optflow::GPCMatchingParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class encapsulating matching parameters.  <a href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dfd/structcv_1_1optflow_1_1GPCPatchDescriptor.html">cv::optflow::GPCPatchDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d6a/structcv_1_1optflow_1_1GPCPatchSample.html">cv::optflow::GPCPatchSample</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dcc/structcv_1_1optflow_1_1GPCTrainingParams.html">cv::optflow::GPCTrainingParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class encapsulating training parameters.  <a href="../../d1/dcc/structcv_1_1optflow_1_1GPCTrainingParams.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d49/classcv_1_1optflow_1_1GPCTrainingSamples.html">cv::optflow::GPCTrainingSamples</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class encapsulating training samples.  <a href="../../d5/d49/classcv_1_1optflow_1_1GPCTrainingSamples.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d4d/classcv_1_1optflow_1_1GPCTree.html">cv::optflow::GPCTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class for individual tree.  <a href="../../d4/d4d/classcv_1_1optflow_1_1GPCTree.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/da2/classcv_1_1optflow_1_1OpticalFlowPCAFlow.html">cv::optflow::OpticalFlowPCAFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">PCAFlow algorithm.  <a href="../../d1/da2/classcv_1_1optflow_1_1OpticalFlowPCAFlow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d5e/classcv_1_1optflow_1_1PCAPrior.html">cv::optflow::PCAPrior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">This class can be used for imposing a learned prior on the resulting optical flow. Solution will be regularized according to this prior. You need to generate appropriate prior file with "learn_prior.py" script beforehand.  <a href="../../d5/d5e/classcv_1_1optflow_1_1PCAPrior.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html">cv::optflow::RLOFOpticalFlowParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">This is used store and set up the parameters of the robust local optical flow (RLOF) algoritm.  <a href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dc4/classcv_1_1optflow_1_1SparseRLOFOpticalFlow.html">cv::optflow::SparseRLOFOpticalFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Class used for calculation sparse optical flow and feature tracking with robust local optical flow (RLOF) algorithms.  <a href="../../df/dc4/classcv_1_1optflow_1_1SparseRLOFOpticalFlow.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaae8114ca8607c4a6f7735b313fe9a342"><td align="right" class="memItemLeft" valign="top">typedef std::vector&lt; <a class="el" href="../../d4/d6a/structcv_1_1optflow_1_1GPCPatchSample.html">GPCPatchSample</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gaae8114ca8607c4a6f7735b313fe9a342">cv::optflow::GPCSamplesVector</a></td></tr>
<tr class="separator:gaae8114ca8607c4a6f7735b313fe9a342"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa42b40f18dde15651b35c2666ac6824d"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gaa42b40f18dde15651b35c2666ac6824d">cv::optflow::GPCDescType</a> { <br/>
  <a class="el" href="../../d2/d84/group__optflow.html#ggaa42b40f18dde15651b35c2666ac6824da2ca1454e5a45e1faac62237cad32b479">cv::optflow::GPC_DESCRIPTOR_DCT</a> = 0, 
<br/>
  <a class="el" href="../../d2/d84/group__optflow.html#ggaa42b40f18dde15651b35c2666ac6824da363ac25bbb8fad970bf2efbdcccab11b">cv::optflow::GPC_DESCRIPTOR_WHT</a>
<br/>
 }<tr class="memdesc:gaa42b40f18dde15651b35c2666ac6824d"><td class="mdescLeft"> </td><td class="mdescRight">Descriptor types for the Global Patch Collider.  <a href="../../d2/d84/group__optflow.html#gaa42b40f18dde15651b35c2666ac6824d">More...</a><br/></td></tr>
</td></tr>
<tr class="separator:gaa42b40f18dde15651b35c2666ac6824d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac80d2a88890a3d8a1e655c91a24f3225"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gac80d2a88890a3d8a1e655c91a24f3225">cv::optflow::InterpolationType</a> { <br/>
  <a class="el" href="../../d2/d84/group__optflow.html#ggac80d2a88890a3d8a1e655c91a24f3225adbe6372a8510a26dae909fd9e5acfacb">cv::optflow::INTERP_GEO</a> = 0, 
<br/>
  <a class="el" href="../../d2/d84/group__optflow.html#ggac80d2a88890a3d8a1e655c91a24f3225a286254d8895e599c70603e226f2d3026">cv::optflow::INTERP_EPIC</a> = 1, 
<br/>
  <a class="el" href="../../d2/d84/group__optflow.html#ggac80d2a88890a3d8a1e655c91a24f3225a7c079638b5150b20bdf5fb2a0acf5f15">cv::optflow::INTERP_RIC</a> = 2
<br/>
 }</td></tr>
<tr class="separator:gac80d2a88890a3d8a1e655c91a24f3225"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaac4a33e26da30a5c5aa1ed3f66fc0998"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gaac4a33e26da30a5c5aa1ed3f66fc0998">cv::optflow::SolverType</a> { <br/>
  <a class="el" href="../../d2/d84/group__optflow.html#ggaac4a33e26da30a5c5aa1ed3f66fc0998aa4c47a58f231a484eff77183148908a2">cv::optflow::ST_STANDART</a> = 0, 
<br/>
  <a class="el" href="../../d2/d84/group__optflow.html#ggaac4a33e26da30a5c5aa1ed3f66fc0998a412f292ae2101f5fd3de778cc597c13c">cv::optflow::ST_BILINEAR</a> = 1
<br/>
 }</td></tr>
<tr class="separator:gaac4a33e26da30a5c5aa1ed3f66fc0998"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabd57af723cddf921d0c0601a6e8e789b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gabd57af723cddf921d0c0601a6e8e789b">cv::optflow::SupportRegionType</a> { <br/>
  <a class="el" href="../../d2/d84/group__optflow.html#ggabd57af723cddf921d0c0601a6e8e789ba039f4856c9cd55fdd1a50c20885f046b">cv::optflow::SR_FIXED</a> = 0, 
<br/>
  <a class="el" href="../../d2/d84/group__optflow.html#ggabd57af723cddf921d0c0601a6e8e789ba9d59164b49e3adbe1031a21d65053edb">cv::optflow::SR_CROSS</a> = 1
<br/>
 }</td></tr>
<tr class="separator:gabd57af723cddf921d0c0601a6e8e789b"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9b841df1ad43ae7ea06fb3cdd6408db7"><td align="right" class="memItemLeft" valign="top">double </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga9b841df1ad43ae7ea06fb3cdd6408db7">cv::motempl::calcGlobalOrientation</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> orientation, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> mask, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> mhi, double timestamp, double duration)</td></tr>
<tr class="memdesc:ga9b841df1ad43ae7ea06fb3cdd6408db7"><td class="mdescLeft"> </td><td class="mdescRight">Calculates a global motion orientation in a selected region.  <a href="../../d2/d84/group__optflow.html#ga9b841df1ad43ae7ea06fb3cdd6408db7">More...</a><br/></td></tr>
<tr class="separator:ga9b841df1ad43ae7ea06fb3cdd6408db7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf81cb3d2e60299558df0e4d6c0e059a7"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gaf81cb3d2e60299558df0e4d6c0e059a7">cv::motempl::calcMotionGradient</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> mhi, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> mask, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> orientation, double delta1, double delta2, int apertureSize=3)</td></tr>
<tr class="memdesc:gaf81cb3d2e60299558df0e4d6c0e059a7"><td class="mdescLeft"> </td><td class="mdescRight">Calculates a gradient orientation of a motion history image.  <a href="../../d2/d84/group__optflow.html#gaf81cb3d2e60299558df0e4d6c0e059a7">More...</a><br/></td></tr>
<tr class="separator:gaf81cb3d2e60299558df0e4d6c0e059a7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga0fc536362c239654322d9015f6efcecd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga0fc536362c239654322d9015f6efcecd">cv::optflow::calcOpticalFlowDenseRLOF</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> I0, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> I1, <a class="el" href="../../dc/d84/group__core__basic.html#gaf77c9a14ef956c50c1efd4547f444e63">InputOutputArray</a> flow, <a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html">RLOFOpticalFlowParameter</a> &gt; rlofParam=<a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html">RLOFOpticalFlowParameter</a> &gt;(), float forwardBackwardThreshold=0, <a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a> gridStep=<a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a>(6, 6), <a class="el" href="../../d2/d84/group__optflow.html#gac80d2a88890a3d8a1e655c91a24f3225">InterpolationType</a> interp_type=InterpolationType::INTERP_EPIC, int epicK=128, float epicSigma=0.05f, float epicLambda=100.f, int ricSPSize=15, int ricSLICType=100, bool use_post_proc=true, float fgsLambda=500.0f, float fgsSigma=1.5f, bool use_variational_refinement=false)</td></tr>
<tr class="memdesc:ga0fc536362c239654322d9015f6efcecd"><td class="mdescLeft"> </td><td class="mdescRight">Fast dense optical flow computation based on robust local optical flow (RLOF) algorithms and sparse-to-dense interpolation scheme.  <a href="../../d2/d84/group__optflow.html#ga0fc536362c239654322d9015f6efcecd">More...</a><br/></td></tr>
<tr class="separator:ga0fc536362c239654322d9015f6efcecd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga370e4f91055a5ae14a0db71850b2f788"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga370e4f91055a5ae14a0db71850b2f788">cv::optflow::calcOpticalFlowSF</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> from, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> to, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> flow, int layers, int averaging_block_size, int max_flow)</td></tr>
<tr class="separator:ga370e4f91055a5ae14a0db71850b2f788"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf23c367519903ed2384e9532e43c7032"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gaf23c367519903ed2384e9532e43c7032">cv::optflow::calcOpticalFlowSF</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> from, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> to, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> flow, int layers, int averaging_block_size, int max_flow, double sigma_dist, double sigma_color, int postprocess_window, double sigma_dist_fix, double sigma_color_fix, double occ_thr, int upscale_averaging_radius, double upscale_sigma_dist, double upscale_sigma_color, double speed_up_thr)</td></tr>
<tr class="memdesc:gaf23c367519903ed2384e9532e43c7032"><td class="mdescLeft"> </td><td class="mdescRight">Calculate an optical flow using "SimpleFlow" algorithm.  <a href="../../d2/d84/group__optflow.html#gaf23c367519903ed2384e9532e43c7032">More...</a><br/></td></tr>
<tr class="separator:gaf23c367519903ed2384e9532e43c7032"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga32ba4b0f6a21684d99d45f6bc470f480"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga32ba4b0f6a21684d99d45f6bc470f480">cv::optflow::calcOpticalFlowSparseRLOF</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> prevImg, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> nextImg, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> prevPts, <a class="el" href="../../dc/d84/group__core__basic.html#gaf77c9a14ef956c50c1efd4547f444e63">InputOutputArray</a> nextPts, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> status, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> err, <a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html">RLOFOpticalFlowParameter</a> &gt; rlofParam=<a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html">RLOFOpticalFlowParameter</a> &gt;(), float forwardBackwardThreshold=0)</td></tr>
<tr class="memdesc:ga32ba4b0f6a21684d99d45f6bc470f480"><td class="mdescLeft"> </td><td class="mdescRight">Calculates fast optical flow for a sparse feature set using the robust local optical flow (RLOF) similar to <a class="el" href="../../dc/d6b/group__video__track.html#ga473e4b886d0bcc6b65831eb88ed93323" title="Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyra...">optflow::calcOpticalFlowPyrLK()</a>.  <a href="../../d2/d84/group__optflow.html#ga32ba4b0f6a21684d99d45f6bc470f480">More...</a><br/></td></tr>
<tr class="separator:ga32ba4b0f6a21684d99d45f6bc470f480"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad6aa63f2703202806fe18dc1353b5f4b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gad6aa63f2703202806fe18dc1353b5f4b">cv::optflow::calcOpticalFlowSparseToDense</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> from, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> to, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> flow, int grid_step=8, int k=128, float sigma=0.05f, bool use_post_proc=true, float fgs_lambda=500.0f, float fgs_sigma=1.5f)</td></tr>
<tr class="memdesc:gad6aa63f2703202806fe18dc1353b5f4b"><td class="mdescLeft"> </td><td class="mdescRight">Fast dense optical flow based on PyrLK sparse matches interpolation.  <a href="../../d2/d84/group__optflow.html#gad6aa63f2703202806fe18dc1353b5f4b">More...</a><br/></td></tr>
<tr class="separator:gad6aa63f2703202806fe18dc1353b5f4b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5e735547610172695cb0b39495af9d6d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga5e735547610172695cb0b39495af9d6d">cv::optflow::createOptFlow_DeepFlow</a> ()</td></tr>
<tr class="memdesc:ga5e735547610172695cb0b39495af9d6d"><td class="mdescLeft"> </td><td class="mdescRight">DeepFlow optical flow algorithm implementation.  <a href="../../d2/d84/group__optflow.html#ga5e735547610172695cb0b39495af9d6d">More...</a><br/></td></tr>
<tr class="separator:ga5e735547610172695cb0b39495af9d6d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6c01ebcd843767fd4bd754f4238dc72c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga6c01ebcd843767fd4bd754f4238dc72c">cv::optflow::createOptFlow_DenseRLOF</a> ()</td></tr>
<tr class="memdesc:ga6c01ebcd843767fd4bd754f4238dc72c"><td class="mdescLeft"> </td><td class="mdescRight">Additional interface to the Dense RLOF algorithm - <a class="el" href="../../d2/d84/group__optflow.html#ga0fc536362c239654322d9015f6efcecd" title="Fast dense optical flow computation based on robust local optical flow (RLOF) algorithms and sparse-t...">optflow::calcOpticalFlowDenseRLOF()</a>  <a href="../../d2/d84/group__optflow.html#ga6c01ebcd843767fd4bd754f4238dc72c">More...</a><br/></td></tr>
<tr class="separator:ga6c01ebcd843767fd4bd754f4238dc72c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga132098d4d6e74b96c715bb9c451a1d8f"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../dc/d4d/classcv_1_1optflow_1_1DualTVL1OpticalFlow.html">DualTVL1OpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga132098d4d6e74b96c715bb9c451a1d8f">cv::optflow::createOptFlow_DualTVL1</a> ()</td></tr>
<tr class="memdesc:ga132098d4d6e74b96c715bb9c451a1d8f"><td class="mdescLeft"> </td><td class="mdescRight">Creates instance of <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">cv::DenseOpticalFlow</a>.  <a href="../../d2/d84/group__optflow.html#ga132098d4d6e74b96c715bb9c451a1d8f">More...</a><br/></td></tr>
<tr class="separator:ga132098d4d6e74b96c715bb9c451a1d8f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadd1519b8b360c101de0a2d3d3ca5f0e1"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gadd1519b8b360c101de0a2d3d3ca5f0e1">cv::optflow::createOptFlow_Farneback</a> ()</td></tr>
<tr class="memdesc:gadd1519b8b360c101de0a2d3d3ca5f0e1"><td class="mdescLeft"> </td><td class="mdescRight">Additional interface to the Farneback's algorithm - <a class="el" href="../../dc/d6b/group__video__track.html#ga5d10ebbd59fe09c5f650289ec0ece5af" title="Computes a dense optical flow using the Gunnar Farneback's algorithm. ">calcOpticalFlowFarneback()</a>  <a href="../../d2/d84/group__optflow.html#gadd1519b8b360c101de0a2d3d3ca5f0e1">More...</a><br/></td></tr>
<tr class="separator:gadd1519b8b360c101de0a2d3d3ca5f0e1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabbf0942f6ab840dcb1c10273b02507f0"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gabbf0942f6ab840dcb1c10273b02507f0">cv::optflow::createOptFlow_PCAFlow</a> ()</td></tr>
<tr class="memdesc:gabbf0942f6ab840dcb1c10273b02507f0"><td class="mdescLeft"> </td><td class="mdescRight">Creates an instance of PCAFlow.  <a href="../../d2/d84/group__optflow.html#gabbf0942f6ab840dcb1c10273b02507f0">More...</a><br/></td></tr>
<tr class="separator:gabbf0942f6ab840dcb1c10273b02507f0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab3fd0cd6d32cb7cfa169cb72e804d0b4"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gab3fd0cd6d32cb7cfa169cb72e804d0b4">cv::optflow::createOptFlow_SimpleFlow</a> ()</td></tr>
<tr class="memdesc:gab3fd0cd6d32cb7cfa169cb72e804d0b4"><td class="mdescLeft"> </td><td class="mdescRight">Additional interface to the SimpleFlow algorithm - <a class="el" href="../../d2/d84/group__optflow.html#ga370e4f91055a5ae14a0db71850b2f788">calcOpticalFlowSF()</a>  <a href="../../d2/d84/group__optflow.html#gab3fd0cd6d32cb7cfa169cb72e804d0b4">More...</a><br/></td></tr>
<tr class="separator:gab3fd0cd6d32cb7cfa169cb72e804d0b4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadcd2f4b1ecb8ea366bdc23f8f23da7ac"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../de/d14/classcv_1_1SparseOpticalFlow.html">SparseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gadcd2f4b1ecb8ea366bdc23f8f23da7ac">cv::optflow::createOptFlow_SparseRLOF</a> ()</td></tr>
<tr class="memdesc:gadcd2f4b1ecb8ea366bdc23f8f23da7ac"><td class="mdescLeft"> </td><td class="mdescRight">Additional interface to the Sparse RLOF algorithm - <a class="el" href="../../d2/d84/group__optflow.html#ga32ba4b0f6a21684d99d45f6bc470f480" title="Calculates fast optical flow for a sparse feature set using the robust local optical flow (RLOF) simi...">optflow::calcOpticalFlowSparseRLOF()</a>  <a href="../../d2/d84/group__optflow.html#gadcd2f4b1ecb8ea366bdc23f8f23da7ac">More...</a><br/></td></tr>
<tr class="separator:gadcd2f4b1ecb8ea366bdc23f8f23da7ac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae7bcbdec27f2006dde666c5f6c6e232d"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#gae7bcbdec27f2006dde666c5f6c6e232d">cv::optflow::createOptFlow_SparseToDense</a> ()</td></tr>
<tr class="memdesc:gae7bcbdec27f2006dde666c5f6c6e232d"><td class="mdescLeft"> </td><td class="mdescRight">Additional interface to the SparseToDenseFlow algorithm - <a class="el" href="../../d2/d84/group__optflow.html#gad6aa63f2703202806fe18dc1353b5f4b" title="Fast dense optical flow based on PyrLK sparse matches interpolation. ">calcOpticalFlowSparseToDense()</a>  <a href="../../d2/d84/group__optflow.html#gae7bcbdec27f2006dde666c5f6c6e232d">More...</a><br/></td></tr>
<tr class="separator:gae7bcbdec27f2006dde666c5f6c6e232d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga91c50d0cd4b35a72f3850f87fddec2cb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga91c50d0cd4b35a72f3850f87fddec2cb">cv::optflow::GPCForest&lt; T &gt;::findCorrespondences</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> imgFrom, <a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> imgTo, std::vector&lt; std::pair&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga0f70b52f0c0b119f7ed2448ffebdc144">Point2i</a>, <a class="el" href="../../dc/d84/group__core__basic.html#ga0f70b52f0c0b119f7ed2448ffebdc144">Point2i</a> &gt; &gt; &amp;corr, const <a class="el" href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html">GPCMatchingParams</a> params=<a class="el" href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html">GPCMatchingParams</a>()) const</td></tr>
<tr class="memdesc:ga91c50d0cd4b35a72f3850f87fddec2cb"><td class="mdescLeft"> </td><td class="mdescRight">Find correspondences between two images.  <a href="#ga91c50d0cd4b35a72f3850f87fddec2cb">More...</a><br/></td></tr>
<tr class="separator:ga91c50d0cd4b35a72f3850f87fddec2cb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9eea50c233a0a6d7fecdd2c66821eed5"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga9eea50c233a0a6d7fecdd2c66821eed5">cv::motempl::segmentMotion</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> mhi, <a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> segmask, std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga11d95de507098e90bad732b9345402e8">Rect</a> &gt; &amp;boundingRects, double timestamp, double segThresh)</td></tr>
<tr class="memdesc:ga9eea50c233a0a6d7fecdd2c66821eed5"><td class="mdescLeft"> </td><td class="mdescRight">Splits a motion history image into a few parts corresponding to separate independent motions (for example, left hand, right hand).  <a href="../../d2/d84/group__optflow.html#ga9eea50c233a0a6d7fecdd2c66821eed5">More...</a><br/></td></tr>
<tr class="separator:ga9eea50c233a0a6d7fecdd2c66821eed5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9c60ca58707e508be624e21da1273026"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d84/group__optflow.html#ga9c60ca58707e508be624e21da1273026">cv::motempl::updateMotionHistory</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> silhouette, <a class="el" href="../../dc/d84/group__core__basic.html#gaf77c9a14ef956c50c1efd4547f444e63">InputOutputArray</a> mhi, double timestamp, double duration)</td></tr>
<tr class="memdesc:ga9c60ca58707e508be624e21da1273026"><td class="mdescLeft"> </td><td class="mdescRight">Updates the motion history image by a moving silhouette.  <a href="../../d2/d84/group__optflow.html#ga9c60ca58707e508be624e21da1273026">More...</a><br/></td></tr>
<tr class="separator:ga9c60ca58707e508be624e21da1273026"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Dense optical flow algorithms compute motion for each point:</p>
<ul>
<li><a class="el" href="../../d2/d84/group__optflow.html#ga370e4f91055a5ae14a0db71850b2f788">cv::optflow::calcOpticalFlowSF</a></li>
<li><a class="el" href="../../d2/d84/group__optflow.html#ga5e735547610172695cb0b39495af9d6d" title="DeepFlow optical flow algorithm implementation. ">cv::optflow::createOptFlow_DeepFlow</a></li>
</ul>
<p>Motion templates is alternative technique for detecting motion and computing its direction. See samples/motempl.py.</p>
<ul>
<li><a class="el" href="../../d2/d84/group__optflow.html#ga9c60ca58707e508be624e21da1273026" title="Updates the motion history image by a moving silhouette. ">cv::motempl::updateMotionHistory</a></li>
<li><a class="el" href="../../d2/d84/group__optflow.html#gaf81cb3d2e60299558df0e4d6c0e059a7" title="Calculates a gradient orientation of a motion history image. ">cv::motempl::calcMotionGradient</a></li>
<li><a class="el" href="../../d2/d84/group__optflow.html#ga9b841df1ad43ae7ea06fb3cdd6408db7" title="Calculates a global motion orientation in a selected region. ">cv::motempl::calcGlobalOrientation</a></li>
<li><a class="el" href="../../d2/d84/group__optflow.html#ga9eea50c233a0a6d7fecdd2c66821eed5" title="Splits a motion history image into a few parts corresponding to separate independent motions (for exa...">cv::motempl::segmentMotion</a></li>
</ul>
<p>Functions reading and writing .flo files in "Middlebury" format, see: <a href="http://vision.middlebury.edu/flow/code/flow-code/README.txt">http://vision.middlebury.edu/flow/code/flow-code/README.txt</a></p>
<ul>
<li>cv::optflow::readOpticalFlow</li>
<li>cv::optflow::writeOpticalFlow </li>
</ul>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaae8114ca8607c4a6f7735b313fe9a342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae8114ca8607c4a6f7735b313fe9a342">◆ </a></span>GPCSamplesVector</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="../../d4/d6a/structcv_1_1optflow_1_1GPCPatchSample.html">GPCPatchSample</a> &gt; <a class="el" href="../../d2/d84/group__optflow.html#gaae8114ca8607c4a6f7735b313fe9a342">cv::optflow::GPCSamplesVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dc5/sparse__matching__gpc_8hpp.html">opencv2/optflow/sparse_matching_gpc.hpp</a>&gt;</code></p>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa42b40f18dde15651b35c2666ac6824d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa42b40f18dde15651b35c2666ac6824d">◆ </a></span>GPCDescType</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d2/d84/group__optflow.html#gaa42b40f18dde15651b35c2666ac6824d">cv::optflow::GPCDescType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dc5/sparse__matching__gpc_8hpp.html">opencv2/optflow/sparse_matching_gpc.hpp</a>&gt;</code></p>
<p>Descriptor types for the Global Patch Collider. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa42b40f18dde15651b35c2666ac6824da2ca1454e5a45e1faac62237cad32b479"></a>GPC_DESCRIPTOR_DCT <div class="python_language">Python: cv.optflow.GPC_DESCRIPTOR_DCT</div></td><td class="fielddoc"><p>Better quality but slow. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa42b40f18dde15651b35c2666ac6824da363ac25bbb8fad970bf2efbdcccab11b"></a>GPC_DESCRIPTOR_WHT <div class="python_language">Python: cv.optflow.GPC_DESCRIPTOR_WHT</div></td><td class="fielddoc"><p>Worse quality but much faster. </p>
</td></tr>
</table>
</div>
</div>
<a id="gac80d2a88890a3d8a1e655c91a24f3225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac80d2a88890a3d8a1e655c91a24f3225">◆ </a></span>InterpolationType</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d2/d84/group__optflow.html#gac80d2a88890a3d8a1e655c91a24f3225">cv::optflow::InterpolationType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../da/da2/rlofflow_8hpp.html">opencv2/optflow/rlofflow.hpp</a>&gt;</code></p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac80d2a88890a3d8a1e655c91a24f3225adbe6372a8510a26dae909fd9e5acfacb"></a>INTERP_GEO <div class="python_language">Python: cv.optflow.INTERP_GEO</div></td><td class="fielddoc"><p>Fast geodesic interpolation, see <a class="el" href="../../d0/de3/citelist.html#CITEREF_Geistert2016">[91]</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac80d2a88890a3d8a1e655c91a24f3225a286254d8895e599c70603e226f2d3026"></a>INTERP_EPIC <div class="python_language">Python: cv.optflow.INTERP_EPIC</div></td><td class="fielddoc"><p>Edge-preserving interpolation using <a class="el" href="../../d4/dfa/classcv_1_1ximgproc_1_1EdgeAwareInterpolator.html" title="Sparse match interpolation algorithm based on modified locally-weighted affine estimator from  and Fa...">ximgproc::EdgeAwareInterpolator</a>, see <a class="el" href="../../d0/de3/citelist.html#CITEREF_Revaud2015">[206]</a>,Geistert2016. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac80d2a88890a3d8a1e655c91a24f3225a7c079638b5150b20bdf5fb2a0acf5f15"></a>INTERP_RIC <div class="python_language">Python: cv.optflow.INTERP_RIC</div></td><td class="fielddoc"><p>SLIC based robust interpolation using <a class="el" href="../../d2/da4/classcv_1_1ximgproc_1_1RICInterpolator.html" title="Sparse match interpolation algorithm based on modified piecewise locally-weighted affine estimator ca...">ximgproc::RICInterpolator</a>, see <a class="el" href="../../d0/de3/citelist.html#CITEREF_Hu2017">[117]</a>. </p>
</td></tr>
</table>
</div>
</div>
<a id="gaac4a33e26da30a5c5aa1ed3f66fc0998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac4a33e26da30a5c5aa1ed3f66fc0998">◆ </a></span>SolverType</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d2/d84/group__optflow.html#gaac4a33e26da30a5c5aa1ed3f66fc0998">cv::optflow::SolverType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../da/da2/rlofflow_8hpp.html">opencv2/optflow/rlofflow.hpp</a>&gt;</code></p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaac4a33e26da30a5c5aa1ed3f66fc0998aa4c47a58f231a484eff77183148908a2"></a>ST_STANDART <div class="python_language">Python: cv.optflow.ST_STANDART</div></td><td class="fielddoc"><p>Apply standard iterative refinement </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaac4a33e26da30a5c5aa1ed3f66fc0998a412f292ae2101f5fd3de778cc597c13c"></a>ST_BILINEAR <div class="python_language">Python: cv.optflow.ST_BILINEAR</div></td><td class="fielddoc"><p>Apply optimized iterative refinement based bilinear equation solutions as described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2013">[220]</a> </p>
</td></tr>
</table>
</div>
</div>
<a id="gabd57af723cddf921d0c0601a6e8e789b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd57af723cddf921d0c0601a6e8e789b">◆ </a></span>SupportRegionType</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d2/d84/group__optflow.html#gabd57af723cddf921d0c0601a6e8e789b">cv::optflow::SupportRegionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../da/da2/rlofflow_8hpp.html">opencv2/optflow/rlofflow.hpp</a>&gt;</code></p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabd57af723cddf921d0c0601a6e8e789ba039f4856c9cd55fdd1a50c20885f046b"></a>SR_FIXED <div class="python_language">Python: cv.optflow.SR_FIXED</div></td><td class="fielddoc"><p>Apply a constant support region </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabd57af723cddf921d0c0601a6e8e789ba9d59164b49e3adbe1031a21d65053edb"></a>SR_CROSS <div class="python_language">Python: cv.optflow.SR_CROSS</div></td><td class="fielddoc"><p>Apply a adaptive support region obtained by cross-based segmentation as described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2014">[221]</a> </p>
</td></tr>
</table>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9b841df1ad43ae7ea06fb3cdd6408db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b841df1ad43ae7ea06fb3cdd6408db7">◆ </a></span>calcGlobalOrientation()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cv::motempl::calcGlobalOrientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>duration</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.motempl.calcGlobalOrientation(</td><td class="paramname">orientation, mask, mhi, timestamp, duration</td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../da/d48/motempl_8hpp.html">opencv2/optflow/motempl.hpp</a>&gt;</code></p>
<p>Calculates a global motion orientation in a selected region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>Motion gradient orientation image calculated by the function calcMotionGradient </td></tr>
    <tr><td class="paramname">mask</td><td>Mask image. It may be a conjunction of a valid gradient mask, also calculated by calcMotionGradient , and the mask of a region whose direction needs to be calculated. </td></tr>
    <tr><td class="paramname">mhi</td><td>Motion history image calculated by updateMotionHistory . </td></tr>
    <tr><td class="paramname">timestamp</td><td>Timestamp passed to updateMotionHistory . </td></tr>
    <tr><td class="paramname">duration</td><td>Maximum duration of a motion track in milliseconds, passed to updateMotionHistory</td></tr>
  </table>
  </dd>
</dl>
<p>The function calculates an average motion direction in the selected region and returns the angle between 0 degrees and 360 degrees. The average direction is computed from the weighted orientation histogram, where a recent motion has a larger weight and the motion occurred in the past has a smaller weight, as recorded in mhi . </p>
</div>
</div>
<a id="gaf81cb3d2e60299558df0e4d6c0e059a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf81cb3d2e60299558df0e4d6c0e059a7">◆ </a></span>calcMotionGradient()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::motempl::calcMotionGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>delta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>delta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>apertureSize</em> = <code>3</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.motempl.calcMotionGradient(</td><td class="paramname">mhi, delta1, delta2[, mask[, orientation[, apertureSize]]]</td><td>) -&gt; </td><td>mask, orientation</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../da/d48/motempl_8hpp.html">opencv2/optflow/motempl.hpp</a>&gt;</code></p>
<p>Calculates a gradient orientation of a motion history image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mhi</td><td>Motion history single-channel floating-point image. </td></tr>
    <tr><td class="paramname">mask</td><td>Output mask image that has the type CV_8UC1 and the same size as mhi . Its non-zero elements mark pixels where the motion gradient data is correct. </td></tr>
    <tr><td class="paramname">orientation</td><td>Output motion gradient orientation image that has the same type and the same size as mhi . Each pixel of the image is a motion orientation, from 0 to 360 degrees. </td></tr>
    <tr><td class="paramname">delta1</td><td>Minimal (or maximal) allowed difference between mhi values within a pixel neighborhood. </td></tr>
    <tr><td class="paramname">delta2</td><td>Maximal (or minimal) allowed difference between mhi values within a pixel neighborhood. That is, the function finds the minimum ( \(m(x,y)\) ) and maximum ( \(M(x,y)\) ) mhi values over \(3 \times 3\) neighborhood of each pixel and marks the motion orientation at \((x, y)\) as valid only if <p class="formulaDsp">
\[\min ( \texttt{delta1} , \texttt{delta2} ) \le M(x,y)-m(x,y) \le \max ( \texttt{delta1} , \texttt{delta2} ).\]
</p>
 </td></tr>
    <tr><td class="paramname">apertureSize</td><td>Aperture size of the Sobel operator.</td></tr>
  </table>
  </dd>
</dl>
<p>The function calculates a gradient orientation at each pixel \((x, y)\) as:</p>
<p class="formulaDsp">
\[\texttt{orientation} (x,y)= \arctan{\frac{d\texttt{mhi}/dy}{d\texttt{mhi}/dx}}\]
</p>
<p>In fact, fastAtan2 and phase are used so that the computed angle is measured in degrees and covers the full range 0..360. Also, the mask is filled to indicate pixels where the computed angle is valid.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>(Python) An example on how to perform a motion template technique can be found at opencv_source_code/samples/python2/motempl.py </li>
</ul>
</dd></dl>
</div>
</div>
<a id="ga0fc536362c239654322d9015f6efcecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fc536362c239654322d9015f6efcecd">◆ </a></span>calcOpticalFlowDenseRLOF()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::optflow::calcOpticalFlowDenseRLOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>I0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>I1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaf77c9a14ef956c50c1efd4547f444e63">InputOutputArray</a> </td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html">RLOFOpticalFlowParameter</a> &gt; </td>
          <td class="paramname"><em>rlofParam</em> = <code><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html">RLOFOpticalFlowParameter</a> &gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>forwardBackwardThreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a> </td>
          <td class="paramname"><em>gridStep</em> = <code><a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a>(6, 6)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d84/group__optflow.html#gac80d2a88890a3d8a1e655c91a24f3225">InterpolationType</a> </td>
          <td class="paramname"><em>interp_type</em> = <code>InterpolationType::INTERP_EPIC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>epicK</em> = <code>128</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>epicSigma</em> = <code>0.05f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>epicLambda</em> = <code>100.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>ricSPSize</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>ricSLICType</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>use_post_proc</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>fgsLambda</em> = <code>500.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>fgsSigma</em> = <code>1.5f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>use_variational_refinement</em> = <code>false</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.calcOpticalFlowDenseRLOF(</td><td class="paramname">I0, I1, flow[, rlofParam[, forwardBackwardThreshold[, gridStep[, interp_type[, epicK[, epicSigma[, epicLambda[, ricSPSize[, ricSLICType[, use_post_proc[, fgsLambda[, fgsSigma[, use_variational_refinement]]]]]]]]]]]]]</td><td>) -&gt; </td><td>flow</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../da/da2/rlofflow_8hpp.html">opencv2/optflow/rlofflow.hpp</a>&gt;</code></p>
<p>Fast dense optical flow computation based on robust local optical flow (RLOF) algorithms and sparse-to-dense interpolation scheme. </p>
<p>The RLOF is a fast local optical flow approach described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2012">[219]</a> <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2013">[220]</a> <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2014">[221]</a> and <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2016">[222]</a> similar to the pyramidal iterative Lucas-Kanade method as proposed by <a class="el" href="../../d0/de3/citelist.html#CITEREF_Bouguet00">[32]</a>. More details and experiments can be found in the following thesis <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2019">[223]</a>. The implementation is derived from <a class="el" href="../../dc/d6b/group__video__track.html#ga473e4b886d0bcc6b65831eb88ed93323" title="Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyra...">optflow::calcOpticalFlowPyrLK()</a>.</p>
<p>The sparse-to-dense interpolation scheme allows for fast computation of dense optical flow using RLOF (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_Geistert2016">[91]</a>). For this scheme the following steps are applied:</p><ol type="1">
<li>motion vector seeded at a regular sampled grid are computed. The sparsity of this grid can be configured with setGridStep</li>
<li>(optinally) errornous motion vectors are filter based on the forward backward confidence. The threshold can be configured with setForwardBackward. The filter is only applied if the threshold &gt;0 but than the runtime is doubled due to the estimation of the backward flow.</li>
<li>Vector field interpolation is applied to the motion vector set to obtain a dense vector field.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">I0</td><td>first 8-bit input image. If The cross-based RLOF is used (by selecting <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html#a203bd482fc0efa091faf0e537768d5d1">optflow::RLOFOpticalFlowParameter::supportRegionType</a> = SupportRegionType::SR_CROSS) image has to be a 8-bit 3 channel image. </td></tr>
    <tr><td class="paramname">I1</td><td>second 8-bit input image. If The cross-based RLOF is used (by selecting <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html#a203bd482fc0efa091faf0e537768d5d1">optflow::RLOFOpticalFlowParameter::supportRegionType</a> = SupportRegionType::SR_CROSS) image has to be a 8-bit 3 channel image. </td></tr>
    <tr><td class="paramname">flow</td><td>computed flow image that has the same size as I0 and type CV_32FC2. </td></tr>
    <tr><td class="paramname">rlofParam</td><td>see <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html" title="This is used store and set up the parameters of the robust local optical flow (RLOF) algoritm...">optflow::RLOFOpticalFlowParameter</a> </td></tr>
    <tr><td class="paramname">forwardBackwardThreshold</td><td>Threshold for the forward backward confidence check. For each grid point \( \mathbf{x} \) a motion vector \( d_{I0,I1}(\mathbf{x}) \) is computed. If the forward backward error <p class="formulaDsp">
\[ EP_{FB} = || d_{I0,I1} + d_{I1,I0} || \]
</p>
 is larger than threshold given by this function then the motion vector will not be used by the following vector field interpolation. \( d_{I1,I0} \) denotes the backward flow. Note, the forward backward test will only be applied if the threshold &gt; 0. This may results into a doubled runtime for the motion estimation. </td></tr>
    <tr><td class="paramname">gridStep</td><td>Size of the grid to spawn the motion vectors. For each grid point a motion vector is computed. Some motion vectors will be removed due to the forwatd backward threshold (if set &gt;0). The rest will be the base of the vector field interpolation. </td></tr>
    <tr><td class="paramname">interp_type</td><td>interpolation method used to compute the dense optical flow. Two interpolation algorithms are supported:<ul>
<li><b>INTERP_GEO</b> applies the fast geodesic interpolation, see <a class="el" href="../../d0/de3/citelist.html#CITEREF_Geistert2016">[91]</a>.</li>
<li><b>INTERP_EPIC_RESIDUAL</b> applies the edge-preserving interpolation, see <a class="el" href="../../d0/de3/citelist.html#CITEREF_Revaud2015">[206]</a>,Geistert2016. </li>
</ul>
</td></tr>
    <tr><td class="paramname">epicK</td><td>see <a class="el" href="../../d4/dfa/classcv_1_1ximgproc_1_1EdgeAwareInterpolator.html" title="Sparse match interpolation algorithm based on modified locally-weighted affine estimator from  and Fa...">ximgproc::EdgeAwareInterpolator</a> sets the respective parameter. </td></tr>
    <tr><td class="paramname">epicSigma</td><td>see <a class="el" href="../../d4/dfa/classcv_1_1ximgproc_1_1EdgeAwareInterpolator.html" title="Sparse match interpolation algorithm based on modified locally-weighted affine estimator from  and Fa...">ximgproc::EdgeAwareInterpolator</a> sets the respective parameter. </td></tr>
    <tr><td class="paramname">epicLambda</td><td>see <a class="el" href="../../d4/dfa/classcv_1_1ximgproc_1_1EdgeAwareInterpolator.html" title="Sparse match interpolation algorithm based on modified locally-weighted affine estimator from  and Fa...">ximgproc::EdgeAwareInterpolator</a> sets the respective parameter. </td></tr>
    <tr><td class="paramname">ricSPSize</td><td>see <a class="el" href="../../d2/da4/classcv_1_1ximgproc_1_1RICInterpolator.html" title="Sparse match interpolation algorithm based on modified piecewise locally-weighted affine estimator ca...">ximgproc::RICInterpolator</a> sets the respective parameter. </td></tr>
    <tr><td class="paramname">ricSLICType</td><td>see <a class="el" href="../../d2/da4/classcv_1_1ximgproc_1_1RICInterpolator.html" title="Sparse match interpolation algorithm based on modified piecewise locally-weighted affine estimator ca...">ximgproc::RICInterpolator</a> sets the respective parameter. </td></tr>
    <tr><td class="paramname">use_post_proc</td><td>enables <a class="el" href="../../da/d17/group__ximgproc__filters.html#gaf8673fe9147160ad96ac6053fac3c106" title="Simple one-line Fast Global Smoother filter call. If you have multiple images to filter with the same...">ximgproc::fastGlobalSmootherFilter()</a> parameter. </td></tr>
    <tr><td class="paramname">fgsLambda</td><td>sets the respective <a class="el" href="../../da/d17/group__ximgproc__filters.html#gaf8673fe9147160ad96ac6053fac3c106" title="Simple one-line Fast Global Smoother filter call. If you have multiple images to filter with the same...">ximgproc::fastGlobalSmootherFilter()</a> parameter. </td></tr>
    <tr><td class="paramname">fgsSigma</td><td>sets the respective <a class="el" href="../../da/d17/group__ximgproc__filters.html#gaf8673fe9147160ad96ac6053fac3c106" title="Simple one-line Fast Global Smoother filter call. If you have multiple images to filter with the same...">ximgproc::fastGlobalSmootherFilter()</a> parameter. </td></tr>
    <tr><td class="paramname">use_variational_refinement</td><td>enables <a class="el" href="../../d2/d4b/classcv_1_1VariationalRefinement.html" title="Variational optical flow refinement. ">VariationalRefinement</a></td></tr>
  </table>
  </dd>
</dl>
<p>Parameters have been described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2012">[219]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2013">[220]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2014">[221]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2016">[222]</a>. For the RLOF configuration see <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html" title="This is used store and set up the parameters of the robust local optical flow (RLOF) algoritm...">optflow::RLOFOpticalFlowParameter</a> for further details. </p><dl class="section note"><dt>Note</dt><dd>If the grid size is set to (1,1) and the forward backward threshold &lt;= 0 that the dense optical flow field is purely computed with the RLOF.</dd>
<dd>
SIMD parallelization is only available when compiling with SSE4.1. </dd>
<dd>
Note that in output, if no correspondences are found between <em>I0</em> and <em>I1</em>, the <em>flow</em> is set to 0.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/d59/classcv_1_1optflow_1_1DenseRLOFOpticalFlow.html" title="Fast dense optical flow computation based on robust local optical flow (RLOF) algorithms and sparse-t...">optflow::DenseRLOFOpticalFlow</a>, <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html" title="This is used store and set up the parameters of the robust local optical flow (RLOF) algoritm...">optflow::RLOFOpticalFlowParameter</a> </dd></dl>
</div>
</div>
<a id="ga370e4f91055a5ae14a0db71850b2f788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370e4f91055a5ae14a0db71850b2f788">◆ </a></span>calcOpticalFlowSF() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::optflow::calcOpticalFlowSF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>averaging_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>max_flow</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.calcOpticalFlowSF(</td><td class="paramname">from_, to, layers, averaging_block_size, max_flow[, flow]</td><td>) -&gt; </td><td>flow</td></tr><tr><td style="width: 20px;"></td><td>cv.optflow.calcOpticalFlowSF(</td><td class="paramname">from_, to, layers, averaging_block_size, max_flow, sigma_dist, sigma_color, postprocess_window, sigma_dist_fix, sigma_color_fix, occ_thr, upscale_averaging_radius, upscale_sigma_dist, upscale_sigma_color, speed_up_thr[, flow]</td><td>) -&gt; </td><td>flow</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../de/d67/optflow_8hpp.html">opencv2/optflow.hpp</a>&gt;</code></p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
</div>
</div>
<a id="gaf23c367519903ed2384e9532e43c7032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf23c367519903ed2384e9532e43c7032">◆ </a></span>calcOpticalFlowSF() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::optflow::calcOpticalFlowSF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>averaging_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>max_flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>sigma_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>sigma_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>postprocess_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>sigma_dist_fix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>sigma_color_fix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>occ_thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>upscale_averaging_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>upscale_sigma_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>upscale_sigma_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>speed_up_thr</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.calcOpticalFlowSF(</td><td class="paramname">from_, to, layers, averaging_block_size, max_flow[, flow]</td><td>) -&gt; </td><td>flow</td></tr><tr><td style="width: 20px;"></td><td>cv.optflow.calcOpticalFlowSF(</td><td class="paramname">from_, to, layers, averaging_block_size, max_flow, sigma_dist, sigma_color, postprocess_window, sigma_dist_fix, sigma_color_fix, occ_thr, upscale_averaging_radius, upscale_sigma_dist, upscale_sigma_color, speed_up_thr[, flow]</td><td>) -&gt; </td><td>flow</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../de/d67/optflow_8hpp.html">opencv2/optflow.hpp</a>&gt;</code></p>
<p>Calculate an optical flow using "SimpleFlow" algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>First 8-bit 3-channel image. </td></tr>
    <tr><td class="paramname">to</td><td>Second 8-bit 3-channel image of the same size as prev </td></tr>
    <tr><td class="paramname">flow</td><td>computed flow image that has the same size as prev and type CV_32FC2 </td></tr>
    <tr><td class="paramname">layers</td><td>Number of layers </td></tr>
    <tr><td class="paramname">averaging_block_size</td><td>Size of block through which we sum up when calculate cost function for pixel </td></tr>
    <tr><td class="paramname">max_flow</td><td>maximal flow that we search at each level </td></tr>
    <tr><td class="paramname">sigma_dist</td><td>vector smooth spatial sigma parameter </td></tr>
    <tr><td class="paramname">sigma_color</td><td>vector smooth color sigma parameter </td></tr>
    <tr><td class="paramname">postprocess_window</td><td>window size for postprocess cross bilateral filter </td></tr>
    <tr><td class="paramname">sigma_dist_fix</td><td>spatial sigma for postprocess cross bilateralf filter </td></tr>
    <tr><td class="paramname">sigma_color_fix</td><td>color sigma for postprocess cross bilateral filter </td></tr>
    <tr><td class="paramname">occ_thr</td><td>threshold for detecting occlusions </td></tr>
    <tr><td class="paramname">upscale_averaging_radius</td><td>window size for bilateral upscale operation </td></tr>
    <tr><td class="paramname">upscale_sigma_dist</td><td>spatial sigma for bilateral upscale operation </td></tr>
    <tr><td class="paramname">upscale_sigma_color</td><td>color sigma for bilateral upscale operation </td></tr>
    <tr><td class="paramname">speed_up_thr</td><td>threshold to detect point with irregular flow - where flow should be recalculated after upscale</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="../../d0/de3/citelist.html#CITEREF_Tao2012">[243]</a> . And site of project - <a href="http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/">http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/</a>.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>An example using the simpleFlow algorithm can be found at samples/simpleflow_demo.cpp </li>
</ul>
</dd></dl>
</div>
</div>
<a id="ga32ba4b0f6a21684d99d45f6bc470f480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32ba4b0f6a21684d99d45f6bc470f480">◆ </a></span>calcOpticalFlowSparseRLOF()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::optflow::calcOpticalFlowSparseRLOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>prevImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>nextImg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>prevPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaf77c9a14ef956c50c1efd4547f444e63">InputOutputArray</a> </td>
          <td class="paramname"><em>nextPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html">RLOFOpticalFlowParameter</a> &gt; </td>
          <td class="paramname"><em>rlofParam</em> = <code><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html">RLOFOpticalFlowParameter</a> &gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>forwardBackwardThreshold</em> = <code>0</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.calcOpticalFlowSparseRLOF(</td><td class="paramname">prevImg, nextImg, prevPts, nextPts[, status[, err[, rlofParam[, forwardBackwardThreshold]]]]</td><td>) -&gt; </td><td>nextPts, status, err</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../da/da2/rlofflow_8hpp.html">opencv2/optflow/rlofflow.hpp</a>&gt;</code></p>
<p>Calculates fast optical flow for a sparse feature set using the robust local optical flow (RLOF) similar to <a class="el" href="../../dc/d6b/group__video__track.html#ga473e4b886d0bcc6b65831eb88ed93323" title="Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyra...">optflow::calcOpticalFlowPyrLK()</a>. </p>
<p>The RLOF is a fast local optical flow approach described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2012">[219]</a> <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2013">[220]</a> <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2014">[221]</a> and <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2016">[222]</a> similar to the pyramidal iterative Lucas-Kanade method as proposed by <a class="el" href="../../d0/de3/citelist.html#CITEREF_Bouguet00">[32]</a>. More details and experiments can be found in the following thesis <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2019">[223]</a>. The implementation is derived from <a class="el" href="../../dc/d6b/group__video__track.html#ga473e4b886d0bcc6b65831eb88ed93323" title="Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyra...">optflow::calcOpticalFlowPyrLK()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prevImg</td><td>first 8-bit input image. If The cross-based RLOF is used (by selecting <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html#a203bd482fc0efa091faf0e537768d5d1">optflow::RLOFOpticalFlowParameter::supportRegionType</a> = SupportRegionType::SR_CROSS) image has to be a 8-bit 3 channel image. </td></tr>
    <tr><td class="paramname">nextImg</td><td>second 8-bit input image. If The cross-based RLOF is used (by selecting <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html#a203bd482fc0efa091faf0e537768d5d1">optflow::RLOFOpticalFlowParameter::supportRegionType</a> = SupportRegionType::SR_CROSS) image has to be a 8-bit 3 channel image. </td></tr>
    <tr><td class="paramname">prevPts</td><td>vector of 2D points for which the flow needs to be found; point coordinates must be single-precision floating-point numbers. </td></tr>
    <tr><td class="paramname">nextPts</td><td>output vector of 2D points (with single-precision floating-point coordinates) containing the calculated new positions of input features in the second image; when <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html#adce1ef76d306f2f10962ae9e93ab1c4c">optflow::RLOFOpticalFlowParameter::useInitialFlow</a> variable is true the vector must have the same size as in the input and contain the initialization point correspondences. </td></tr>
    <tr><td class="paramname">status</td><td>output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has passed the forward backward check. </td></tr>
    <tr><td class="paramname">err</td><td>output vector of errors; each element of the vector is set to the forward backward error for the corresponding feature. </td></tr>
    <tr><td class="paramname">rlofParam</td><td>see <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html" title="This is used store and set up the parameters of the robust local optical flow (RLOF) algoritm...">optflow::RLOFOpticalFlowParameter</a> </td></tr>
    <tr><td class="paramname">forwardBackwardThreshold</td><td>Threshold for the forward backward confidence check. If forewardBackwardThreshold &lt;=0 the forward</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>SIMD parallelization is only available when compiling with SSE4.1.</dd></dl>
<p>Parameters have been described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2012">[219]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2013">[220]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2014">[221]</a> and <a class="el" href="../../d0/de3/citelist.html#CITEREF_Senst2016">[222]</a>. For the RLOF configuration see <a class="el" href="../../d4/d91/classcv_1_1optflow_1_1RLOFOpticalFlowParameter.html" title="This is used store and set up the parameters of the robust local optical flow (RLOF) algoritm...">optflow::RLOFOpticalFlowParameter</a> for further details. </p>
</div>
</div>
<a id="gad6aa63f2703202806fe18dc1353b5f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6aa63f2703202806fe18dc1353b5f4b">◆ </a></span>calcOpticalFlowSparseToDense()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::optflow::calcOpticalFlowSparseToDense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>grid_step</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>k</em> = <code>128</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>sigma</em> = <code>0.05f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool </td>
          <td class="paramname"><em>use_post_proc</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>fgs_lambda</em> = <code>500.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float </td>
          <td class="paramname"><em>fgs_sigma</em> = <code>1.5f</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.calcOpticalFlowSparseToDense(</td><td class="paramname">from_, to[, flow[, grid_step[, k[, sigma[, use_post_proc[, fgs_lambda[, fgs_sigma]]]]]]]</td><td>) -&gt; </td><td>flow</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../de/d67/optflow_8hpp.html">opencv2/optflow.hpp</a>&gt;</code></p>
<p>Fast dense optical flow based on PyrLK sparse matches interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>first 8-bit 3-channel or 1-channel image. </td></tr>
    <tr><td class="paramname">to</td><td>second 8-bit 3-channel or 1-channel image of the same size as from </td></tr>
    <tr><td class="paramname">flow</td><td>computed flow image that has the same size as from and CV_32FC2 type </td></tr>
    <tr><td class="paramname">grid_step</td><td>stride used in sparse match computation. Lower values usually result in higher quality but slow down the algorithm. </td></tr>
    <tr><td class="paramname">k</td><td>number of nearest-neighbor matches considered, when fitting a locally affine model. Lower values can make the algorithm noticeably faster at the cost of some quality degradation. </td></tr>
    <tr><td class="paramname">sigma</td><td>parameter defining how fast the weights decrease in the locally-weighted affine fitting. Higher values can help preserve fine details, lower values can help to get rid of the noise in the output flow. </td></tr>
    <tr><td class="paramname">use_post_proc</td><td>defines whether the <a class="el" href="../../da/d17/group__ximgproc__filters.html#gaf8673fe9147160ad96ac6053fac3c106" title="Simple one-line Fast Global Smoother filter call. If you have multiple images to filter with the same...">ximgproc::fastGlobalSmootherFilter()</a> is used for post-processing after interpolation </td></tr>
    <tr><td class="paramname">fgs_lambda</td><td>see the respective parameter of the <a class="el" href="../../da/d17/group__ximgproc__filters.html#gaf8673fe9147160ad96ac6053fac3c106" title="Simple one-line Fast Global Smoother filter call. If you have multiple images to filter with the same...">ximgproc::fastGlobalSmootherFilter()</a> </td></tr>
    <tr><td class="paramname">fgs_sigma</td><td>see the respective parameter of the <a class="el" href="../../da/d17/group__ximgproc__filters.html#gaf8673fe9147160ad96ac6053fac3c106" title="Simple one-line Fast Global Smoother filter call. If you have multiple images to filter with the same...">ximgproc::fastGlobalSmootherFilter()</a> </td></tr>
  </table>
  </dd>
</dl>
</div>
</div>
<a id="ga5e735547610172695cb0b39495af9d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e735547610172695cb0b39495af9d6d">◆ </a></span>createOptFlow_DeepFlow()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a>&gt; cv::optflow::createOptFlow_DeepFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.createOptFlow_DeepFlow(</td><td class="paramname"></td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../de/d67/optflow_8hpp.html">opencv2/optflow.hpp</a>&gt;</code></p>
<p>DeepFlow optical flow algorithm implementation. </p>
<p>The class implements the DeepFlow optical flow algorithm described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Weinzaepfel2013">[275]</a> . See also <a href="http://lear.inrialpes.fr/src/deepmatching/">http://lear.inrialpes.fr/src/deepmatching/</a> . Parameters - class fields - that may be modified after creating a class instance:</p><ul>
<li>member float alpha Smoothness assumption weight</li>
<li>member float delta Color constancy assumption weight</li>
<li>member float gamma Gradient constancy weight</li>
<li>member float sigma Gaussian smoothing parameter</li>
<li>member int minSize Minimal dimension of an image in the pyramid (next, smaller images in the pyramid are generated until one of the dimensions reaches this size)</li>
<li>member float downscaleFactor Scaling factor in the image pyramid (must be &lt; 1)</li>
<li>member int fixedPointIterations How many iterations on each level of the pyramid</li>
<li>member int sorIterations Iterations of Succesive Over-Relaxation (solver)</li>
<li>member float omega Relaxation factor in SOR </li>
</ul>
</div>
</div>
<a id="ga6c01ebcd843767fd4bd754f4238dc72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c01ebcd843767fd4bd754f4238dc72c">◆ </a></span>createOptFlow_DenseRLOF()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a>&gt; cv::optflow::createOptFlow_DenseRLOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.createOptFlow_DenseRLOF(</td><td class="paramname"></td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../da/da2/rlofflow_8hpp.html">opencv2/optflow/rlofflow.hpp</a>&gt;</code></p>
<p>Additional interface to the Dense RLOF algorithm - <a class="el" href="../../d2/d84/group__optflow.html#ga0fc536362c239654322d9015f6efcecd" title="Fast dense optical flow computation based on robust local optical flow (RLOF) algorithms and sparse-t...">optflow::calcOpticalFlowDenseRLOF()</a> </p>
</div>
</div>
<a id="ga132098d4d6e74b96c715bb9c451a1d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga132098d4d6e74b96c715bb9c451a1d8f">◆ </a></span>createOptFlow_DualTVL1()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../dc/d4d/classcv_1_1optflow_1_1DualTVL1OpticalFlow.html">DualTVL1OpticalFlow</a>&gt; cv::optflow::createOptFlow_DualTVL1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.createOptFlow_DualTVL1(</td><td class="paramname"></td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../de/d67/optflow_8hpp.html">opencv2/optflow.hpp</a>&gt;</code></p>
<p>Creates instance of <a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">cv::DenseOpticalFlow</a>. </p>
</div>
</div>
<a id="gadd1519b8b360c101de0a2d3d3ca5f0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd1519b8b360c101de0a2d3d3ca5f0e1">◆ </a></span>createOptFlow_Farneback()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a>&gt; cv::optflow::createOptFlow_Farneback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.createOptFlow_Farneback(</td><td class="paramname"></td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../de/d67/optflow_8hpp.html">opencv2/optflow.hpp</a>&gt;</code></p>
<p>Additional interface to the Farneback's algorithm - <a class="el" href="../../dc/d6b/group__video__track.html#ga5d10ebbd59fe09c5f650289ec0ece5af" title="Computes a dense optical flow using the Gunnar Farneback's algorithm. ">calcOpticalFlowFarneback()</a> </p>
</div>
</div>
<a id="gabbf0942f6ab840dcb1c10273b02507f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbf0942f6ab840dcb1c10273b02507f0">◆ </a></span>createOptFlow_PCAFlow()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a>&gt; cv::optflow::createOptFlow_PCAFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.createOptFlow_PCAFlow(</td><td class="paramname"></td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../dc/dee/pcaflow_8hpp.html">opencv2/optflow/pcaflow.hpp</a>&gt;</code></p>
<p>Creates an instance of PCAFlow. </p>
</div>
</div>
<a id="gab3fd0cd6d32cb7cfa169cb72e804d0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3fd0cd6d32cb7cfa169cb72e804d0b4">◆ </a></span>createOptFlow_SimpleFlow()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a>&gt; cv::optflow::createOptFlow_SimpleFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.createOptFlow_SimpleFlow(</td><td class="paramname"></td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../de/d67/optflow_8hpp.html">opencv2/optflow.hpp</a>&gt;</code></p>
<p>Additional interface to the SimpleFlow algorithm - <a class="el" href="../../d2/d84/group__optflow.html#ga370e4f91055a5ae14a0db71850b2f788">calcOpticalFlowSF()</a> </p>
</div>
</div>
<a id="gadcd2f4b1ecb8ea366bdc23f8f23da7ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcd2f4b1ecb8ea366bdc23f8f23da7ac">◆ </a></span>createOptFlow_SparseRLOF()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../de/d14/classcv_1_1SparseOpticalFlow.html">SparseOpticalFlow</a>&gt; cv::optflow::createOptFlow_SparseRLOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.createOptFlow_SparseRLOF(</td><td class="paramname"></td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../da/da2/rlofflow_8hpp.html">opencv2/optflow/rlofflow.hpp</a>&gt;</code></p>
<p>Additional interface to the Sparse RLOF algorithm - <a class="el" href="../../d2/d84/group__optflow.html#ga32ba4b0f6a21684d99d45f6bc470f480" title="Calculates fast optical flow for a sparse feature set using the robust local optical flow (RLOF) simi...">optflow::calcOpticalFlowSparseRLOF()</a> </p>
</div>
</div>
<a id="gae7bcbdec27f2006dde666c5f6c6e232d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7bcbdec27f2006dde666c5f6c6e232d">◆ </a></span>createOptFlow_SparseToDense()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/dde/classcv_1_1DenseOpticalFlow.html">DenseOpticalFlow</a>&gt; cv::optflow::createOptFlow_SparseToDense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.optflow.createOptFlow_SparseToDense(</td><td class="paramname"></td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../de/d67/optflow_8hpp.html">opencv2/optflow.hpp</a>&gt;</code></p>
<p>Additional interface to the SparseToDenseFlow algorithm - <a class="el" href="../../d2/d84/group__optflow.html#gad6aa63f2703202806fe18dc1353b5f4b" title="Fast dense optical flow based on PyrLK sparse matches interpolation. ">calcOpticalFlowSparseToDense()</a> </p>
</div>
</div>
<a id="ga91c50d0cd4b35a72f3850f87fddec2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91c50d0cd4b35a72f3850f87fddec2cb">◆ </a></span>findCorrespondences()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../da/dfe/classcv_1_1optflow_1_1GPCForest.html">cv::optflow::GPCForest</a>&lt; T &gt;::findCorrespondences </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>imgFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>imgTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga0f70b52f0c0b119f7ed2448ffebdc144">Point2i</a>, <a class="el" href="../../dc/d84/group__core__basic.html#ga0f70b52f0c0b119f7ed2448ffebdc144">Point2i</a> &gt; &gt; &amp; </td>
          <td class="paramname"><em>corr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html">GPCMatchingParams</a> </td>
          <td class="paramname"><em>params</em> = <code><a class="el" href="../../d0/d4d/structcv_1_1optflow_1_1GPCMatchingParams.html">GPCMatchingParams</a>()</code> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../d8/dc5/sparse__matching__gpc_8hpp.html">opencv2/optflow/sparse_matching_gpc.hpp</a>&gt;</code></p>
<p>Find correspondences between two images. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">imgFrom</td><td>First image in a sequence. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">imgTo</td><td>Second image in a sequence. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">corr</td><td>Output vector with pairs of corresponding points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>Additional matching parameters for fine-tuning. </td></tr>
  </table>
  </dd>
</dl>
</div>
</div>
<a id="ga9eea50c233a0a6d7fecdd2c66821eed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9eea50c233a0a6d7fecdd2c66821eed5">◆ </a></span>segmentMotion()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::motempl::segmentMotion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaad17fda1d0f0d1ee069aebb1df2913c0">OutputArray</a> </td>
          <td class="paramname"><em>segmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../dc/d84/group__core__basic.html#ga11d95de507098e90bad732b9345402e8">Rect</a> &gt; &amp; </td>
          <td class="paramname"><em>boundingRects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>segThresh</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.motempl.segmentMotion(</td><td class="paramname">mhi, timestamp, segThresh[, segmask]</td><td>) -&gt; </td><td>segmask, boundingRects</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../da/d48/motempl_8hpp.html">opencv2/optflow/motempl.hpp</a>&gt;</code></p>
<p>Splits a motion history image into a few parts corresponding to separate independent motions (for example, left hand, right hand). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mhi</td><td>Motion history image. </td></tr>
    <tr><td class="paramname">segmask</td><td>Image where the found mask should be stored, single-channel, 32-bit floating-point. </td></tr>
    <tr><td class="paramname">boundingRects</td><td>Vector containing ROIs of motion connected components. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Current time in milliseconds or other units. </td></tr>
    <tr><td class="paramname">segThresh</td><td>Segmentation threshold that is recommended to be equal to the interval between motion history "steps" or greater.</td></tr>
  </table>
  </dd>
</dl>
<p>The function finds all of the motion segments and marks them in segmask with individual values (1,2,...). It also computes a vector with ROIs of motion connected components. After that the motion direction for every component can be calculated with calcGlobalOrientation using the extracted mask of the particular component. </p>
</div>
</div>
<a id="ga9c60ca58707e508be624e21da1273026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c60ca58707e508be624e21da1273026">◆ </a></span>updateMotionHistory()</h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::motempl::updateMotionHistory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga353a9de602fe76c709e12074a6f362ba">InputArray</a> </td>
          <td class="paramname"><em>silhouette</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#gaf77c9a14ef956c50c1efd4547f444e63">InputOutputArray</a> </td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double </td>
          <td class="paramname"><em>duration</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.motempl.updateMotionHistory(</td><td class="paramname">silhouette, mhi, timestamp, duration</td><td>) -&gt; </td><td>mhi</td></tr></table>
</div><div class="memdoc">
<p><code>#include &lt;<a class="el" href="../../da/d48/motempl_8hpp.html">opencv2/optflow/motempl.hpp</a>&gt;</code></p>
<p>Updates the motion history image by a moving silhouette. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silhouette</td><td>Silhouette mask that has non-zero pixels where the motion occurs. </td></tr>
    <tr><td class="paramname">mhi</td><td>Motion history image that is updated by the function (single-channel, 32-bit floating-point). </td></tr>
    <tr><td class="paramname">timestamp</td><td>Current time in milliseconds or other units. </td></tr>
    <tr><td class="paramname">duration</td><td>Maximal duration of the motion track in the same units as timestamp .</td></tr>
  </table>
  </dd>
</dl>
<p>The function updates the motion history image as follows:</p>
<p class="formulaDsp">
\[\texttt{mhi} (x,y)= \forkthree{\texttt{timestamp}}{if \(\texttt{silhouette}(x,y) \ne 0\)}{0}{if \(\texttt{silhouette}(x,y) = 0\) and \(\texttt{mhi} &lt; (\texttt{timestamp} - \texttt{duration})\)}{\texttt{mhi}(x,y)}{otherwise}\]
</p>
<p>That is, MHI pixels where the motion occurs are set to the current timestamp , while the pixels where the motion happened last time a long time ago are cleared.</p>
<p>The function, together with calcMotionGradient and calcGlobalOrientation , implements a motion templates technique described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Davis97">[55]</a> and <a class="el" href="../../d0/de3/citelist.html#CITEREF_Bradski00">[34]</a> . </p>
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 5 2022 16:19:59 for OpenCV by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="../../doxygen.png"/>
</a> 1.8.13
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
