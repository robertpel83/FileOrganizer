<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>OpenCV: How to use the OpenCV parallel_for_ to parallelize your code</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
          distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
          distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.6.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/df8/tutorial_root.html">OpenCV Tutorials</a></li><li class="navelem"><a class="el" href="../../de/d7a/tutorial_table_of_content_core.html">The Core Functionality (core module)</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How to use the OpenCV parallel_for_ to parallelize your code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Prev Tutorial:</b> <a class="el" href="../../dd/d74/tutorial_file_input_output_with_xml_yml.html">File Input and Output using XML and YAML files</a></p>
<p><b>Next Tutorial:</b> <a class="el" href="../../d6/dd1/tutorial_univ_intrin.html">Vectorizing your code using Universal Intrinsics</a></p>
<table class="doxtable">
<tr>
<th align="right"></th><th align="left"></th></tr>
<tr>
<td align="right">Compatibility </td><td align="left">OpenCV &gt;= 3.0 </td></tr>
</table>
<h2>Goal </h2>
<p>The goal of this tutorial is to demonstrate the use of the OpenCV <code>parallel_for_</code> framework to easily parallelize your code. To illustrate the concept, we will write a program to perform convolution operation over an image. The full tutorial code is <a href="https://github.com/opencv/opencv/blob/4.x/samples/cpp/tutorial_code/core/how_to_use_OpenCV_parallel_for_/how_to_use_OpenCV_parallel_for_new.cpp">here</a>.</p>
<h2>Precondition </h2>
<h3>Parallel Frameworks</h3>
<p>The first precondition is to have OpenCV built with a parallel framework. In OpenCV 4.5, the following parallel frameworks are available in that order:</p>
<ul>
<li>Intel Threading Building Blocks (3rdparty library, should be explicitly enabled)</li>
<li>OpenMP (integrated to compiler, should be explicitly enabled)</li>
<li>APPLE GCD (system wide, used automatically (APPLE only))</li>
<li>Windows RT concurrency (system wide, used automatically (Windows RT only))</li>
<li>Windows concurrency (part of runtime, used automatically (Windows only - MSVC++ &gt;= 10))</li>
<li>Pthreads</li>
</ul>
<p>As you can see, several parallel frameworks can be used in the OpenCV library. Some parallel libraries are third party libraries and have to be explicitly enabled in CMake before building, while others are automatically available with the platform (e.g. APPLE GCD).</p>
<h3>Race Conditions</h3>
<p>Race conditions occur when more than one thread try to write <em>or</em> read and write to a particular memory location simultaneously. Based on that, we can broadly classify algorithms into two categories:-</p><ol type="1">
<li>Algorithms in which only a single thread writes data to a particular memory location.<ul>
<li>In <em>convolution</em>, for example, even though multiple threads may read from a pixel at a particular time, only a single thread <em>writes</em> to a particular pixel.</li>
</ul>
</li>
<li>Algorithms in which multiple threads may write to a single memory location.<ul>
<li>Finding contours, features, etc. Such algorithms may require each thread to add data to a global variable simultaneously. For example, when detecting features, each thread will add features of their respective parts of the image to a common vector, thus creating a race condition.</li>
</ul>
</li>
</ol>
<h2>Convolution </h2>
<p>We will use the example of performing a convolution to demonstrate the use of <code>parallel_for_</code> to parallelize the computation. This is an example of an algorithm which does not lead to a race condition.</p>
<h2>Theory </h2>
<p>Convolution is a simple mathematical operation widely used in image processing. Here, we slide a smaller matrix, called the <em>kernel</em>, over an image and a sum of the product of pixel values and corresponding values in the kernel gives us the value of the particular pixel in the output (called the anchor point of the kernel). Based on the values in the kernel, we get different results. In the example below, we use a 3x3 kernel (anchored at its center) and convolve over a 5x5 matrix to produce a 3x3 matrix. The size of the output can be altered by padding the input with suitable values. </p><div class="image">
<img src="../../convolution-example-matrix.gif" alt="convolution-example-matrix.gif"/>
<div class="caption">
Convolution Animation</div></div>
<p> For more information about different kernels and what they do, look <a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)">here</a></p>
<p>For the purpose of this tutorial, we will implement the simplest form of the function which takes a grayscale image (1 channel) and an odd length square kernel and produces an output image. The operation will not be performed in-place. </p><dl class="section note"><dt>Note</dt><dd>We can store a few of the relevant pixels temporarily to make sure we use the original values during the convolution and then do it in-place. However, the purpose of this tutorial is to introduce parallel_for_ function and an inplace implementation may be too complicated.</dd></dl>
<h2>Pseudocode </h2>
<pre class="fragment">InputImage src, OutputImage dst, kernel(size n)
makeborder(src, n/2)
for each pixel (i, j) strictly inside borders, do:
{
    value := 0
    for k := -n/2 to n/2, do:
        for l := -n/2 to n/2, do:
            value += kernel[n/2 + k][n/2 + l]*src[i + k][j + l]

    dst[i][j] := value
}
</pre><p>For an <em>n-sized kernel</em>, we will add a border of size <em>n/2</em> to handle edge cases. We then run two loops to move along the kernel and add the products to sum</p>
<h2>Implementation </h2>
<h3>Sequential implementation</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> conv_seq(Mat src, Mat &amp;dst, Mat kernel)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> rows = src.rows, cols = src.cols;</div><div class="line">    dst = Mat(rows, cols, src.type());</div><div class="line"></div><div class="line">    <span class="comment">// Taking care of edge values</span></div><div class="line">    <span class="comment">// Make border = kernel.rows / 2;</span></div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> sz = kernel.rows / 2;</div><div class="line">    <a class="code" href="../../d2/de8/group__core__array.html#ga2ac1049c2c3dd25c2b41bffe17658a36">copyMakeBorder</a>(src, src, sz, sz, sz, sz, <a class="code" href="../../d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aa1de4cff95e3377d6d0cbe7569bd4e9f">BORDER_REPLICATE</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows; i++)</div><div class="line">    {</div><div class="line">        <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> *dptr = dst.ptr(i);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; cols; j++)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">double</span> value = 0;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = -sz; k &lt;= sz; k++)</div><div class="line">            {</div><div class="line">                <span class="comment">// slightly faster results when we create a ptr due to more efficient memory access.</span></div><div class="line">                <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> *sptr = src.ptr(i + sz + k);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l = -sz; l &lt;= sz; l++)</div><div class="line">                {</div><div class="line">                    value += kernel.ptr&lt;<span class="keywordtype">double</span>&gt;(k + sz)[l + sz] * sptr[j + sz + l];</div><div class="line">                }</div><div class="line">            }</div><div class="line">            dptr[j] = <a class="code" href="../../db/de0/group__core__utils.html#gab93126370b85fda2c8bfaf8c811faeaf">saturate_cast</a>&lt;<a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt;(value);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> We first make an output matrix(dst) with the same size as src and add borders to the src image(to handle edge cases). </p><div class="fragment"><div class="line">    <span class="keywordtype">int</span> rows = src.rows, cols = src.cols;</div><div class="line">    dst = Mat(rows, cols, src.type());</div><div class="line"></div><div class="line">    <span class="comment">// Taking care of edge values</span></div><div class="line">    <span class="comment">// Make border = kernel.rows / 2;</span></div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> sz = kernel.rows / 2;</div><div class="line">    <a class="code" href="../../d2/de8/group__core__array.html#ga2ac1049c2c3dd25c2b41bffe17658a36">copyMakeBorder</a>(src, src, sz, sz, sz, sz, <a class="code" href="../../d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aa1de4cff95e3377d6d0cbe7569bd4e9f">BORDER_REPLICATE</a>);</div></div><!-- fragment --><p> We then sequentially iterate over the pixels in the src image and compute the value over the kernel and the neighbouring pixel values. We then fill value to the corresponding pixel in the dst image. </p><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows; i++)</div><div class="line">    {</div><div class="line">        <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> *dptr = dst.ptr(i);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; cols; j++)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">double</span> value = 0;</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = -sz; k &lt;= sz; k++)</div><div class="line">            {</div><div class="line">                <span class="comment">// slightly faster results when we create a ptr due to more efficient memory access.</span></div><div class="line">                <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> *sptr = src.ptr(i + sz + k);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l = -sz; l &lt;= sz; l++)</div><div class="line">                {</div><div class="line">                    value += kernel.ptr&lt;<span class="keywordtype">double</span>&gt;(k + sz)[l + sz] * sptr[j + sz + l];</div><div class="line">                }</div><div class="line">            }</div><div class="line">            dptr[j] = <a class="code" href="../../db/de0/group__core__utils.html#gab93126370b85fda2c8bfaf8c811faeaf">saturate_cast</a>&lt;<a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt;(value);</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --> <h3>Parallel implementation</h3>
<p>When looking at the sequential implementation, we can notice that each pixel depends on multiple neighbouring pixels but only one pixel is edited at a time. Thus, to optimize the computation, we can split the image into stripes and parallelly perform convolution on each, by exploiting the multi-core architecture of modern processor. The OpenCV <a class="el" href="../../d3/d89/group__core__parallel.html#gaa42ec9937b847cb52a97c613fc894c4a">cv::parallel_for_</a> framework automatically decides how to split the computation efficiently and does most of the work for us.</p>
<dl class="section note"><dt>Note</dt><dd>Although values of a pixel in a particular stripe may depend on pixel values outside the stripe, these are only read only operations and hence will not cause undefined behaviour.</dd></dl>
<p>We first declare a custom class that inherits from <a class="el" href="../../d2/d74/classcv_1_1ParallelLoopBody.html">cv::ParallelLoopBody</a> and override the <code>virtual void operator ()(const cv::Range&amp; range) const</code>. </p><div class="fragment"><div class="line"><span class="keyword">class </span>parallelConvolution : <span class="keyword">public</span> ParallelLoopBody</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Mat m_src, &amp;m_dst;</div><div class="line">    Mat m_kernel;</div><div class="line">    <span class="keywordtype">int</span> sz;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    parallelConvolution(Mat src, Mat &amp;dst, Mat kernel)</div><div class="line">        : m_src(src), m_dst(dst), m_kernel(kernel)</div><div class="line">    {</div><div class="line">        sz = kernel.rows / 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> Range &amp;range) <span class="keyword">const</span> <a class="code" href="../../db/de0/group__core__utils.html#ga4d89d63e402ef9ddc48e18e21180fe4a">CV_OVERRIDE</a></div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = range.start; r &lt; range.end; r++)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">int</span> i = r / m_src.cols, j = r % m_src.cols;</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> value = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = -sz; k &lt;= sz; k++)</div><div class="line">            {</div><div class="line">                <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> *sptr = m_src.ptr(i + sz + k);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l = -sz; l &lt;= sz; l++)</div><div class="line">                {</div><div class="line">                    value += m_kernel.ptr&lt;<span class="keywordtype">double</span>&gt;(k + sz)[l + sz] * sptr[j + sz + l];</div><div class="line">                }</div><div class="line">            }</div><div class="line">            m_dst.ptr(i)[j] = <a class="code" href="../../db/de0/group__core__utils.html#gab93126370b85fda2c8bfaf8c811faeaf">saturate_cast</a>&lt;<a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt;(value);</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p> The range in the <code>operator ()</code> represents the subset of values that will be treated by an individual thread. Based on the requirement, there may be different ways of splitting the range which in turn changes the computation.</p>
<p>For example, we can either</p><ol type="1">
<li><p class="startli">Split the entire traversal of the image and obtain the [row, col] coordinate in the following way (as shown in the above code):</p>
<div class="fragment"><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> Range &amp;range) <span class="keyword">const</span> <a class="code" href="../../db/de0/group__core__utils.html#ga4d89d63e402ef9ddc48e18e21180fe4a">CV_OVERRIDE</a></div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = range.start; r &lt; range.end; r++)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">int</span> i = r / m_src.cols, j = r % m_src.cols;</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> value = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = -sz; k &lt;= sz; k++)</div><div class="line">            {</div><div class="line">                uchar *sptr = m_src.ptr(i + sz + k);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l = -sz; l &lt;= sz; l++)</div><div class="line">                {</div><div class="line">                    value += m_kernel.ptr&lt;<span class="keywordtype">double</span>&gt;(k + sz)[l + sz] * sptr[j + sz + l];</div><div class="line">                }</div><div class="line">            }</div><div class="line">            m_dst.ptr(i)[j] = <a class="code" href="../../db/de0/group__core__utils.html#gab93126370b85fda2c8bfaf8c811faeaf">saturate_cast</a>&lt;uchar&gt;(value);</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> We would then call the parallel_for_ function in the following way: </p><div class="fragment"><div class="line">    parallelConvolution obj(src, dst, kernel);</div><div class="line">    <a class="code" href="../../d3/d89/group__core__parallel.html#gaa42ec9937b847cb52a97c613fc894c4a">parallel_for_</a>(Range(0, rows * cols), obj);</div></div><!-- fragment --><p><br />
</p>
</li>
<li><p class="startli">Split the rows and compute for each row:</p>
<div class="fragment"><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> Range &amp;range) <span class="keyword">const</span> <a class="code" href="../../db/de0/group__core__utils.html#ga4d89d63e402ef9ddc48e18e21180fe4a">CV_OVERRIDE</a></div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = range.start; i &lt; range.end; i++)</div><div class="line">        {</div><div class="line"></div><div class="line">            uchar *dptr = dst.ptr(i);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; cols; j++)</div><div class="line">            {</div><div class="line">                <span class="keywordtype">double</span> value = 0;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = -sz; k &lt;= sz; k++)</div><div class="line">                {</div><div class="line">                    uchar *sptr = src.ptr(i + sz + k);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l = -sz; l &lt;= sz; l++)</div><div class="line">                    {</div><div class="line">                        value += kernel.ptr&lt;<span class="keywordtype">double</span>&gt;(k + sz)[l + sz] * sptr[j + sz + l];</div><div class="line">                    }</div><div class="line">                }</div><div class="line">                dptr[j] = <a class="code" href="../../db/de0/group__core__utils.html#gab93126370b85fda2c8bfaf8c811faeaf">saturate_cast</a>&lt;uchar&gt;(value);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p> In this case, we call the parallel_for_ function with a different range: </p><div class="fragment"><div class="line">    parallelConvolutionRowSplit obj(src, dst, kernel);</div><div class="line">    <a class="code" href="../../d3/d89/group__core__parallel.html#gaa42ec9937b847cb52a97c613fc894c4a">parallel_for_</a>(Range(0, rows), obj);</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>In our case, both implementations perform similarly. Some cases may allow better memory access patterns or other performance benefits.</dd></dl>
<p>To set the number of threads, you can use: <a class="el" href="../../db/de0/group__core__utils.html#gae78625c3c2aa9e0b83ed31b73c6549c0">cv::setNumThreads</a>. You can also specify the number of splitting using the nstripes parameter in <a class="el" href="../../d3/d89/group__core__parallel.html#gaa42ec9937b847cb52a97c613fc894c4a">cv::parallel_for_</a>. For instance, if your processor has 4 threads, setting <code>cv::setNumThreads(2)</code> or setting <code>nstripes=2</code> should be the same as by default it will use all the processor threads available but will split the workload only on two threads.</p>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>C++ 11 standard allows to simplify the parallel implementation by get rid of the <code>parallelConvolution</code> class and replacing it with lambda expression:</dd></dl>
<div class="fragment"><div class="line">    <a class="code" href="../../d3/d89/group__core__parallel.html#gaa42ec9937b847cb52a97c613fc894c4a">parallel_for_</a>(Range(0, rows * cols), [&amp;](<span class="keyword">const</span> Range &amp;range)</div><div class="line">                    {</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = range.start; r &lt; range.end; r++)</div><div class="line">                        {</div><div class="line">                            int i = r / cols, j = r % cols;</div><div class="line"></div><div class="line">                            double value = 0;</div><div class="line">                            for (int k = -sz; k &lt;= sz; k++)</div><div class="line">                            {</div><div class="line">                                uchar *sptr = src.ptr(i + sz + k);</div><div class="line">                                for (int l = -sz; l &lt;= sz; l++)</div><div class="line">                                {</div><div class="line">                                    value += kernel.ptr&lt;double&gt;(k + sz)[l + sz] * sptr[j + sz + l];</div><div class="line">                                }</div><div class="line">                            }</div><div class="line">                            dst.ptr(i)[j] = <a class="code" href="../../db/de0/group__core__utils.html#gab93126370b85fda2c8bfaf8c811faeaf">saturate_cast</a>&lt;uchar&gt;(value);</div><div class="line">                        }</div><div class="line">                    });</div></div><!-- fragment --> <h2>Results </h2>
<p>The resulting time taken for execution of the two implementations on a</p><ul>
<li><em>512x512 input</em> with a <em>5x5 kernel</em>: <pre class="fragment">  This program shows how to use the OpenCV parallel_for_ function and
  compares the performance of the sequential and parallel implementations for a
  convolution operation
  Usage:
  ./a.out [image_path -- default lena.jpg]

  Sequential Implementation: 0.0953564s
  Parallel Implementation: 0.0246762s
  Parallel Implementation(Row Split): 0.0248722s
</pre></li>
</ul>
<p><br />
</p>
<ul>
<li><em>512x512 input with a 3x3 kernel</em> <pre class="fragment">  This program shows how to use the OpenCV parallel_for_ function and
  compares the performance of the sequential and parallel implementations for a
  convolution operation
  Usage:
  ./a.out [image_path -- default lena.jpg]

  Sequential Implementation: 0.0301325s
  Parallel Implementation: 0.0117053s
  Parallel Implementation(Row Split): 0.0117894s
</pre></li>
</ul>
<p>The performance of the parallel implementation depends on the type of CPU you have. For instance, on 4 cores - 8 threads CPU, runtime may be 6x to 7x faster than a sequential implementation. There are many factors to explain why we do not achieve a speed-up of 8x:</p><ul>
<li>the overhead to create and manage the threads,</li>
<li>background processes running in parallel,</li>
<li>the difference between 4 hardware cores with 2 logical threads for each core and 8 hardware cores.</li>
</ul>
<p>In the tutorial, we used a horizontal gradient filter(as shown in the animation above), which produces an image highlighting the vertical edges.</p>
<div class="image">
<img src="../../resimg.jpg" alt="resimg.jpg"/>
<div class="caption">
result image</div></div>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 5 2022 16:19:50 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
