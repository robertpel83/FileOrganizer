<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>OpenCV: Face Recognition with OpenCV</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
          distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
          distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.6.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d3/d81/tutorial_contrib_root.html">Tutorials for contrib modules</a></li><li class="navelem"><a class="el" href="../../de/d27/tutorial_table_of_content_face.html">Tutorials for face module</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Face Recognition with OpenCV </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutorial_face_intro">Introduction </a><ul><li class="level2"><a href="#tutorial_face_facerec">Face Recognition </a></li>
<li class="level2"><a href="#tutorial_face_facedb">Face Database  </a><ul><li class="level3"><a href="#tutorial_face_prepare">Preparing the data</a></li>
</ul>
</li>
<li class="level2"><a href="#tutorial_face_eigenfaces">Eigenfaces  </a><ul><li class="level3"><a href="#tutorial_face_eigenfaces_algo">Algorithmic Description of Eigenfaces method</a></li>
<li class="level3"><a href="#tutorial_face_eigenfaces_use">Eigenfaces in OpenCV</a></li>
</ul>
</li>
<li class="level2"><a href="#tutorial_face_fisherfaces">Fisherfaces  </a><ul><li class="level3"><a href="#tutorial_face_fisherfaces_algo">Algorithmic Description of Fisherfaces method</a></li>
<li class="level3"><a href="#tutorial_face_fisherfaces_use">Fisherfaces in OpenCV</a></li>
</ul>
</li>
<li class="level2"><a href="#tutorial_face_lbph">Local Binary Patterns Histograms </a><ul><li class="level3"><a href="#tutorial_face_lbph_algo">Algorithmic Description of LBPH method</a></li>
<li class="level3"><a href="#tutorial_face_lbph_use">Local Binary Patterns Histograms in OpenCV</a></li>
</ul>
</li>
<li class="level2"><a href="#tutorial_face_conclusion">Conclusion </a></li>
<li class="level2"><a href="#tutorial_face_credits">Credits </a><ul><li class="level3"><a href="#tutorial_face_credits_db">The Database of Faces</a></li>
<li class="level3"><a href="#tutorial_face_credits_yalea">Yale Facedatabase A</a></li>
<li class="level3"><a href="#tutorial_face_credits_yaleb">Yale Facedatabase B</a></li>
</ul>
</li>
<li class="level2"><a href="#face_appendix">Appendix </a><ul><li class="level3"><a href="#tutorial_face_appendix_csv">Creating the CSV File</a></li>
<li class="level3"><a href="#tutorial_face_appendix_align">Aligning Face Images</a></li>
<li class="level3"><a href="#tutorial_face_appendix_attcsv">CSV for the AT&amp;T Facedatabase</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tutorial_face_intro"></a>
Introduction </h1>
<p><a href="http://opencv.org">OpenCV (Open Source Computer Vision)</a> is a popular computer vision library started by <a href="http://www.intel.com">Intel</a> in 1999. The cross-platform library sets its focus on real-time image processing and includes patent-free implementations of the latest computer vision algorithms. In 2008 <a href="http://www.willowgarage.com">Willow Garage</a> took over support and OpenCV 2.3.1 now comes with a programming interface to C, C++, <a href="http://www.python.org">Python</a> and <a href="http://www.android.com">Android</a>. OpenCV is released under a BSD license so it is used in academic projects and commercial products alike.</p>
<p>OpenCV 2.4 now comes with the very new FaceRecognizer class for face recognition, so you can start experimenting with face recognition right away. This document is the guide I've wished for, when I was working myself into face recognition. It shows you how to perform face recognition with FaceRecognizer in OpenCV (with full source code listings) and gives you an introduction into the algorithms behind. I'll also show how to create the visualizations you can find in many publications, because a lot of people asked for.</p>
<p>The currently available algorithms are:</p>
<ul>
<li>Eigenfaces (see EigenFaceRecognizer::create)</li>
<li>Fisherfaces (see FisherFaceRecognizer::create)</li>
<li>Local Binary Patterns Histograms (see LBPHFaceRecognizer::create)</li>
</ul>
<p>You don't need to copy and paste the source code examples from this page, because they are available in the src folder coming with this documentation. If you have built OpenCV with the samples turned on, chances are good you have them compiled already! Although it might be interesting for very advanced users, I've decided to leave the implementation details out as I am afraid they confuse new users.</p>
<p>All code in this document is released under the <a href="http://www.opensource.org/licenses/bsd-license">BSD license</a>, so feel free to use it for your projects.</p>
<h2><a class="anchor" id="tutorial_face_facerec"></a>
Face Recognition </h2>
<p>Face recognition is an easy task for humans. Experiments in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Tu06">[254]</a> have shown, that even one to three day old babies are able to distinguish between known faces. So how hard could it be for a computer? It turns out we know little about human recognition to date. Are inner features (eyes, nose, mouth) or outer features (head shape, hairline) used for a successful face recognition? How do we analyze an image and how does the brain encode it? It was shown by <a href="http://en.wikipedia.org/wiki/David_H._Hubel">David Hubel</a> and <a href="http://en.wikipedia.org/wiki/Torsten_Wiesel">Torsten Wiesel</a>, that our brain has specialized nerve cells responding to specific local features of a scene, such as lines, edges, angles or movement. Since we don't see the world as scattered pieces, our visual cortex must somehow combine the different sources of information into useful patterns. Automatic face recognition is all about extracting those meaningful features from an image, putting them into a useful representation and performing some kind of classification on them.</p>
<p>Face recognition based on the geometric features of a face is probably the most intuitive approach to face recognition. One of the first automated face recognition systems was described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Kanade73">[127]</a> : marker points (position of eyes, ears, nose, ...) were used to build a feature vector (distance between the points, angle between them, ...). The recognition was performed by calculating the euclidean distance between feature vectors of a probe and reference image. Such a method is robust against changes in illumination by its nature, but has a huge drawback: the accurate registration of the marker points is complicated, even with state of the art algorithms. Some of the latest work on geometric face recognition was carried out in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Bru92">[39]</a> . A 22-dimensional feature vector was used and experiments on large datasets have shown, that geometrical features alone may not carry enough information for face recognition.</p>
<p>The Eigenfaces method described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_TP91">[255]</a> took a holistic approach to face recognition: A facial image is a point from a high-dimensional image space and a lower-dimensional representation is found, where classification becomes easy. The lower-dimensional subspace is found with Principal Component Analysis, which identifies the axes with maximum variance. While this kind of transformation is optimal from a reconstruction standpoint, it doesn't take any class labels into account. Imagine a situation where the variance is generated from external sources, let it be light. The axes with maximum variance do not necessarily contain any discriminative information at all, hence a classification becomes impossible. So a class-specific projection with a Linear Discriminant Analysis was applied to face recognition in <a class="el" href="../../d0/de3/citelist.html#CITEREF_BHK97">[19]</a> . The basic idea is to minimize the variance within a class, while maximizing the variance between the classes at the same time.</p>
<p>Recently various methods for a local feature extraction emerged. To avoid the high-dimensionality of the input data only local regions of an image are described, the extracted features are (hopefully) more robust against partial occlusion, illumation and small sample size. Algorithms used for a local feature extraction are Gabor Wavelets (<a class="el" href="../../d0/de3/citelist.html#CITEREF_Wiskott97">[278]</a>), Discrete Cosinus Transform (<a class="el" href="../../d0/de3/citelist.html#CITEREF_Messer06">[172]</a>) and Local Binary Patterns (<a class="el" href="../../d0/de3/citelist.html#CITEREF_AHP04">[3]</a>). It's still an open research question what's the best way to preserve spatial information when applying a local feature extraction, because spatial information is potentially useful information.</p>
<h2><a class="anchor" id="tutorial_face_facedb"></a>
Face Database  </h2>
<p>Let's get some data to experiment with first. I don't want to do a toy example here. We are doing face recognition, so you'll need some face images! You can either create your own dataset or start with one of the available face databases, <a href="http://face-rec.org/databases">http://face-rec.org/databases/</a> gives you an up-to-date overview. Three interesting databases are (parts of the description are quoted from <a href="http://face-rec.org">http://face-rec.org</a>):</p>
<ul>
<li><a href="http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html">AT&amp;T Facedatabase</a> The AT&amp;T Facedatabase, sometimes also referred to as <em>ORL Database of Faces</em>, contains ten different images of each of 40 distinct subjects. For some subjects, the images were taken at different times, varying the lighting, facial expressions (open / closed eyes, smiling / not smiling) and facial details (glasses / no glasses). All the images were taken against a dark homogeneous background with the subjects in an upright, frontal position (with tolerance for some side movement).</li>
<li><p class="startli"><a href="http://vision.ucsd.edu/content/yale-face-database">Yale Facedatabase A</a>, also known as Yalefaces. The AT&amp;T Facedatabase is good for initial tests, but it's a fairly easy database. The Eigenfaces method already has a 97% recognition rate on it, so you won't see any great improvements with other algorithms. The Yale Facedatabase A (also known as Yalefaces) is a more appropriate dataset for initial experiments, because the recognition problem is harder. The database consists of 15 people (14 male, 1 female) each with 11 grayscale images sized \(320 \times 243\) pixel. There are changes in the light conditions (center light, left light, right light), facial expressions (happy, normal, sad, sleepy, surprised, wink) and glasses (glasses, no-glasses).</p>
<p class="startli">The original images are not cropped and aligned. Please look into the <a class="el" href="../../da/d60/tutorial_face_main.html#face_appendix">Appendix </a> for a Python script, that does the job for you.</p>
</li>
<li><a href="http://vision.ucsd.edu/~leekc/ExtYaleDatabase/ExtYaleB.html">Extended Yale Facedatabase B</a> The Extended Yale Facedatabase B contains 2414 images of 38 different people in its cropped version. The focus of this database is set on extracting features that are robust to illumination, the images have almost no variation in emotion/occlusion/... . I personally think, that this dataset is too large for the experiments I perform in this document. You better use the <a href="http://www.cl.cam.ac.uk/research/dtg/attarchive/facedatabase.html">AT&amp;T Facedatabase</a> for intial testing. A first version of the Yale Facedatabase B was used in <a class="el" href="../../d0/de3/citelist.html#CITEREF_BHK97">[19]</a> to see how the Eigenfaces and Fisherfaces method perform under heavy illumination changes. <a class="el" href="../../d0/de3/citelist.html#CITEREF_Lee05">[138]</a> used the same setup to take 16128 images of 28 people. The Extended Yale Facedatabase B is the merge of the two databases, which is now known as Extended Yalefacedatabase B.</li>
</ul>
<h3><a class="anchor" id="tutorial_face_prepare"></a>
Preparing the data</h3>
<p>Once we have acquired some data, we'll need to read it in our program. In the demo applications I have decided to read the images from a very simple CSV file. Why? Because it's the simplest platform-independent approach I can think of. However, if you know a simpler solution please ping me about it. Basically all the CSV file needs to contain are lines composed of a filename followed by a ; followed by the label (as <em>integer number</em>), making up a line like this:</p>
<div class="fragment"><div class="line">/path/to/image.ext;0</div></div><!-- fragment --><p>Let's dissect the line. /path/to/image.ext is the path to an image, probably something like this if you are in Windows: C:/faces/person0/image0.jpg. Then there is the separator ; and finally we assign the label 0 to the image. Think of the label as the subject (the person) this image belongs to, so same subjects (persons) should have the same label.</p>
<p>Download the AT&amp;T Facedatabase from AT&amp;T Facedatabase and the corresponding CSV file from at.txt, which looks like this (file is without ... of course):</p>
<div class="fragment"><div class="line">./at/s1/1.pgm;0</div><div class="line">./at/s1/2.pgm;0</div><div class="line">...</div><div class="line">./at/s2/1.pgm;1</div><div class="line">./at/s2/2.pgm;1</div><div class="line">...</div><div class="line">./at/s40/1.pgm;39</div><div class="line">./at/s40/2.pgm;39</div></div><!-- fragment --><p>Imagine I have extracted the files to D:/data/at and have downloaded the CSV file to D:/data/at.txt. Then you would simply need to Search &amp; Replace ./ with D:/data/. You can do that in an editor of your choice, every sufficiently advanced editor can do this. Once you have a CSV file with valid filenames and labels, you can run any of the demos by passing the path to the CSV file as parameter:</p>
<div class="fragment"><div class="line">facerec_demo.exe D:/data/at.txt</div></div><!-- fragment --><p>Please, see <a class="el" href="../../da/d60/tutorial_face_main.html#tutorial_face_appendix_csv">Creating the CSV File</a> for details on creating CSV file.</p>
<h2><a class="anchor" id="tutorial_face_eigenfaces"></a>
Eigenfaces  </h2>
<p>The problem with the image representation we are given is its high dimensionality. Two-dimensional \(p \times q\) grayscale images span a \(m = pq\)-dimensional vector space, so an image with \(100 \times 100\) pixels lies in a \(10,000\)-dimensional image space already. The question is: Are all dimensions equally useful for us? We can only make a decision if there's any variance in data, so what we are looking for are the components that account for most of the information. The Principal Component Analysis (PCA) was independently proposed by <a href="http://en.wikipedia.org/wiki/Karl_Pearson">Karl Pearson</a> (1901) and <a href="http://en.wikipedia.org/wiki/Harold_Hotelling">Harold Hotelling</a> (1933) to turn a set of possibly correlated variables into a smaller set of uncorrelated variables. The idea is, that a high-dimensional dataset is often described by correlated variables and therefore only a few meaningful dimensions account for most of the information. The PCA method finds the directions with the greatest variance in the data, called principal components.</p>
<h3><a class="anchor" id="tutorial_face_eigenfaces_algo"></a>
Algorithmic Description of Eigenfaces method</h3>
<p>Let \(X = \{ x_{1}, x_{2}, \ldots, x_{n} \}\) be a random vector with observations \(x_i \in R^{d}\).</p>
<ol type="1">
<li><p class="startli">Compute the mean \(\mu\)</p>
<p class="formulaDsp">
\[\mu = \frac{1}{n} \sum_{i=1}^{n} x_{i}\]
</p>
</li>
<li><p class="startli">Compute the the Covariance Matrix S</p>
<p class="formulaDsp">
\[S = \frac{1}{n} \sum_{i=1}^{n} (x_{i} - \mu) (x_{i} - \mu)^{T}`\]
</p>
</li>
<li><p class="startli">Compute the eigenvalues \(\lambda_{i}\) and eigenvectors \(v_{i}\) of \(S\)</p>
<p class="formulaDsp">
\[S v_{i} = \lambda_{i} v_{i}, i=1,2,\ldots,n\]
</p>
</li>
<li>Order the eigenvectors descending by their eigenvalue. The \(k\) principal components are the eigenvectors corresponding to the \(k\) largest eigenvalues.</li>
</ol>
<p>The \(k\) principal components of the observed vector \(x\) are then given by:</p>
<p class="formulaDsp">
\[y = W^{T} (x - \mu)\]
</p>
<p>where \(W = (v_{1}, v_{2}, \ldots, v_{k})\).</p>
<p>The reconstruction from the PCA basis is given by:</p>
<p class="formulaDsp">
\[x = W y + \mu\]
</p>
<p>where \(W = (v_{1}, v_{2}, \ldots, v_{k})\).</p>
<p>The Eigenfaces method then performs face recognition by:</p>
<ul>
<li>Projecting all training samples into the PCA subspace.</li>
<li>Projecting the query image into the PCA subspace.</li>
<li>Finding the nearest neighbor between the projected training images and the projected query image.</li>
</ul>
<p>Still there's one problem left to solve. Imagine we are given \(400\) images sized \(100 \times 100\) pixel. The Principal Component Analysis solves the covariance matrix \(S = X X^{T}\), where \({size}(X) = 10000 \times 400\) in our example. You would end up with a \(10000 \times 10000\) matrix, roughly \(0.8 GB\). Solving this problem isn't feasible, so we'll need to apply a trick. From your linear algebra lessons you know that a \(M \times N\) matrix with \(M &gt; N\) can only have \(N - 1\) non-zero eigenvalues. So it's possible to take the eigenvalue decomposition \(S = X^{T} X\) of size \(N \times N\) instead:</p>
<p class="formulaDsp">
\[X^{T} X v_{i} = \lambda_{i} v{i}\]
</p>
<p>and get the original eigenvectors of \(S = X X^{T}\) with a left multiplication of the data matrix:</p>
<p class="formulaDsp">
\[X X^{T} (X v_{i}) = \lambda_{i} (X v_{i})\]
</p>
<p>The resulting eigenvectors are orthogonal, to get orthonormal eigenvectors they need to be normalized to unit length. I don't want to turn this into a publication, so please look into <a class="el" href="../../d0/de3/citelist.html#CITEREF_Duda01">[64]</a> for the derivation and proof of the equations.</p>
<h3><a class="anchor" id="tutorial_face_eigenfaces_use"></a>
Eigenfaces in OpenCV</h3>
<p>For the first source code example, I'll go through it with you. I am first giving you the whole source code listing, and after this we'll look at the most important lines in detail. Please note: every source code listing is commented in detail, so you should have no problems following it.</p>
<p>The source code for this demo application is also available in the src folder coming with this documentation:</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Copyright (c) 2011. Philipp Wagner &lt;bytefish[at]gmx[dot]de&gt;.</span></div><div class="line"><span class="comment"> * Released to public domain under terms of the BSD Simplified license.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment"> * modification, are permitted provided that the following conditions are met:</span></div><div class="line"><span class="comment"> *   * Redistributions of source code must retain the above copyright</span></div><div class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"> *   * Redistributions in binary form must reproduce the above copyright</span></div><div class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer in the</span></div><div class="line"><span class="comment"> *     documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"> *   * Neither the name of the organization nor the names of its contributors</span></div><div class="line"><span class="comment"> *     may be used to endorse or promote products derived from this software</span></div><div class="line"><span class="comment"> *     without specific prior written permission.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *   See &lt;http://www.opensource.org/licenses/bsd-license&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d0/d9c/core_2include_2opencv2_2core_8hpp.html">opencv2/core.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d2/dc4/contrib_2modules_2face_2include_2opencv2_2face_8hpp.html">opencv2/face.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d4/dd5/highgui_8hpp.html">opencv2/highgui.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d1/d4f/imgproc_2include_2opencv2_2imgproc_8hpp.html">opencv2/imgproc.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d2/d75/namespacecv.html">cv</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d4/d48/namespacecv_1_1face.html">cv::face</a>;</div><div class="line"><span class="keyword">using namespace </span>std;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> norm_0_255(<a class="code" href="../../d4/d32/classcv_1_1__InputArray.html">InputArray</a> _src) {</div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> src = _src.<a class="code" href="../../d4/d32/classcv_1_1__InputArray.html#a9c09739ca3e0ce212e2ab8374aa2f195">getMat</a>();</div><div class="line">    <span class="comment">// Create and return normalized image:</span></div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> dst;</div><div class="line">    <span class="keywordflow">switch</span>(src.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#aa11336b9ac538e0475d840657ce164be">channels</a>()) {</div><div class="line">    <span class="keywordflow">case</span> 1:</div><div class="line">        <a class="code" href="../../dc/d84/group__core__basic.html#ga1b6a396a456c8b6c6e4afd8591560d80">cv::normalize</a>(_src, dst, 0, 255, <a class="code" href="../../d2/de8/group__core__array.html#ggad12cefbcb5291cf958a85b4b67b6149fa9f0c1c342a18114d47b516a88e29822e">NORM_MINMAX</a>, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> 3:</div><div class="line">        <a class="code" href="../../dc/d84/group__core__basic.html#ga1b6a396a456c8b6c6e4afd8591560d80">cv::normalize</a>(_src, dst, 0, 255, <a class="code" href="../../d2/de8/group__core__array.html#ggad12cefbcb5291cf958a85b4b67b6149fa9f0c1c342a18114d47b516a88e29822e">NORM_MINMAX</a>, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">        src.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a33fd5d125b4c302b0c9aa86980791a77">copyTo</a>(dst);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> dst;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> read_csv(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; filename, vector&lt;Mat&gt;&amp; images, vector&lt;int&gt;&amp; labels, <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;;&#39;</span>) {</div><div class="line">    std::ifstream file(filename.c_str(), ifstream::in);</div><div class="line">    <span class="keywordflow">if</span> (!file) {</div><div class="line">        <span class="keywordtype">string</span> error_message = <span class="stringliteral">&quot;No valid input file was given, please check the given filename.&quot;</span>;</div><div class="line">        <a class="code" href="../../db/de0/group__core__utils.html#ga5b48c333c777666e076bd7052799f891">CV_Error</a>(<a class="code" href="../../d1/d0d/namespacecv_1_1Error.html#a759fa1af92f7aa7377c76ffb142abccaaf587497af64537041ee62c04a92b755d">Error::StsBadArg</a>, error_message);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">string</span> <a class="code" href="../../d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2">line</a>, path, classlabel;</div><div class="line">    <span class="keywordflow">while</span> (getline(file, line)) {</div><div class="line">        stringstream liness(line);</div><div class="line">        getline(liness, path, separator);</div><div class="line">        getline(liness, classlabel);</div><div class="line">        <span class="keywordflow">if</span>(!path.empty() &amp;&amp; !classlabel.empty()) {</div><div class="line">            images.push_back(<a class="code" href="../../d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56">imread</a>(path, 0));</div><div class="line">            labels.push_back(atoi(classlabel.c_str()));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[]) {</div><div class="line">    <span class="comment">// Check for valid command line arguments, print usage</span></div><div class="line">    <span class="comment">// if no arguments were given.</span></div><div class="line">    <span class="keywordflow">if</span> (argc &lt; 2) {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;csv.ext&gt; &lt;output_folder&gt; &quot;</span> &lt;&lt; endl;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">string</span> output_folder = <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (argc == 3) {</div><div class="line">        output_folder = string(argv[2]);</div><div class="line">    }</div><div class="line">    <span class="comment">// Get the path to your CSV.</span></div><div class="line">    <span class="keywordtype">string</span> fn_csv = string(argv[1]);</div><div class="line">    <span class="comment">// These vectors hold the images and corresponding labels.</span></div><div class="line">    vector&lt;Mat&gt; images;</div><div class="line">    vector&lt;int&gt; labels;</div><div class="line">    <span class="comment">// Read in the data. This can fail if no valid</span></div><div class="line">    <span class="comment">// input filename is given.</span></div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        read_csv(fn_csv, images, labels);</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="../../d1/dee/classcv_1_1Exception.html">cv::Exception</a>&amp; e) {</div><div class="line">        cerr &lt;&lt; <span class="stringliteral">&quot;Error opening file \&quot;&quot;</span> &lt;&lt; fn_csv &lt;&lt; <span class="stringliteral">&quot;\&quot;. Reason: &quot;</span> &lt;&lt; e.<a class="code" href="../../d1/dee/classcv_1_1Exception.html#a7ead458b4fc88ebca20b231383c49845">msg</a> &lt;&lt; endl;</div><div class="line">        <span class="comment">// nothing more we can do</span></div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line">    <span class="comment">// Quit if there are not enough images for this demo.</span></div><div class="line">    <span class="keywordflow">if</span>(images.size() &lt;= 1) {</div><div class="line">        <span class="keywordtype">string</span> error_message = <span class="stringliteral">&quot;This demo needs at least 2 images to work. Please add more images to your data set!&quot;</span>;</div><div class="line">        <a class="code" href="../../db/de0/group__core__utils.html#ga5b48c333c777666e076bd7052799f891">CV_Error</a>(<a class="code" href="../../d1/d0d/namespacecv_1_1Error.html#a759fa1af92f7aa7377c76ffb142abccaacf93e97abba2e7defa74fe5b99e122ac">Error::StsError</a>, error_message);</div><div class="line">    }</div><div class="line">    <span class="comment">// Get the height from the first image. We&#39;ll need this</span></div><div class="line">    <span class="comment">// later in code to reshape the images to their original</span></div><div class="line">    <span class="comment">// size:</span></div><div class="line">    <span class="keywordtype">int</span> height = images[0].rows;</div><div class="line">    <span class="comment">// The following lines simply get the last images from</span></div><div class="line">    <span class="comment">// your dataset and remove it from the vector. This is</span></div><div class="line">    <span class="comment">// done, so that the training data (which we learn the</span></div><div class="line">    <span class="comment">// cv::BasicFaceRecognizer on) and the test data we test</span></div><div class="line">    <span class="comment">// the model with, do not overlap.</span></div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> testSample = images[images.size() - 1];</div><div class="line">    <span class="keywordtype">int</span> testLabel = labels[labels.size() - 1];</div><div class="line">    images.pop_back();</div><div class="line">    labels.pop_back();</div><div class="line">    <span class="comment">// The following lines create an Eigenfaces model for</span></div><div class="line">    <span class="comment">// face recognition and train it with the images and</span></div><div class="line">    <span class="comment">// labels read from the given CSV file.</span></div><div class="line">    <span class="comment">// This here is a full PCA, if you just want to keep</span></div><div class="line">    <span class="comment">// 10 principal components (read Eigenfaces), then call</span></div><div class="line">    <span class="comment">// the factory method like this:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      EigenFaceRecognizer::create(10);</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// If you want to create a FaceRecognizer with a</span></div><div class="line">    <span class="comment">// confidence threshold (e.g. 123.0), call it with:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      EigenFaceRecognizer::create(10, 123.0);</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// If you want to use _all_ Eigenfaces and have a threshold,</span></div><div class="line">    <span class="comment">// then call the method like this:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      EigenFaceRecognizer::create(0, 123.0);</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <a class="code" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr&lt;EigenFaceRecognizer&gt;</a> model = <a class="code" href="../../dd/d7c/classcv_1_1face_1_1EigenFaceRecognizer.html#a5ccb5a03dd0d8fb828f17670d9d28f68">EigenFaceRecognizer::create</a>();</div><div class="line">    model-&gt;train(images, labels);</div><div class="line">    <span class="comment">// The following line predicts the label of a given</span></div><div class="line">    <span class="comment">// test image:</span></div><div class="line">    <span class="keywordtype">int</span> predictedLabel = model-&gt;predict(testSample);</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// To get the confidence of a prediction call the model with:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      int predictedLabel = -1;</span></div><div class="line">    <span class="comment">//      double confidence = 0.0;</span></div><div class="line">    <span class="comment">//      model-&gt;predict(testSample, predictedLabel, confidence);</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keywordtype">string</span> result_message = format(<span class="stringliteral">&quot;Predicted class = %d / Actual class = %d.&quot;</span>, predictedLabel, testLabel);</div><div class="line">    cout &lt;&lt; result_message &lt;&lt; endl;</div><div class="line">    <span class="comment">// Here is how to get the eigenvalues of this Eigenfaces model:</span></div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> eigenvalues = model-&gt;getEigenValues();</div><div class="line">    <span class="comment">// And we can do the same to display the Eigenvectors (read Eigenfaces):</span></div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> W = model-&gt;getEigenVectors();</div><div class="line">    <span class="comment">// Get the sample mean from the training data</span></div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> mean = model-&gt;getMean();</div><div class="line">    <span class="comment">// Display or save:</span></div><div class="line">    <span class="keywordflow">if</span>(argc == 2) {</div><div class="line">        <a class="code" href="../../d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">imshow</a>(<span class="stringliteral">&quot;mean&quot;</span>, norm_0_255(mean.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a4eb96e3251417fa88b78e2abd6cfd7d8">reshape</a>(1, images[0].rows)));</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <a class="code" href="../../d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce">imwrite</a>(format(<span class="stringliteral">&quot;%s/mean.png&quot;</span>, output_folder.c_str()), norm_0_255(mean.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a4eb96e3251417fa88b78e2abd6cfd7d8">reshape</a>(1, images[0].rows)));</div><div class="line">    }</div><div class="line">    <span class="comment">// Display or save the Eigenfaces:</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="../../d7/dcc/group__core__utils__softfloat.html#gac48df53b8fd34b87e7b121fa8fd4c379">min</a>(10, W.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a>); i++) {</div><div class="line">        <span class="keywordtype">string</span> msg = format(<span class="stringliteral">&quot;Eigenvalue #%d = %.5f&quot;</span>, i, eigenvalues.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#aa5d20fc86d41d59e4d71ae93daee9726">at</a>&lt;<span class="keywordtype">double</span>&gt;(i));</div><div class="line">        cout &lt;&lt; msg &lt;&lt; endl;</div><div class="line">        <span class="comment">// get eigenvector #i</span></div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> ev = W.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a23df02a07ffbfa4aa59c19bc003919fe">col</a>(i).<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a03d2a2570d06dcae378f788725789aa4">clone</a>();</div><div class="line">        <span class="comment">// Reshape to original size &amp; normalize to [0...255] for imshow.</span></div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> grayscale = norm_0_255(ev.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a4eb96e3251417fa88b78e2abd6cfd7d8">reshape</a>(1, height));</div><div class="line">        <span class="comment">// Show the image &amp; apply a Jet colormap for better sensing.</span></div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> cgrayscale;</div><div class="line">        <a class="code" href="../../d3/d50/group__imgproc__colormap.html#gadf478a5e5ff49d8aa24e726ea6f65d15">applyColorMap</a>(grayscale, cgrayscale, <a class="code" href="../../d3/d50/group__imgproc__colormap.html#gga9a805d8262bcbe273f16be9ea2055a65ab3f207661ddf74511b002b1acda5ec09">COLORMAP_JET</a>);</div><div class="line">        <span class="comment">// Display or save:</span></div><div class="line">        <span class="keywordflow">if</span>(argc == 2) {</div><div class="line">            <a class="code" href="../../d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">imshow</a>(format(<span class="stringliteral">&quot;eigenface_%d&quot;</span>, i), cgrayscale);</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            <a class="code" href="../../d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce">imwrite</a>(format(<span class="stringliteral">&quot;%s/eigenface_%d.png&quot;</span>, output_folder.c_str(), i), norm_0_255(cgrayscale));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Display or save the image reconstruction at some predefined steps:</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> num_components = <a class="code" href="../../d7/dcc/group__core__utils__softfloat.html#gac48df53b8fd34b87e7b121fa8fd4c379">min</a>(W.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a>, 10); num_components &lt; <a class="code" href="../../d7/dcc/group__core__utils__softfloat.html#gac48df53b8fd34b87e7b121fa8fd4c379">min</a>(W.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a>, 300); num_components+=15) {</div><div class="line">        <span class="comment">// slice the eigenvectors from the model</span></div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> evs = <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a>(W, <a class="code" href="../../da/d35/classcv_1_1Range.html#af5a0207f6f98a69077db8e77898abc0f">Range::all</a>(), <a class="code" href="../../da/d35/classcv_1_1Range.html">Range</a>(0, num_components));</div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> projection = <a class="code" href="../../db/d59/classcv_1_1LDA.html#a69c7019a344edc5c55799c16a9fc9ada">LDA::subspaceProject</a>(evs, mean, images[0].reshape(1,1));</div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> reconstruction = <a class="code" href="../../db/d59/classcv_1_1LDA.html#acbf9949e7567e23af5f71c29fcef76d4">LDA::subspaceReconstruct</a>(evs, mean, projection);</div><div class="line">        <span class="comment">// Normalize the result:</span></div><div class="line">        reconstruction = norm_0_255(reconstruction.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a4eb96e3251417fa88b78e2abd6cfd7d8">reshape</a>(1, images[0].rows));</div><div class="line">        <span class="comment">// Display or save:</span></div><div class="line">        <span class="keywordflow">if</span>(argc == 2) {</div><div class="line">            <a class="code" href="../../d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">imshow</a>(format(<span class="stringliteral">&quot;eigenface_reconstruction_%d&quot;</span>, num_components), reconstruction);</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            <a class="code" href="../../d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce">imwrite</a>(format(<span class="stringliteral">&quot;%s/eigenface_reconstruction_%d.png&quot;</span>, output_folder.c_str(), num_components), reconstruction);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// Display if we are not writing to an output folder:</span></div><div class="line">    <span class="keywordflow">if</span>(argc == 2) {</div><div class="line">        <a class="code" href="../../d7/dfc/group__highgui.html#ga5628525ad33f52eab17feebcfba38bd7">waitKey</a>(0);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>I've used the jet colormap, so you can see how the grayscale values are distributed within the specific Eigenfaces. You can see, that the Eigenfaces do not only encode facial features, but also the illumination in the images (see the left light in Eigenface #4, right light in Eigenfaces #5):</p>
<div class="image">
<img src="../../eigenfaces_opencv.png" alt="eigenfaces_opencv.png"/>
<div class="caption">
image</div></div>
<p> We've already seen, that we can reconstruct a face from its lower dimensional approximation. So let's see how many Eigenfaces are needed for a good reconstruction. I'll do a subplot with \(10,30,\ldots,310\) Eigenfaces:</p>
<div class="fragment"><div class="line"><span class="comment">// Display or save the image reconstruction at some predefined steps:</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> num_components = 10; num_components &lt; 300; num_components+=15) {</div><div class="line">    <span class="comment">// slice the eigenvectors from the model</span></div><div class="line">    Mat evs = Mat(W, Range::all(), Range(0, num_components));</div><div class="line">    Mat projection = LDA::subspaceProject(evs, mean, images[0].reshape(1,1));</div><div class="line">    Mat reconstruction = LDA::subspaceReconstruct(evs, mean, projection);</div><div class="line">    <span class="comment">// Normalize the result:</span></div><div class="line">    reconstruction = norm_0_255(reconstruction.reshape(1, images[0].rows));</div><div class="line">    <span class="comment">// Display or save:</span></div><div class="line">    <span class="keywordflow">if</span>(argc == 2) {</div><div class="line">        <a class="code" href="../../d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">imshow</a>(format(<span class="stringliteral">&quot;eigenface_reconstruction_%d&quot;</span>, num_components), reconstruction);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <a class="code" href="../../d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce">imwrite</a>(format(<span class="stringliteral">&quot;%s/eigenface_reconstruction_%d.png&quot;</span>, output_folder.c_str(), num_components), reconstruction);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>10 Eigenvectors are obviously not sufficient for a good image reconstruction, 50 Eigenvectors may already be sufficient to encode important facial features. You'll get a good reconstruction with approximately 300 Eigenvectors for the AT&amp;T Facedatabase. There are rule of thumbs how many Eigenfaces you should choose for a successful face recognition, but it heavily depends on the input data. <a class="el" href="../../d0/de3/citelist.html#CITEREF_Zhao03">[298]</a> is the perfect point to start researching for this:</p>
<div class="image">
<img src="../../eigenface_reconstruction_opencv.png" alt="eigenface_reconstruction_opencv.png"/>
<div class="caption">
image</div></div>
 <h2><a class="anchor" id="tutorial_face_fisherfaces"></a>
Fisherfaces  </h2>
<p>The Principal Component Analysis (PCA), which is the core of the Eigenfaces method, finds a linear combination of features that maximizes the total variance in data. While this is clearly a powerful way to represent data, it doesn't consider any classes and so a lot of discriminative information <em>may</em> be lost when throwing components away. Imagine a situation where the variance in your data is generated by an external source, let it be the light. The components identified by a PCA do not necessarily contain any discriminative information at all, so the projected samples are smeared together and a classification becomes impossible (see <a href="http://www.bytefish.de/wiki/pca_lda_with_gnu_octave">http://www.bytefish.de/wiki/pca_lda_with_gnu_octave</a> for an example).</p>
<p>The Linear Discriminant Analysis performs a class-specific dimensionality reduction and was invented by the great statistician <a href="http://en.wikipedia.org/wiki/Ronald_Fisher">Sir R. A. Fisher</a>. He successfully used it for classifying flowers in his 1936 paper <em>The use of multiple measurements in taxonomic problems</em> <a class="el" href="../../d0/de3/citelist.html#CITEREF_Fisher36">[79]</a> . In order to find the combination of features that separates best between classes the Linear Discriminant Analysis maximizes the ratio of between-classes to within-classes scatter, instead of maximizing the overall scatter. The idea is simple: same classes should cluster tightly together, while different classes are as far away as possible from each other in the lower-dimensional representation. This was also recognized by <a href="http://www.cs.columbia.edu/~belhumeur/">Belhumeur</a>, <a href="http://www.ece.ucsb.edu/~hespanha/">Hespanha</a> and <a href="http://cseweb.ucsd.edu/~kriegman/">Kriegman</a> and so they applied a Discriminant Analysis to face recognition in <a class="el" href="../../d0/de3/citelist.html#CITEREF_BHK97">[19]</a> .</p>
<h3><a class="anchor" id="tutorial_face_fisherfaces_algo"></a>
Algorithmic Description of Fisherfaces method</h3>
<p>Let \(X\) be a random vector with samples drawn from \(c\) classes:</p>
<p class="formulaDsp">
\[\begin{align*} X &amp; = &amp; \{X_1,X_2,\ldots,X_c\} \\ X_i &amp; = &amp; \{x_1, x_2, \ldots, x_n\} \end{align*}\]
</p>
<p>The scatter matrices \(S_{B}\) and S_{W} are calculated as:</p>
<p class="formulaDsp">
\[\begin{align*} S_{B} &amp; = &amp; \sum_{i=1}^{c} N_{i} (\mu_i - \mu)(\mu_i - \mu)^{T} \\ S_{W} &amp; = &amp; \sum_{i=1}^{c} \sum_{x_{j} \in X_{i}} (x_j - \mu_i)(x_j - \mu_i)^{T} \end{align*}\]
</p>
<p>, where \(\mu\) is the total mean:</p>
<p class="formulaDsp">
\[\mu = \frac{1}{N} \sum_{i=1}^{N} x_i\]
</p>
<p>And \(\mu_i\) is the mean of class \(i \in \{1,\ldots,c\}\):</p>
<p class="formulaDsp">
\[\mu_i = \frac{1}{|X_i|} \sum_{x_j \in X_i} x_j\]
</p>
<p>Fisher's classic algorithm now looks for a projection \(W\), that maximizes the class separability criterion:</p>
<p class="formulaDsp">
\[W_{opt} = \operatorname{arg\,max}_{W} \frac{|W^T S_B W|}{|W^T S_W W|}\]
</p>
<p>Following <a class="el" href="../../d0/de3/citelist.html#CITEREF_BHK97">[19]</a>, a solution for this optimization problem is given by solving the General Eigenvalue Problem:</p>
<p class="formulaDsp">
\[\begin{align*} S_{B} v_{i} &amp; = &amp; \lambda_{i} S_w v_{i} \nonumber \\ S_{W}^{-1} S_{B} v_{i} &amp; = &amp; \lambda_{i} v_{i} \end{align*}\]
</p>
<p>There's one problem left to solve: The rank of \(S_{W}\) is at most \((N-c)\), with \(N\) samples and \(c\) classes. In pattern recognition problems the number of samples \(N\) is almost always samller than the dimension of the input data (the number of pixels), so the scatter matrix \(S_{W}\) becomes singular (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_RJ91">[204]</a>). In <a class="el" href="../../d0/de3/citelist.html#CITEREF_BHK97">[19]</a> this was solved by performing a Principal Component Analysis on the data and projecting the samples into the \((N-c)\)-dimensional space. A Linear Discriminant Analysis was then performed on the reduced data, because \(S_{W}\) isn't singular anymore.</p>
<p>The optimization problem can then be rewritten as:</p>
<p class="formulaDsp">
\[\begin{align*} W_{pca} &amp; = &amp; \operatorname{arg\,max}_{W} |W^T S_T W| \\ W_{fld} &amp; = &amp; \operatorname{arg\,max}_{W} \frac{|W^T W_{pca}^T S_{B} W_{pca} W|}{|W^T W_{pca}^T S_{W} W_{pca} W|} \end{align*}\]
</p>
<p>The transformation matrix \(W\), that projects a sample into the \((c-1)\)-dimensional space is then given by:</p>
<p class="formulaDsp">
\[W = W_{fld}^{T} W_{pca}^{T}\]
</p>
<h3><a class="anchor" id="tutorial_face_fisherfaces_use"></a>
Fisherfaces in OpenCV</h3>
<p>The source code for this demo application is also available in the src folder coming with this documentation:</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Copyright (c) 2011. Philipp Wagner &lt;bytefish[at]gmx[dot]de&gt;.</span></div><div class="line"><span class="comment"> * Released to public domain under terms of the BSD Simplified license.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment"> * modification, are permitted provided that the following conditions are met:</span></div><div class="line"><span class="comment"> *   * Redistributions of source code must retain the above copyright</span></div><div class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"> *   * Redistributions in binary form must reproduce the above copyright</span></div><div class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer in the</span></div><div class="line"><span class="comment"> *     documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"> *   * Neither the name of the organization nor the names of its contributors</span></div><div class="line"><span class="comment"> *     may be used to endorse or promote products derived from this software</span></div><div class="line"><span class="comment"> *     without specific prior written permission.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *   See &lt;http://www.opensource.org/licenses/bsd-license&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d0/d9c/core_2include_2opencv2_2core_8hpp.html">opencv2/core.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d2/dc4/contrib_2modules_2face_2include_2opencv2_2face_8hpp.html">opencv2/face.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d4/dd5/highgui_8hpp.html">opencv2/highgui.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d1/d4f/imgproc_2include_2opencv2_2imgproc_8hpp.html">opencv2/imgproc.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d2/d75/namespacecv.html">cv</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d4/d48/namespacecv_1_1face.html">cv::face</a>;</div><div class="line"><span class="keyword">using namespace </span>std;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> norm_0_255(<a class="code" href="../../d4/d32/classcv_1_1__InputArray.html">InputArray</a> _src) {</div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> src = _src.<a class="code" href="../../d4/d32/classcv_1_1__InputArray.html#a9c09739ca3e0ce212e2ab8374aa2f195">getMat</a>();</div><div class="line">    <span class="comment">// Create and return normalized image:</span></div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> dst;</div><div class="line">    <span class="keywordflow">switch</span>(src.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#aa11336b9ac538e0475d840657ce164be">channels</a>()) {</div><div class="line">    <span class="keywordflow">case</span> 1:</div><div class="line">        <a class="code" href="../../dc/d84/group__core__basic.html#ga1b6a396a456c8b6c6e4afd8591560d80">cv::normalize</a>(_src, dst, 0, 255, <a class="code" href="../../d2/de8/group__core__array.html#ggad12cefbcb5291cf958a85b4b67b6149fa9f0c1c342a18114d47b516a88e29822e">NORM_MINMAX</a>, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">case</span> 3:</div><div class="line">        <a class="code" href="../../dc/d84/group__core__basic.html#ga1b6a396a456c8b6c6e4afd8591560d80">cv::normalize</a>(_src, dst, 0, 255, <a class="code" href="../../d2/de8/group__core__array.html#ggad12cefbcb5291cf958a85b4b67b6149fa9f0c1c342a18114d47b516a88e29822e">NORM_MINMAX</a>, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a>);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    <span class="keywordflow">default</span>:</div><div class="line">        src.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a33fd5d125b4c302b0c9aa86980791a77">copyTo</a>(dst);</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> dst;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> read_csv(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; filename, vector&lt;Mat&gt;&amp; images, vector&lt;int&gt;&amp; labels, <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;;&#39;</span>) {</div><div class="line">    std::ifstream file(filename.c_str(), ifstream::in);</div><div class="line">    <span class="keywordflow">if</span> (!file) {</div><div class="line">        <span class="keywordtype">string</span> error_message = <span class="stringliteral">&quot;No valid input file was given, please check the given filename.&quot;</span>;</div><div class="line">        <a class="code" href="../../db/de0/group__core__utils.html#ga5b48c333c777666e076bd7052799f891">CV_Error</a>(<a class="code" href="../../d1/d0d/namespacecv_1_1Error.html#a759fa1af92f7aa7377c76ffb142abccaaf587497af64537041ee62c04a92b755d">Error::StsBadArg</a>, error_message);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">string</span> <a class="code" href="../../d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2">line</a>, path, classlabel;</div><div class="line">    <span class="keywordflow">while</span> (getline(file, line)) {</div><div class="line">        stringstream liness(line);</div><div class="line">        getline(liness, path, separator);</div><div class="line">        getline(liness, classlabel);</div><div class="line">        <span class="keywordflow">if</span>(!path.empty() &amp;&amp; !classlabel.empty()) {</div><div class="line">            images.push_back(<a class="code" href="../../d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56">imread</a>(path, 0));</div><div class="line">            labels.push_back(atoi(classlabel.c_str()));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[]) {</div><div class="line">    <span class="comment">// Check for valid command line arguments, print usage</span></div><div class="line">    <span class="comment">// if no arguments were given.</span></div><div class="line">    <span class="keywordflow">if</span> (argc &lt; 2) {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;csv.ext&gt; &lt;output_folder&gt; &quot;</span> &lt;&lt; endl;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">string</span> output_folder = <span class="stringliteral">&quot;.&quot;</span>;</div><div class="line">    <span class="keywordflow">if</span> (argc == 3) {</div><div class="line">        output_folder = string(argv[2]);</div><div class="line">    }</div><div class="line">    <span class="comment">// Get the path to your CSV.</span></div><div class="line">    <span class="keywordtype">string</span> fn_csv = string(argv[1]);</div><div class="line">    <span class="comment">// These vectors hold the images and corresponding labels.</span></div><div class="line">    vector&lt;Mat&gt; images;</div><div class="line">    vector&lt;int&gt; labels;</div><div class="line">    <span class="comment">// Read in the data. This can fail if no valid</span></div><div class="line">    <span class="comment">// input filename is given.</span></div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        read_csv(fn_csv, images, labels);</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="../../d1/dee/classcv_1_1Exception.html">cv::Exception</a>&amp; e) {</div><div class="line">        cerr &lt;&lt; <span class="stringliteral">&quot;Error opening file \&quot;&quot;</span> &lt;&lt; fn_csv &lt;&lt; <span class="stringliteral">&quot;\&quot;. Reason: &quot;</span> &lt;&lt; e.<a class="code" href="../../d1/dee/classcv_1_1Exception.html#a7ead458b4fc88ebca20b231383c49845">msg</a> &lt;&lt; endl;</div><div class="line">        <span class="comment">// nothing more we can do</span></div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line">    <span class="comment">// Quit if there are not enough images for this demo.</span></div><div class="line">    <span class="keywordflow">if</span>(images.size() &lt;= 1) {</div><div class="line">        <span class="keywordtype">string</span> error_message = <span class="stringliteral">&quot;This demo needs at least 2 images to work. Please add more images to your data set!&quot;</span>;</div><div class="line">        <a class="code" href="../../db/de0/group__core__utils.html#ga5b48c333c777666e076bd7052799f891">CV_Error</a>(<a class="code" href="../../d1/d0d/namespacecv_1_1Error.html#a759fa1af92f7aa7377c76ffb142abccaacf93e97abba2e7defa74fe5b99e122ac">Error::StsError</a>, error_message);</div><div class="line">    }</div><div class="line">    <span class="comment">// Get the height from the first image. We&#39;ll need this</span></div><div class="line">    <span class="comment">// later in code to reshape the images to their original</span></div><div class="line">    <span class="comment">// size:</span></div><div class="line">    <span class="keywordtype">int</span> height = images[0].rows;</div><div class="line">    <span class="comment">// The following lines simply get the last images from</span></div><div class="line">    <span class="comment">// your dataset and remove it from the vector. This is</span></div><div class="line">    <span class="comment">// done, so that the training data (which we learn the</span></div><div class="line">    <span class="comment">// cv::BasicFaceRecognizer on) and the test data we test</span></div><div class="line">    <span class="comment">// the model with, do not overlap.</span></div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> testSample = images[images.size() - 1];</div><div class="line">    <span class="keywordtype">int</span> testLabel = labels[labels.size() - 1];</div><div class="line">    images.pop_back();</div><div class="line">    labels.pop_back();</div><div class="line">    <span class="comment">// The following lines create an Fisherfaces model for</span></div><div class="line">    <span class="comment">// face recognition and train it with the images and</span></div><div class="line">    <span class="comment">// labels read from the given CSV file.</span></div><div class="line">    <span class="comment">// If you just want to keep 10 Fisherfaces, then call</span></div><div class="line">    <span class="comment">// the factory method like this:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      FisherFaceRecognizer::create(10);</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// However it is not useful to discard Fisherfaces! Please</span></div><div class="line">    <span class="comment">// always try to use _all_ available Fisherfaces for</span></div><div class="line">    <span class="comment">// classification.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// If you want to create a FaceRecognizer with a</span></div><div class="line">    <span class="comment">// confidence threshold (e.g. 123.0) and use _all_</span></div><div class="line">    <span class="comment">// Fisherfaces, then call it with:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      FisherFaceRecognizer::create(0, 123.0);</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <a class="code" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr&lt;FisherFaceRecognizer&gt;</a> model = <a class="code" href="../../d2/de9/classcv_1_1face_1_1FisherFaceRecognizer.html#a0072e4c3f410250baf4b083296a41dfc">FisherFaceRecognizer::create</a>();</div><div class="line">    model-&gt;train(images, labels);</div><div class="line">    <span class="comment">// The following line predicts the label of a given</span></div><div class="line">    <span class="comment">// test image:</span></div><div class="line">    <span class="keywordtype">int</span> predictedLabel = model-&gt;predict(testSample);</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// To get the confidence of a prediction call the model with:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      int predictedLabel = -1;</span></div><div class="line">    <span class="comment">//      double confidence = 0.0;</span></div><div class="line">    <span class="comment">//      model-&gt;predict(testSample, predictedLabel, confidence);</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keywordtype">string</span> result_message = format(<span class="stringliteral">&quot;Predicted class = %d / Actual class = %d.&quot;</span>, predictedLabel, testLabel);</div><div class="line">    cout &lt;&lt; result_message &lt;&lt; endl;</div><div class="line">    <span class="comment">// Here is how to get the eigenvalues of this Eigenfaces model:</span></div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> eigenvalues = model-&gt;getEigenValues();</div><div class="line">    <span class="comment">// And we can do the same to display the Eigenvectors (read Eigenfaces):</span></div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> W = model-&gt;getEigenVectors();</div><div class="line">    <span class="comment">// Get the sample mean from the training data</span></div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> mean = model-&gt;getMean();</div><div class="line">    <span class="comment">// Display or save:</span></div><div class="line">    <span class="keywordflow">if</span>(argc == 2) {</div><div class="line">        <a class="code" href="../../d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">imshow</a>(<span class="stringliteral">&quot;mean&quot;</span>, norm_0_255(mean.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a4eb96e3251417fa88b78e2abd6cfd7d8">reshape</a>(1, images[0].rows)));</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <a class="code" href="../../d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce">imwrite</a>(format(<span class="stringliteral">&quot;%s/mean.png&quot;</span>, output_folder.c_str()), norm_0_255(mean.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a4eb96e3251417fa88b78e2abd6cfd7d8">reshape</a>(1, images[0].rows)));</div><div class="line">    }</div><div class="line">    <span class="comment">// Display or save the first, at most 16 Fisherfaces:</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="../../d7/dcc/group__core__utils__softfloat.html#gac48df53b8fd34b87e7b121fa8fd4c379">min</a>(16, W.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a>); i++) {</div><div class="line">        <span class="keywordtype">string</span> msg = format(<span class="stringliteral">&quot;Eigenvalue #%d = %.5f&quot;</span>, i, eigenvalues.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#aa5d20fc86d41d59e4d71ae93daee9726">at</a>&lt;<span class="keywordtype">double</span>&gt;(i));</div><div class="line">        cout &lt;&lt; msg &lt;&lt; endl;</div><div class="line">        <span class="comment">// get eigenvector #i</span></div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> ev = W.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a23df02a07ffbfa4aa59c19bc003919fe">col</a>(i).<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a03d2a2570d06dcae378f788725789aa4">clone</a>();</div><div class="line">        <span class="comment">// Reshape to original size &amp; normalize to [0...255] for imshow.</span></div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> grayscale = norm_0_255(ev.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a4eb96e3251417fa88b78e2abd6cfd7d8">reshape</a>(1, height));</div><div class="line">        <span class="comment">// Show the image &amp; apply a Bone colormap for better sensing.</span></div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> cgrayscale;</div><div class="line">        <a class="code" href="../../d3/d50/group__imgproc__colormap.html#gadf478a5e5ff49d8aa24e726ea6f65d15">applyColorMap</a>(grayscale, cgrayscale, <a class="code" href="../../d3/d50/group__imgproc__colormap.html#gga9a805d8262bcbe273f16be9ea2055a65a91d58e66f015ea030150bdc8545d3b41">COLORMAP_BONE</a>);</div><div class="line">        <span class="comment">// Display or save:</span></div><div class="line">        <span class="keywordflow">if</span>(argc == 2) {</div><div class="line">            <a class="code" href="../../d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">imshow</a>(format(<span class="stringliteral">&quot;fisherface_%d&quot;</span>, i), cgrayscale);</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            <a class="code" href="../../d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce">imwrite</a>(format(<span class="stringliteral">&quot;%s/fisherface_%d.png&quot;</span>, output_folder.c_str(), i), norm_0_255(cgrayscale));</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// Display or save the image reconstruction at some predefined steps:</span></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> num_component = 0; num_component &lt; <a class="code" href="../../d7/dcc/group__core__utils__softfloat.html#gac48df53b8fd34b87e7b121fa8fd4c379">min</a>(16, W.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a>); num_component++) {</div><div class="line">        <span class="comment">// Slice the Fisherface from the model:</span></div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> ev = W.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a23df02a07ffbfa4aa59c19bc003919fe">col</a>(num_component);</div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> projection = <a class="code" href="../../db/d59/classcv_1_1LDA.html#a69c7019a344edc5c55799c16a9fc9ada">LDA::subspaceProject</a>(ev, mean, images[0].reshape(1,1));</div><div class="line">        <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> reconstruction = <a class="code" href="../../db/d59/classcv_1_1LDA.html#acbf9949e7567e23af5f71c29fcef76d4">LDA::subspaceReconstruct</a>(ev, mean, projection);</div><div class="line">        <span class="comment">// Normalize the result:</span></div><div class="line">        reconstruction = norm_0_255(reconstruction.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a4eb96e3251417fa88b78e2abd6cfd7d8">reshape</a>(1, images[0].rows));</div><div class="line">        <span class="comment">// Display or save:</span></div><div class="line">        <span class="keywordflow">if</span>(argc == 2) {</div><div class="line">            <a class="code" href="../../d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">imshow</a>(format(<span class="stringliteral">&quot;fisherface_reconstruction_%d&quot;</span>, num_component), reconstruction);</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            <a class="code" href="../../d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce">imwrite</a>(format(<span class="stringliteral">&quot;%s/fisherface_reconstruction_%d.png&quot;</span>, output_folder.c_str(), num_component), reconstruction);</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// Display if we are not writing to an output folder:</span></div><div class="line">    <span class="keywordflow">if</span>(argc == 2) {</div><div class="line">        <a class="code" href="../../d7/dfc/group__highgui.html#ga5628525ad33f52eab17feebcfba38bd7">waitKey</a>(0);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>For this example I am going to use the Yale Facedatabase A, just because the plots are nicer. Each Fisherface has the same length as an original image, thus it can be displayed as an image. The demo shows (or saves) the first, at most 16 Fisherfaces:</p>
<div class="image">
<img src="../../fisherfaces_opencv.png" alt="fisherfaces_opencv.png"/>
<div class="caption">
image</div></div>
<p> The Fisherfaces method learns a class-specific transformation matrix, so the they do not capture illumination as obviously as the Eigenfaces method. The Discriminant Analysis instead finds the facial features to discriminate between the persons. It's important to mention, that the performance of the Fisherfaces heavily depends on the input data as well. Practically said: if you learn the Fisherfaces for well-illuminated pictures only and you try to recognize faces in bad-illuminated scenes, then method is likely to find the wrong components (just because those features may not be predominant on bad illuminated images). This is somewhat logical, since the method had no chance to learn the illumination.</p>
<p>The Fisherfaces allow a reconstruction of the projected image, just like the Eigenfaces did. But since we only identified the features to distinguish between subjects, you can't expect a nice reconstruction of the original image. For the Fisherfaces method we'll project the sample image onto each of the Fisherfaces instead. So you'll have a nice visualization, which feature each of the Fisherfaces describes:</p>
<div class="fragment"><div class="line"><span class="comment">// Display or save the image reconstruction at some predefined steps:</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> num_component = 0; num_component &lt; <a class="code" href="../../d1/d10/classcv_1_1MatExpr.html#ac22d7d32f1ec91fd106760a98a6f4731">min</a>(16, W.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a>); num_component++) {</div><div class="line">    <span class="comment">// Slice the Fisherface from the model:</span></div><div class="line">    Mat ev = W.<a class="code" href="../../d3/d63/classcv_1_1Mat.html#a23df02a07ffbfa4aa59c19bc003919fe">col</a>(num_component);</div><div class="line">    Mat projection = LDA::subspaceProject(ev, mean, images[0].reshape(1,1));</div><div class="line">    Mat reconstruction = LDA::subspaceReconstruct(ev, mean, projection);</div><div class="line">    <span class="comment">// Normalize the result:</span></div><div class="line">    reconstruction = norm_0_255(reconstruction.reshape(1, images[0].rows));</div><div class="line">    <span class="comment">// Display or save:</span></div><div class="line">    <span class="keywordflow">if</span>(argc == 2) {</div><div class="line">        <a class="code" href="../../d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">imshow</a>(format(<span class="stringliteral">&quot;fisherface_reconstruction_%d&quot;</span>, num_component), reconstruction);</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <a class="code" href="../../d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce">imwrite</a>(format(<span class="stringliteral">&quot;%s/fisherface_reconstruction_%d.png&quot;</span>, output_folder.c_str(), num_component), reconstruction);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The differences may be subtle for the human eyes, but you should be able to see some differences:</p>
<div class="image">
<img src="../../fisherface_reconstruction_opencv.png" alt="fisherface_reconstruction_opencv.png"/>
<div class="caption">
image</div></div>
 <h2><a class="anchor" id="tutorial_face_lbph"></a>
Local Binary Patterns Histograms </h2>
<p>Eigenfaces and Fisherfaces take a somewhat holistic approach to face recognition. You treat your data as a vector somewhere in a high-dimensional image space. We all know high-dimensionality is bad, so a lower-dimensional subspace is identified, where (probably) useful information is preserved. The Eigenfaces approach maximizes the total scatter, which can lead to problems if the variance is generated by an external source, because components with a maximum variance over all classes aren't necessarily useful for classification (see <a href="http://www.bytefish.de/wiki/pca_lda_with_gnu_octave">http://www.bytefish.de/wiki/pca_lda_with_gnu_octave</a>). So to preserve some discriminative information we applied a Linear Discriminant Analysis and optimized as described in the Fisherfaces method. The Fisherfaces method worked great... at least for the constrained scenario we've assumed in our model.</p>
<p>Now real life isn't perfect. You simply can't guarantee perfect light settings in your images or 10 different images of a person. So what if there's only one image for each person? Our covariance estimates for the subspace <em>may</em> be horribly wrong, so will the recognition. Remember the Eigenfaces method had a 96% recognition rate on the AT&amp;T Facedatabase? How many images do we actually need to get such useful estimates? Here are the Rank-1 recognition rates of the Eigenfaces and Fisherfaces method on the AT&amp;T Facedatabase, which is a fairly easy image database:</p>
<div class="image">
<img src="../../at_database_small_sample_size.png" alt="at_database_small_sample_size.png"/>
<div class="caption">
image</div></div>
<p> So in order to get good recognition rates you'll need at least 8(+-1) images for each person and the Fisherfaces method doesn't really help here. The above experiment is a 10-fold cross validated result carried out with the facerec framework at: <a href="https://github.com/bytefish/facerec">https://github.com/bytefish/facerec</a>. This is not a publication, so I won't back these figures with a deep mathematical analysis. Please have a look into <a class="el" href="../../d0/de3/citelist.html#CITEREF_KM01">[167]</a> for a detailed analysis of both methods, when it comes to small training datasets.</p>
<p>So some research concentrated on extracting local features from images. The idea is to not look at the whole image as a high-dimensional vector, but describe only local features of an object. The features you extract this way will have a low-dimensionality implicitly. A fine idea! But you'll soon observe the image representation we are given doesn't only suffer from illumination variations. Think of things like scale, translation or rotation in images - your local description has to be at least a bit robust against those things. Just like SIFT, the Local Binary Patterns methodology has its roots in 2D texture analysis. The basic idea of Local Binary Patterns is to summarize the local structure in an image by comparing each pixel with its neighborhood. Take a pixel as center and threshold its neighbors against. If the intensity of the center pixel is greater-equal its neighbor, then denote it with 1 and 0 if not. You'll end up with a binary number for each pixel, just like</p><ol type="1">
<li>So with 8 surrounding pixels you'll end up with 2\^8 possible combinations, called <em>Local Binary Patterns</em> or sometimes referred to as <em>LBP codes</em>. The first LBP operator described in literature actually used a fixed 3 x 3 neighborhood just like this:</li>
</ol>
<div class="image">
<img src="../../lbp.png" alt="lbp.png"/>
<div class="caption">
image</div></div>
 <h3><a class="anchor" id="tutorial_face_lbph_algo"></a>
Algorithmic Description of LBPH method</h3>
<p>A more formal description of the LBP operator can be given as:</p>
<p class="formulaDsp">
\[LBP(x_c, y_c) = \sum_{p=0}^{P-1} 2^p s(i_p - i_c)\]
</p>
<p>, with \((x_c, y_c)\) as central pixel with intensity \(i_c\); and \(i_n\) being the intensity of the the neighbor pixel. \(s\) is the sign function defined as:</p>
<p class="formulaDsp">
\[\begin{equation} s(x) = \begin{cases} 1 &amp; \text{if \(x \geq 0\)}\\ 0 &amp; \text{else} \end{cases} \end{equation}\]
</p>
<p>This description enables you to capture very fine grained details in images. In fact the authors were able to compete with state of the art results for texture classification. Soon after the operator was published it was noted, that a fixed neighborhood fails to encode details differing in scale. So the operator was extended to use a variable neighborhood in <a class="el" href="../../d0/de3/citelist.html#CITEREF_AHP04">[3]</a> . The idea is to align an abritrary number of neighbors on a circle with a variable radius, which enables to capture the following neighborhoods:</p>
<div class="image">
<img src="../../patterns.png" alt="patterns.png"/>
<div class="caption">
image</div></div>
<p> For a given Point \((x_c,y_c)\) the position of the neighbor \((x_p,y_p), p \in P\) can be calculated by:</p>
<p class="formulaDsp">
\[\begin{align*} x_{p} &amp; = &amp; x_c + R \cos({\frac{2\pi p}{P}})\\ y_{p} &amp; = &amp; y_c - R \sin({\frac{2\pi p}{P}}) \end{align*}\]
</p>
<p>Where \(R\) is the radius of the circle and \(P\) is the number of sample points.</p>
<p>The operator is an extension to the original LBP codes, so it's sometimes called <em>Extended LBP</em> (also referred to as <em>Circular LBP</em>) . If a points coordinate on the circle doesn't correspond to image coordinates, the point get's interpolated. Computer science has a bunch of clever interpolation schemes, the OpenCV implementation does a bilinear interpolation:</p>
<p class="formulaDsp">
\[\begin{align*} f(x,y) \approx \begin{bmatrix} 1-x &amp; x \end{bmatrix} \begin{bmatrix} f(0,0) &amp; f(0,1) \\ f(1,0) &amp; f(1,1) \end{bmatrix} \begin{bmatrix} 1-y \\ y \end{bmatrix}. \end{align*}\]
</p>
<p>By definition the LBP operator is robust against monotonic gray scale transformations. We can easily verify this by looking at the LBP image of an artificially modified image (so you see what an LBP image looks like!):</p>
<div class="image">
<img src="../../lbp_yale.jpg" alt="lbp_yale.jpg"/>
<div class="caption">
image</div></div>
<p> So what's left to do is how to incorporate the spatial information in the face recognition model. The representation proposed by Ahonen et. al <a class="el" href="../../d0/de3/citelist.html#CITEREF_AHP04">[3]</a> is to divide the LBP image into \(m\) local regions and extract a histogram from each. The spatially enhanced feature vector is then obtained by concatenating the local histograms (<b>not merging them</b>). These histograms are called <em>Local Binary Patterns Histograms</em>.</p>
<h3><a class="anchor" id="tutorial_face_lbph_use"></a>
Local Binary Patterns Histograms in OpenCV</h3>
<p>The source code for this demo application is also available in the src folder coming with this documentation:</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Copyright (c) 2011. Philipp Wagner &lt;bytefish[at]gmx[dot]de&gt;.</span></div><div class="line"><span class="comment"> * Released to public domain under terms of the BSD Simplified license.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment"> * modification, are permitted provided that the following conditions are met:</span></div><div class="line"><span class="comment"> *   * Redistributions of source code must retain the above copyright</span></div><div class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"> *   * Redistributions in binary form must reproduce the above copyright</span></div><div class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer in the</span></div><div class="line"><span class="comment"> *     documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"> *   * Neither the name of the organization nor the names of its contributors</span></div><div class="line"><span class="comment"> *     may be used to endorse or promote products derived from this software</span></div><div class="line"><span class="comment"> *     without specific prior written permission.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> *   See &lt;http://www.opensource.org/licenses/bsd-license&gt;</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d0/d9c/core_2include_2opencv2_2core_8hpp.html">opencv2/core.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d2/dc4/contrib_2modules_2face_2include_2opencv2_2face_8hpp.html">opencv2/face.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d4/dd5/highgui_8hpp.html">opencv2/highgui.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d2/d75/namespacecv.html">cv</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d4/d48/namespacecv_1_1face.html">cv::face</a>;</div><div class="line"><span class="keyword">using namespace </span>std;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> read_csv(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; filename, vector&lt;Mat&gt;&amp; images, vector&lt;int&gt;&amp; labels, <span class="keywordtype">char</span> separator = <span class="charliteral">&#39;;&#39;</span>) {</div><div class="line">    std::ifstream file(filename.c_str(), ifstream::in);</div><div class="line">    <span class="keywordflow">if</span> (!file) {</div><div class="line">        <span class="keywordtype">string</span> error_message = <span class="stringliteral">&quot;No valid input file was given, please check the given filename.&quot;</span>;</div><div class="line">        <a class="code" href="../../db/de0/group__core__utils.html#ga5b48c333c777666e076bd7052799f891">CV_Error</a>(<a class="code" href="../../d1/d0d/namespacecv_1_1Error.html#a759fa1af92f7aa7377c76ffb142abccaaf587497af64537041ee62c04a92b755d">Error::StsBadArg</a>, error_message);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">string</span> <a class="code" href="../../d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2">line</a>, path, classlabel;</div><div class="line">    <span class="keywordflow">while</span> (getline(file, line)) {</div><div class="line">        stringstream liness(line);</div><div class="line">        getline(liness, path, separator);</div><div class="line">        getline(liness, classlabel);</div><div class="line">        <span class="keywordflow">if</span>(!path.empty() &amp;&amp; !classlabel.empty()) {</div><div class="line">            images.push_back(<a class="code" href="../../d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56">imread</a>(path, 0));</div><div class="line">            labels.push_back(atoi(classlabel.c_str()));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[]) {</div><div class="line">    <span class="comment">// Check for valid command line arguments, print usage</span></div><div class="line">    <span class="comment">// if no arguments were given.</span></div><div class="line">    <span class="keywordflow">if</span> (argc != 2) {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; &lt;csv.ext&gt;&quot;</span> &lt;&lt; endl;</div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line">    <span class="comment">// Get the path to your CSV.</span></div><div class="line">    <span class="keywordtype">string</span> fn_csv = string(argv[1]);</div><div class="line">    <span class="comment">// These vectors hold the images and corresponding labels.</span></div><div class="line">    vector&lt;Mat&gt; images;</div><div class="line">    vector&lt;int&gt; labels;</div><div class="line">    <span class="comment">// Read in the data. This can fail if no valid</span></div><div class="line">    <span class="comment">// input filename is given.</span></div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">        read_csv(fn_csv, images, labels);</div><div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="../../d1/dee/classcv_1_1Exception.html">cv::Exception</a>&amp; e) {</div><div class="line">        cerr &lt;&lt; <span class="stringliteral">&quot;Error opening file \&quot;&quot;</span> &lt;&lt; fn_csv &lt;&lt; <span class="stringliteral">&quot;\&quot;. Reason: &quot;</span> &lt;&lt; e.<a class="code" href="../../d1/dee/classcv_1_1Exception.html#a7ead458b4fc88ebca20b231383c49845">msg</a> &lt;&lt; endl;</div><div class="line">        <span class="comment">// nothing more we can do</span></div><div class="line">        exit(1);</div><div class="line">    }</div><div class="line">    <span class="comment">// Quit if there are not enough images for this demo.</span></div><div class="line">    <span class="keywordflow">if</span>(images.size() &lt;= 1) {</div><div class="line">        <span class="keywordtype">string</span> error_message = <span class="stringliteral">&quot;This demo needs at least 2 images to work. Please add more images to your data set!&quot;</span>;</div><div class="line">        <a class="code" href="../../db/de0/group__core__utils.html#ga5b48c333c777666e076bd7052799f891">CV_Error</a>(<a class="code" href="../../d1/d0d/namespacecv_1_1Error.html#a759fa1af92f7aa7377c76ffb142abccaacf93e97abba2e7defa74fe5b99e122ac">Error::StsError</a>, error_message);</div><div class="line">    }</div><div class="line">    <span class="comment">// The following lines simply get the last images from</span></div><div class="line">    <span class="comment">// your dataset and remove it from the vector. This is</span></div><div class="line">    <span class="comment">// done, so that the training data (which we learn the</span></div><div class="line">    <span class="comment">// cv::LBPHFaceRecognizer on) and the test data we test</span></div><div class="line">    <span class="comment">// the model with, do not overlap.</span></div><div class="line">    <a class="code" href="../../d3/d63/classcv_1_1Mat.html">Mat</a> testSample = images[images.size() - 1];</div><div class="line">    <span class="keywordtype">int</span> testLabel = labels[labels.size() - 1];</div><div class="line">    images.pop_back();</div><div class="line">    labels.pop_back();</div><div class="line">    <span class="comment">// The following lines create an LBPH model for</span></div><div class="line">    <span class="comment">// face recognition and train it with the images and</span></div><div class="line">    <span class="comment">// labels read from the given CSV file.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// The LBPHFaceRecognizer uses Extended Local Binary Patterns</span></div><div class="line">    <span class="comment">// (it&#39;s probably configurable with other operators at a later</span></div><div class="line">    <span class="comment">// point), and has the following default values</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      radius = 1</span></div><div class="line">    <span class="comment">//      neighbors = 8</span></div><div class="line">    <span class="comment">//      grid_x = 8</span></div><div class="line">    <span class="comment">//      grid_y = 8</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// So if you want a LBPH FaceRecognizer using a radius of</span></div><div class="line">    <span class="comment">// 2 and 16 neighbors, call the factory method with:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      cv::face::LBPHFaceRecognizer::create(2, 16);</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// And if you want a threshold (e.g. 123.0) call it with its default values:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      cv::face::LBPHFaceRecognizer::create(1,8,8,8,123.0)</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <a class="code" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr&lt;LBPHFaceRecognizer&gt;</a> model = <a class="code" href="../../df/d25/classcv_1_1face_1_1LBPHFaceRecognizer.html#ac33ba992b16f29f2824761cea5cd5fc5">LBPHFaceRecognizer::create</a>();</div><div class="line">    model-&gt;train(images, labels);</div><div class="line">    <span class="comment">// The following line predicts the label of a given</span></div><div class="line">    <span class="comment">// test image:</span></div><div class="line">    <span class="keywordtype">int</span> predictedLabel = model-&gt;predict(testSample);</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// To get the confidence of a prediction call the model with:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">//      int predictedLabel = -1;</span></div><div class="line">    <span class="comment">//      double confidence = 0.0;</span></div><div class="line">    <span class="comment">//      model-&gt;predict(testSample, predictedLabel, confidence);</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keywordtype">string</span> result_message = format(<span class="stringliteral">&quot;Predicted class = %d / Actual class = %d.&quot;</span>, predictedLabel, testLabel);</div><div class="line">    cout &lt;&lt; result_message &lt;&lt; endl;</div><div class="line">    <span class="comment">// First we&#39;ll use it to set the threshold of the LBPHFaceRecognizer</span></div><div class="line">    <span class="comment">// to 0.0 without retraining the model. This can be useful if</span></div><div class="line">    <span class="comment">// you are evaluating the model:</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    model-&gt;setThreshold(0.0);</div><div class="line">    <span class="comment">// Now the threshold of this model is set to 0.0. A prediction</span></div><div class="line">    <span class="comment">// now returns -1, as it&#39;s impossible to have a distance below</span></div><div class="line">    <span class="comment">// it</span></div><div class="line">    predictedLabel = model-&gt;predict(testSample);</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Predicted class = &quot;</span> &lt;&lt; predictedLabel &lt;&lt; endl;</div><div class="line">    <span class="comment">// Show some informations about the model, as there&#39;s no cool</span></div><div class="line">    <span class="comment">// Model data to display as in Eigenfaces/Fisherfaces.</span></div><div class="line">    <span class="comment">// Due to efficiency reasons the LBP images are not stored</span></div><div class="line">    <span class="comment">// within the model:</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Model Information:&quot;</span> &lt;&lt; endl;</div><div class="line">    <span class="keywordtype">string</span> model_info = format(<span class="stringliteral">&quot;\tLBPH(radius=%i, neighbors=%i, grid_x=%i, grid_y=%i, threshold=%.2f)&quot;</span>,</div><div class="line">            model-&gt;getRadius(),</div><div class="line">            model-&gt;getNeighbors(),</div><div class="line">            model-&gt;getGridX(),</div><div class="line">            model-&gt;getGridY(),</div><div class="line">            model-&gt;getThreshold());</div><div class="line">    cout &lt;&lt; model_info &lt;&lt; endl;</div><div class="line">    <span class="comment">// We could get the histograms for example:</span></div><div class="line">    vector&lt;Mat&gt; histograms = model-&gt;getHistograms();</div><div class="line">    <span class="comment">// But should I really visualize it? Probably the length is interesting:</span></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Size of the histograms: &quot;</span> &lt;&lt; histograms[0].total() &lt;&lt; endl;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="tutorial_face_conclusion"></a>
Conclusion </h2>
<p>You've learned how to use the new FaceRecognizer in real applications. After reading the document you also know how the algorithms work, so now it's time for you to experiment with the available algorithms. Use them, improve them and let the OpenCV community participate!</p>
<h2><a class="anchor" id="tutorial_face_credits"></a>
Credits </h2>
<p>This document wouldn't be possible without the kind permission to use the face images of the <em>AT&amp;T Database of Faces</em> and the <em>Yale Facedatabase A/B</em>.</p>
<h3><a class="anchor" id="tutorial_face_credits_db"></a>
The Database of Faces</h3>
<p><b>Important: when using these images, please give credit to "AT&amp;T Laboratories, Cambridge."</b></p>
<p>The Database of Faces, formerly <em>The ORL Database of Faces</em>, contains a set of face images taken between April 1992 and April 1994. The database was used in the context of a face recognition project carried out in collaboration with the Speech, Vision and Robotics Group of the Cambridge University Engineering Department.</p>
<p>There are ten different images of each of 40 distinct subjects. For some subjects, the images were taken at different times, varying the lighting, facial expressions (open / closed eyes, smiling / not smiling) and facial details (glasses / no glasses). All the images were taken against a dark homogeneous background with the subjects in an upright, frontal position (with tolerance for some side movement).</p>
<p>The files are in PGM format. The size of each image is 92x112 pixels, with 256 grey levels per pixel. The images are organised in 40 directories (one for each subject), which have names of the form sX, where X indicates the subject number (between 1 and 40). In each of these directories, there are ten different images of that subject, which have names of the form Y.pgm, where Y is the image number for that subject (between 1 and 10).</p>
<p>A copy of the database can be retrieved from: <a href="http://www.cl.cam.ac.uk/research/dtg/attarchive/pub/data/att_faces.zip">http://www.cl.cam.ac.uk/research/dtg/attarchive/pub/data/att_faces.zip</a>.</p>
<h3><a class="anchor" id="tutorial_face_credits_yalea"></a>
Yale Facedatabase A</h3>
<p><em>With the permission of the authors I am allowed to show a small number of images (say subject 1 and all the variations) and all images such as Fisherfaces and Eigenfaces from either Yale Facedatabase A or the Yale Facedatabase B.</em></p>
<p>The Yale Face Database A (size 6.4MB) contains 165 grayscale images in GIF format of 15 individuals. There are 11 images per subject, one per different facial expression or configuration: center-light, w/glasses, happy, left-light, w/no glasses, normal, right-light, sad, sleepy, surprised, and wink. (Source: <a href="http://cvc.yale.edu/projects/yalefaces/yalefaces.html">http://cvc.yale.edu/projects/yalefaces/yalefaces.html</a>)</p>
<h3><a class="anchor" id="tutorial_face_credits_yaleb"></a>
Yale Facedatabase B</h3>
<p><em>With the permission of the authors I am allowed to show a small number of images (say subject 1 and all the variations) and all images such as Fisherfaces and Eigenfaces from either Yale Facedatabase A or the Yale Facedatabase B.</em></p>
<p>The extended Yale Face Database B contains 16128 images of 28 human subjects under 9 poses and 64 illumination conditions. The data format of this database is the same as the Yale Face Database B. Please refer to the homepage of the Yale Face Database B (or one copy of this page) for more detailed information of the data format.</p>
<p>You are free to use the extended Yale Face Database B for research purposes. All publications which use this database should acknowledge the use of "the Exteded Yale Face Database B" and reference Athinodoros Georghiades, Peter Belhumeur, and David Kriegman's paper, "From Few to Many:
Illumination Cone Models for Face Recognition under Variable Lighting and Pose", PAMI, 2001, <a href="http://vision.ucsd.edu/~leekc/ExtYaleDatabase/athosref.html">[bibtex]</a>.</p>
<p>The extended database as opposed to the original Yale Face Database B with 10 subjects was first reported by Kuang-Chih Lee, Jeffrey Ho, and David Kriegman in "Acquiring Linear Subspaces for Face Recognition under Variable Lighting, PAMI, May, 2005 <a href="http://vision.ucsd.edu/~leekc/papers/9pltsIEEE.pdf">[pdf]</a>." All test image data used in the experiments are manually aligned, cropped, and then re-sized to 168x192 images. If you publish your experimental results with the cropped images, please reference the PAMI2005 paper as well. (Source: <a href="http://vision.ucsd.edu/~leekc/ExtYaleDatabase/ExtYaleB.html">http://vision.ucsd.edu/~leekc/ExtYaleDatabase/ExtYaleB.html</a>)</p>
<h2><a class="anchor" id="face_appendix"></a>
Appendix </h2>
<h3><a class="anchor" id="tutorial_face_appendix_csv"></a>
Creating the CSV File</h3>
<p>You don't really want to create the CSV file by hand. I have prepared you a little Python script <code>create_csv.py</code> (you find it at <code>src/create_csv.py</code> coming with this tutorial) that automatically creates you a CSV file. If you have your images in hierarchie like this (<code>/basepath/&lt;subject&gt;/&lt;image.ext&gt;</code>):</p>
<div class="fragment"><div class="line">philipp@mango:~/facerec/data/at$ tree</div><div class="line">.</div><div class="line">|-- s1</div><div class="line">|   |-- 1.pgm</div><div class="line">|   |-- ...</div><div class="line">|   |-- 10.pgm</div><div class="line">|-- s2</div><div class="line">|   |-- 1.pgm</div><div class="line">|   |-- ...</div><div class="line">|   |-- 10.pgm</div><div class="line">...</div><div class="line">|-- s40</div><div class="line">|   |-- 1.pgm</div><div class="line">|   |-- ...</div><div class="line">|   |-- 10.pgm</div></div><!-- fragment --><p>Then simply call <code>create_csv.py at</code> , here 'at' being the basepath to the folder, just like this and you could save the output:</p>
<div class="fragment"><div class="line">philipp@mango:~/facerec/data$ python create_csv.py at</div><div class="line">at/s13/2.pgm;0</div><div class="line">at/s13/7.pgm;0</div><div class="line">at/s13/6.pgm;0</div><div class="line">at/s13/9.pgm;0</div><div class="line">at/s13/5.pgm;0</div><div class="line">at/s13/3.pgm;0</div><div class="line">at/s13/4.pgm;0</div><div class="line">at/s13/10.pgm;0</div><div class="line">at/s13/8.pgm;0</div><div class="line">at/s13/1.pgm;0</div><div class="line">at/s17/2.pgm;1</div><div class="line">at/s17/7.pgm;1</div><div class="line">at/s17/6.pgm;1</div><div class="line">at/s17/9.pgm;1</div><div class="line">at/s17/5.pgm;1</div><div class="line">at/s17/3.pgm;1</div><div class="line">[...]</div></div><!-- fragment --><p>Here is the script, if you can't find it:</p>
<pre class="fragment">#!/usr/bin/env python

import sys
import os.path

# This is a tiny script to help you creating a CSV file from a face
# database with a similar hierarchie:
#
#  philipp@mango:~/facerec/data/at$ tree
#  .
#  |-- README
#  |-- s1
#  |   |-- 1.pgm
#  |   |-- ...
#  |   |-- 10.pgm
#  |-- s2
#  |   |-- 1.pgm
#  |   |-- ...
#  |   |-- 10.pgm
#  ...
#  |-- s40
#  |   |-- 1.pgm
#  |   |-- ...
#  |   |-- 10.pgm
#

if __name__ == "__main__":

    if len(sys.argv) != 2:
        print "usage: create_csv &lt;base_path&gt;"
        sys.exit(1)

    BASE_PATH=sys.argv[1]
    SEPARATOR=";"

    label = 0
    for dirname, dirnames, filenames in os.walk(BASE_PATH):
        for subdirname in dirnames:
            subject_path = os.path.join(dirname, subdirname)
            for filename in os.listdir(subject_path):
                abs_path = "%s/%s" % (subject_path, filename)
                print "%s%s%d" % (abs_path, SEPARATOR, label)
            label = label + 1
</pre><h3><a class="anchor" id="tutorial_face_appendix_align"></a>
Aligning Face Images</h3>
<p>An accurate alignment of your image data is especially important in tasks like emotion detection, were you need as much detail as possible. Believe me... You don't want to do this by hand. So I've prepared you a tiny Python script. The code is really easy to use. To scale, rotate and crop the face image you just need to call <em>CropFace(image, eye_left, eye_right, offset_pct, dest_sz)</em>, where:</p>
<ul>
<li><em>eye_left</em> is the position of the left eye</li>
<li><em>eye_right</em> is the position of the right eye</li>
<li><em>offset_pct</em> is the percent of the image you want to keep next to the eyes (horizontal, vertical direction)</li>
<li><em>dest_sz</em> is the size of the output image</li>
</ul>
<p>If you are using the same <em>offset_pct</em> and <em>dest_sz</em> for your images, they are all aligned at the eyes.</p>
<pre class="fragment">#!/usr/bin/env python
# Software License Agreement (BSD License)
#
# Copyright (c) 2012, Philipp Wagner
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
#  * Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#  * Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#  * Neither the name of the author nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import sys, math, Image

def Distance(p1,p2):
  dx = p2[0] - p1[0]
  dy = p2[1] - p1[1]
  return math.sqrt(dx*dx+dy*dy)

def ScaleRotateTranslate(image, angle, center = None, new_center = None, scale = None, resample=Image.BICUBIC):
  if (scale is None) and (center is None):
    return image.rotate(angle=angle, resample=resample)
  nx,ny = x,y = center
  sx=sy=1.0
  if new_center:
    (nx,ny) = new_center
  if scale:
    (sx,sy) = (scale, scale)
  cosine = math.cos(angle)
  sine = math.sin(angle)
  a = cosine/sx
  b = sine/sx
  c = x-nx*a-ny*b
  d = -sine/sy
  e = cosine/sy
  f = y-nx*d-ny*e
  return image.transform(image.size, Image.AFFINE, (a,b,c,d,e,f), resample=resample)

def CropFace(image, eye_left=(0,0), eye_right=(0,0), offset_pct=(0.2,0.2), dest_sz = (70,70)):
  # calculate offsets in original image
  offset_h = math.floor(float(offset_pct[0])*dest_sz[0])
  offset_v = math.floor(float(offset_pct[1])*dest_sz[1])
  # get the direction
  eye_direction = (eye_right[0] - eye_left[0], eye_right[1] - eye_left[1])
  # calc rotation angle in radians
  rotation = -math.atan2(float(eye_direction[1]),float(eye_direction[0]))
  # distance between them
  dist = Distance(eye_left, eye_right)
  # calculate the reference eye-width
  reference = dest_sz[0] - 2.0*offset_h
  # scale factor
  scale = float(dist)/float(reference)
  # rotate original around the left eye
  image = ScaleRotateTranslate(image, center=eye_left, angle=rotation)
  # crop the rotated image
  crop_xy = (eye_left[0] - scale*offset_h, eye_left[1] - scale*offset_v)
  crop_size = (dest_sz[0]*scale, dest_sz[1]*scale)
  image = image.crop((int(crop_xy[0]), int(crop_xy[1]), int(crop_xy[0]+crop_size[0]), int(crop_xy[1]+crop_size[1])))
  # resize it
  image = image.resize(dest_sz, Image.ANTIALIAS)
  return image

def readFileNames():
    try:
        inFile = open('path_to_created_csv_file.csv')
    except:
        raise IOError('There is no file named path_to_created_csv_file.csv in current directory.')
        return False

    picPath = []
    picIndex = []

    for line in inFile.readlines():
        if line != '':
            fields = line.rstrip().split(';')
            picPath.append(fields[0])
            picIndex.append(int(fields[1]))

    return (picPath, picIndex)


if __name__ == "__main__":
  [images, indexes]=readFileNames()
if not os.path.exists("modified"):
    os.makedirs("modified")
for img in images:
    image =  Image.open(img)
    CropFace(image, eye_left=(252,364), eye_right=(420,366), offset_pct=(0.1,0.1), dest_sz=(200,200)).save("modified/"+img.rstrip().split('/')[1]+"_10_10_200_200.jpg")
    CropFace(image, eye_left=(252,364), eye_right=(420,366), offset_pct=(0.2,0.2), dest_sz=(200,200)).save("modified/"+img.rstrip().split('/')[1]+"_20_20_200_200.jpg")
    CropFace(image, eye_left=(252,364), eye_right=(420,366), offset_pct=(0.3,0.3), dest_sz=(200,200)).save("modified/"+img.rstrip().split('/')[1]+"_30_30_200_200.jpg")
    CropFace(image, eye_left=(252,364), eye_right=(420,366), offset_pct=(0.2,0.2)).save("modified/"+img.rstrip().split('/')[1]+"_20_20_70_70.jpg")
</pre><p>Imagine we are given <a href="http://en.wikipedia.org/wiki/File:Arnold_Schwarzenegger_edit%28ws%29.jpg">this photo of Arnold Schwarzenegger</a>, which is under a Public Domain license. The (x,y)-position of the eyes is approximately *(252,364)* for the left and *(420,366)* for the right eye. Now you only need to define the horizontal offset, vertical offset and the size your scaled, rotated &amp; cropped face should have.</p>
<p>Here are some examples:</p>
<table class="doxtable">
<tr>
<th>Configuration </th><th>Cropped, Scaled, Rotated Face  </th></tr>
<tr>
<td>0.1 (10%), 0.1 (10%), (200,200) </td><td><div class="image">
<img src="../../tutorials/gender_classification/arnie_10_10_200_200.jpg"/>
</div>
 </td></tr>
<tr>
<td>0.2 (20%), 0.2 (20%), (200,200) </td><td><div class="image">
<img src="../../tutorials/gender_classification/arnie_20_20_200_200.jpg"/>
</div>
 </td></tr>
<tr>
<td>0.3 (30%), 0.3 (30%), (200,200) </td><td><div class="image">
<img src="../../tutorials/gender_classification/arnie_30_30_200_200.jpg"/>
</div>
 </td></tr>
<tr>
<td>0.2 (20%), 0.2 (20%), (70,70) </td><td><div class="image">
<img src="../../tutorials/gender_classification/arnie_20_20_70_70.jpg"/>
</div>
 </td></tr>
</table>
<h3><a class="anchor" id="tutorial_face_appendix_attcsv"></a>
CSV for the AT&amp;T Facedatabase</h3>
<pre class="fragment">/home/philipp/facerec/data/at/s13/2.pgm;12
/home/philipp/facerec/data/at/s13/7.pgm;12
/home/philipp/facerec/data/at/s13/6.pgm;12
/home/philipp/facerec/data/at/s13/9.pgm;12
/home/philipp/facerec/data/at/s13/5.pgm;12
/home/philipp/facerec/data/at/s13/3.pgm;12
/home/philipp/facerec/data/at/s13/4.pgm;12
/home/philipp/facerec/data/at/s13/10.pgm;12
/home/philipp/facerec/data/at/s13/8.pgm;12
/home/philipp/facerec/data/at/s13/1.pgm;12
/home/philipp/facerec/data/at/s17/2.pgm;16
/home/philipp/facerec/data/at/s17/7.pgm;16
/home/philipp/facerec/data/at/s17/6.pgm;16
/home/philipp/facerec/data/at/s17/9.pgm;16
/home/philipp/facerec/data/at/s17/5.pgm;16
/home/philipp/facerec/data/at/s17/3.pgm;16
/home/philipp/facerec/data/at/s17/4.pgm;16
/home/philipp/facerec/data/at/s17/10.pgm;16
/home/philipp/facerec/data/at/s17/8.pgm;16
/home/philipp/facerec/data/at/s17/1.pgm;16
/home/philipp/facerec/data/at/s32/2.pgm;31
/home/philipp/facerec/data/at/s32/7.pgm;31
/home/philipp/facerec/data/at/s32/6.pgm;31
/home/philipp/facerec/data/at/s32/9.pgm;31
/home/philipp/facerec/data/at/s32/5.pgm;31
/home/philipp/facerec/data/at/s32/3.pgm;31
/home/philipp/facerec/data/at/s32/4.pgm;31
/home/philipp/facerec/data/at/s32/10.pgm;31
/home/philipp/facerec/data/at/s32/8.pgm;31
/home/philipp/facerec/data/at/s32/1.pgm;31
/home/philipp/facerec/data/at/s10/2.pgm;9
/home/philipp/facerec/data/at/s10/7.pgm;9
/home/philipp/facerec/data/at/s10/6.pgm;9
/home/philipp/facerec/data/at/s10/9.pgm;9
/home/philipp/facerec/data/at/s10/5.pgm;9
/home/philipp/facerec/data/at/s10/3.pgm;9
/home/philipp/facerec/data/at/s10/4.pgm;9
/home/philipp/facerec/data/at/s10/10.pgm;9
/home/philipp/facerec/data/at/s10/8.pgm;9
/home/philipp/facerec/data/at/s10/1.pgm;9
/home/philipp/facerec/data/at/s27/2.pgm;26
/home/philipp/facerec/data/at/s27/7.pgm;26
/home/philipp/facerec/data/at/s27/6.pgm;26
/home/philipp/facerec/data/at/s27/9.pgm;26
/home/philipp/facerec/data/at/s27/5.pgm;26
/home/philipp/facerec/data/at/s27/3.pgm;26
/home/philipp/facerec/data/at/s27/4.pgm;26
/home/philipp/facerec/data/at/s27/10.pgm;26
/home/philipp/facerec/data/at/s27/8.pgm;26
/home/philipp/facerec/data/at/s27/1.pgm;26
/home/philipp/facerec/data/at/s5/2.pgm;4
/home/philipp/facerec/data/at/s5/7.pgm;4
/home/philipp/facerec/data/at/s5/6.pgm;4
/home/philipp/facerec/data/at/s5/9.pgm;4
/home/philipp/facerec/data/at/s5/5.pgm;4
/home/philipp/facerec/data/at/s5/3.pgm;4
/home/philipp/facerec/data/at/s5/4.pgm;4
/home/philipp/facerec/data/at/s5/10.pgm;4
/home/philipp/facerec/data/at/s5/8.pgm;4
/home/philipp/facerec/data/at/s5/1.pgm;4
/home/philipp/facerec/data/at/s20/2.pgm;19
/home/philipp/facerec/data/at/s20/7.pgm;19
/home/philipp/facerec/data/at/s20/6.pgm;19
/home/philipp/facerec/data/at/s20/9.pgm;19
/home/philipp/facerec/data/at/s20/5.pgm;19
/home/philipp/facerec/data/at/s20/3.pgm;19
/home/philipp/facerec/data/at/s20/4.pgm;19
/home/philipp/facerec/data/at/s20/10.pgm;19
/home/philipp/facerec/data/at/s20/8.pgm;19
/home/philipp/facerec/data/at/s20/1.pgm;19
/home/philipp/facerec/data/at/s30/2.pgm;29
/home/philipp/facerec/data/at/s30/7.pgm;29
/home/philipp/facerec/data/at/s30/6.pgm;29
/home/philipp/facerec/data/at/s30/9.pgm;29
/home/philipp/facerec/data/at/s30/5.pgm;29
/home/philipp/facerec/data/at/s30/3.pgm;29
/home/philipp/facerec/data/at/s30/4.pgm;29
/home/philipp/facerec/data/at/s30/10.pgm;29
/home/philipp/facerec/data/at/s30/8.pgm;29
/home/philipp/facerec/data/at/s30/1.pgm;29
/home/philipp/facerec/data/at/s39/2.pgm;38
/home/philipp/facerec/data/at/s39/7.pgm;38
/home/philipp/facerec/data/at/s39/6.pgm;38
/home/philipp/facerec/data/at/s39/9.pgm;38
/home/philipp/facerec/data/at/s39/5.pgm;38
/home/philipp/facerec/data/at/s39/3.pgm;38
/home/philipp/facerec/data/at/s39/4.pgm;38
/home/philipp/facerec/data/at/s39/10.pgm;38
/home/philipp/facerec/data/at/s39/8.pgm;38
/home/philipp/facerec/data/at/s39/1.pgm;38
/home/philipp/facerec/data/at/s35/2.pgm;34
/home/philipp/facerec/data/at/s35/7.pgm;34
/home/philipp/facerec/data/at/s35/6.pgm;34
/home/philipp/facerec/data/at/s35/9.pgm;34
/home/philipp/facerec/data/at/s35/5.pgm;34
/home/philipp/facerec/data/at/s35/3.pgm;34
/home/philipp/facerec/data/at/s35/4.pgm;34
/home/philipp/facerec/data/at/s35/10.pgm;34
/home/philipp/facerec/data/at/s35/8.pgm;34
/home/philipp/facerec/data/at/s35/1.pgm;34
/home/philipp/facerec/data/at/s23/2.pgm;22
/home/philipp/facerec/data/at/s23/7.pgm;22
/home/philipp/facerec/data/at/s23/6.pgm;22
/home/philipp/facerec/data/at/s23/9.pgm;22
/home/philipp/facerec/data/at/s23/5.pgm;22
/home/philipp/facerec/data/at/s23/3.pgm;22
/home/philipp/facerec/data/at/s23/4.pgm;22
/home/philipp/facerec/data/at/s23/10.pgm;22
/home/philipp/facerec/data/at/s23/8.pgm;22
/home/philipp/facerec/data/at/s23/1.pgm;22
/home/philipp/facerec/data/at/s4/2.pgm;3
/home/philipp/facerec/data/at/s4/7.pgm;3
/home/philipp/facerec/data/at/s4/6.pgm;3
/home/philipp/facerec/data/at/s4/9.pgm;3
/home/philipp/facerec/data/at/s4/5.pgm;3
/home/philipp/facerec/data/at/s4/3.pgm;3
/home/philipp/facerec/data/at/s4/4.pgm;3
/home/philipp/facerec/data/at/s4/10.pgm;3
/home/philipp/facerec/data/at/s4/8.pgm;3
/home/philipp/facerec/data/at/s4/1.pgm;3
/home/philipp/facerec/data/at/s9/2.pgm;8
/home/philipp/facerec/data/at/s9/7.pgm;8
/home/philipp/facerec/data/at/s9/6.pgm;8
/home/philipp/facerec/data/at/s9/9.pgm;8
/home/philipp/facerec/data/at/s9/5.pgm;8
/home/philipp/facerec/data/at/s9/3.pgm;8
/home/philipp/facerec/data/at/s9/4.pgm;8
/home/philipp/facerec/data/at/s9/10.pgm;8
/home/philipp/facerec/data/at/s9/8.pgm;8
/home/philipp/facerec/data/at/s9/1.pgm;8
/home/philipp/facerec/data/at/s37/2.pgm;36
/home/philipp/facerec/data/at/s37/7.pgm;36
/home/philipp/facerec/data/at/s37/6.pgm;36
/home/philipp/facerec/data/at/s37/9.pgm;36
/home/philipp/facerec/data/at/s37/5.pgm;36
/home/philipp/facerec/data/at/s37/3.pgm;36
/home/philipp/facerec/data/at/s37/4.pgm;36
/home/philipp/facerec/data/at/s37/10.pgm;36
/home/philipp/facerec/data/at/s37/8.pgm;36
/home/philipp/facerec/data/at/s37/1.pgm;36
/home/philipp/facerec/data/at/s24/2.pgm;23
/home/philipp/facerec/data/at/s24/7.pgm;23
/home/philipp/facerec/data/at/s24/6.pgm;23
/home/philipp/facerec/data/at/s24/9.pgm;23
/home/philipp/facerec/data/at/s24/5.pgm;23
/home/philipp/facerec/data/at/s24/3.pgm;23
/home/philipp/facerec/data/at/s24/4.pgm;23
/home/philipp/facerec/data/at/s24/10.pgm;23
/home/philipp/facerec/data/at/s24/8.pgm;23
/home/philipp/facerec/data/at/s24/1.pgm;23
/home/philipp/facerec/data/at/s19/2.pgm;18
/home/philipp/facerec/data/at/s19/7.pgm;18
/home/philipp/facerec/data/at/s19/6.pgm;18
/home/philipp/facerec/data/at/s19/9.pgm;18
/home/philipp/facerec/data/at/s19/5.pgm;18
/home/philipp/facerec/data/at/s19/3.pgm;18
/home/philipp/facerec/data/at/s19/4.pgm;18
/home/philipp/facerec/data/at/s19/10.pgm;18
/home/philipp/facerec/data/at/s19/8.pgm;18
/home/philipp/facerec/data/at/s19/1.pgm;18
/home/philipp/facerec/data/at/s8/2.pgm;7
/home/philipp/facerec/data/at/s8/7.pgm;7
/home/philipp/facerec/data/at/s8/6.pgm;7
/home/philipp/facerec/data/at/s8/9.pgm;7
/home/philipp/facerec/data/at/s8/5.pgm;7
/home/philipp/facerec/data/at/s8/3.pgm;7
/home/philipp/facerec/data/at/s8/4.pgm;7
/home/philipp/facerec/data/at/s8/10.pgm;7
/home/philipp/facerec/data/at/s8/8.pgm;7
/home/philipp/facerec/data/at/s8/1.pgm;7
/home/philipp/facerec/data/at/s21/2.pgm;20
/home/philipp/facerec/data/at/s21/7.pgm;20
/home/philipp/facerec/data/at/s21/6.pgm;20
/home/philipp/facerec/data/at/s21/9.pgm;20
/home/philipp/facerec/data/at/s21/5.pgm;20
/home/philipp/facerec/data/at/s21/3.pgm;20
/home/philipp/facerec/data/at/s21/4.pgm;20
/home/philipp/facerec/data/at/s21/10.pgm;20
/home/philipp/facerec/data/at/s21/8.pgm;20
/home/philipp/facerec/data/at/s21/1.pgm;20
/home/philipp/facerec/data/at/s1/2.pgm;0
/home/philipp/facerec/data/at/s1/7.pgm;0
/home/philipp/facerec/data/at/s1/6.pgm;0
/home/philipp/facerec/data/at/s1/9.pgm;0
/home/philipp/facerec/data/at/s1/5.pgm;0
/home/philipp/facerec/data/at/s1/3.pgm;0
/home/philipp/facerec/data/at/s1/4.pgm;0
/home/philipp/facerec/data/at/s1/10.pgm;0
/home/philipp/facerec/data/at/s1/8.pgm;0
/home/philipp/facerec/data/at/s1/1.pgm;0
/home/philipp/facerec/data/at/s7/2.pgm;6
/home/philipp/facerec/data/at/s7/7.pgm;6
/home/philipp/facerec/data/at/s7/6.pgm;6
/home/philipp/facerec/data/at/s7/9.pgm;6
/home/philipp/facerec/data/at/s7/5.pgm;6
/home/philipp/facerec/data/at/s7/3.pgm;6
/home/philipp/facerec/data/at/s7/4.pgm;6
/home/philipp/facerec/data/at/s7/10.pgm;6
/home/philipp/facerec/data/at/s7/8.pgm;6
/home/philipp/facerec/data/at/s7/1.pgm;6
/home/philipp/facerec/data/at/s16/2.pgm;15
/home/philipp/facerec/data/at/s16/7.pgm;15
/home/philipp/facerec/data/at/s16/6.pgm;15
/home/philipp/facerec/data/at/s16/9.pgm;15
/home/philipp/facerec/data/at/s16/5.pgm;15
/home/philipp/facerec/data/at/s16/3.pgm;15
/home/philipp/facerec/data/at/s16/4.pgm;15
/home/philipp/facerec/data/at/s16/10.pgm;15
/home/philipp/facerec/data/at/s16/8.pgm;15
/home/philipp/facerec/data/at/s16/1.pgm;15
/home/philipp/facerec/data/at/s36/2.pgm;35
/home/philipp/facerec/data/at/s36/7.pgm;35
/home/philipp/facerec/data/at/s36/6.pgm;35
/home/philipp/facerec/data/at/s36/9.pgm;35
/home/philipp/facerec/data/at/s36/5.pgm;35
/home/philipp/facerec/data/at/s36/3.pgm;35
/home/philipp/facerec/data/at/s36/4.pgm;35
/home/philipp/facerec/data/at/s36/10.pgm;35
/home/philipp/facerec/data/at/s36/8.pgm;35
/home/philipp/facerec/data/at/s36/1.pgm;35
/home/philipp/facerec/data/at/s25/2.pgm;24
/home/philipp/facerec/data/at/s25/7.pgm;24
/home/philipp/facerec/data/at/s25/6.pgm;24
/home/philipp/facerec/data/at/s25/9.pgm;24
/home/philipp/facerec/data/at/s25/5.pgm;24
/home/philipp/facerec/data/at/s25/3.pgm;24
/home/philipp/facerec/data/at/s25/4.pgm;24
/home/philipp/facerec/data/at/s25/10.pgm;24
/home/philipp/facerec/data/at/s25/8.pgm;24
/home/philipp/facerec/data/at/s25/1.pgm;24
/home/philipp/facerec/data/at/s14/2.pgm;13
/home/philipp/facerec/data/at/s14/7.pgm;13
/home/philipp/facerec/data/at/s14/6.pgm;13
/home/philipp/facerec/data/at/s14/9.pgm;13
/home/philipp/facerec/data/at/s14/5.pgm;13
/home/philipp/facerec/data/at/s14/3.pgm;13
/home/philipp/facerec/data/at/s14/4.pgm;13
/home/philipp/facerec/data/at/s14/10.pgm;13
/home/philipp/facerec/data/at/s14/8.pgm;13
/home/philipp/facerec/data/at/s14/1.pgm;13
/home/philipp/facerec/data/at/s34/2.pgm;33
/home/philipp/facerec/data/at/s34/7.pgm;33
/home/philipp/facerec/data/at/s34/6.pgm;33
/home/philipp/facerec/data/at/s34/9.pgm;33
/home/philipp/facerec/data/at/s34/5.pgm;33
/home/philipp/facerec/data/at/s34/3.pgm;33
/home/philipp/facerec/data/at/s34/4.pgm;33
/home/philipp/facerec/data/at/s34/10.pgm;33
/home/philipp/facerec/data/at/s34/8.pgm;33
/home/philipp/facerec/data/at/s34/1.pgm;33
/home/philipp/facerec/data/at/s11/2.pgm;10
/home/philipp/facerec/data/at/s11/7.pgm;10
/home/philipp/facerec/data/at/s11/6.pgm;10
/home/philipp/facerec/data/at/s11/9.pgm;10
/home/philipp/facerec/data/at/s11/5.pgm;10
/home/philipp/facerec/data/at/s11/3.pgm;10
/home/philipp/facerec/data/at/s11/4.pgm;10
/home/philipp/facerec/data/at/s11/10.pgm;10
/home/philipp/facerec/data/at/s11/8.pgm;10
/home/philipp/facerec/data/at/s11/1.pgm;10
/home/philipp/facerec/data/at/s26/2.pgm;25
/home/philipp/facerec/data/at/s26/7.pgm;25
/home/philipp/facerec/data/at/s26/6.pgm;25
/home/philipp/facerec/data/at/s26/9.pgm;25
/home/philipp/facerec/data/at/s26/5.pgm;25
/home/philipp/facerec/data/at/s26/3.pgm;25
/home/philipp/facerec/data/at/s26/4.pgm;25
/home/philipp/facerec/data/at/s26/10.pgm;25
/home/philipp/facerec/data/at/s26/8.pgm;25
/home/philipp/facerec/data/at/s26/1.pgm;25
/home/philipp/facerec/data/at/s18/2.pgm;17
/home/philipp/facerec/data/at/s18/7.pgm;17
/home/philipp/facerec/data/at/s18/6.pgm;17
/home/philipp/facerec/data/at/s18/9.pgm;17
/home/philipp/facerec/data/at/s18/5.pgm;17
/home/philipp/facerec/data/at/s18/3.pgm;17
/home/philipp/facerec/data/at/s18/4.pgm;17
/home/philipp/facerec/data/at/s18/10.pgm;17
/home/philipp/facerec/data/at/s18/8.pgm;17
/home/philipp/facerec/data/at/s18/1.pgm;17
/home/philipp/facerec/data/at/s29/2.pgm;28
/home/philipp/facerec/data/at/s29/7.pgm;28
/home/philipp/facerec/data/at/s29/6.pgm;28
/home/philipp/facerec/data/at/s29/9.pgm;28
/home/philipp/facerec/data/at/s29/5.pgm;28
/home/philipp/facerec/data/at/s29/3.pgm;28
/home/philipp/facerec/data/at/s29/4.pgm;28
/home/philipp/facerec/data/at/s29/10.pgm;28
/home/philipp/facerec/data/at/s29/8.pgm;28
/home/philipp/facerec/data/at/s29/1.pgm;28
/home/philipp/facerec/data/at/s33/2.pgm;32
/home/philipp/facerec/data/at/s33/7.pgm;32
/home/philipp/facerec/data/at/s33/6.pgm;32
/home/philipp/facerec/data/at/s33/9.pgm;32
/home/philipp/facerec/data/at/s33/5.pgm;32
/home/philipp/facerec/data/at/s33/3.pgm;32
/home/philipp/facerec/data/at/s33/4.pgm;32
/home/philipp/facerec/data/at/s33/10.pgm;32
/home/philipp/facerec/data/at/s33/8.pgm;32
/home/philipp/facerec/data/at/s33/1.pgm;32
/home/philipp/facerec/data/at/s12/2.pgm;11
/home/philipp/facerec/data/at/s12/7.pgm;11
/home/philipp/facerec/data/at/s12/6.pgm;11
/home/philipp/facerec/data/at/s12/9.pgm;11
/home/philipp/facerec/data/at/s12/5.pgm;11
/home/philipp/facerec/data/at/s12/3.pgm;11
/home/philipp/facerec/data/at/s12/4.pgm;11
/home/philipp/facerec/data/at/s12/10.pgm;11
/home/philipp/facerec/data/at/s12/8.pgm;11
/home/philipp/facerec/data/at/s12/1.pgm;11
/home/philipp/facerec/data/at/s6/2.pgm;5
/home/philipp/facerec/data/at/s6/7.pgm;5
/home/philipp/facerec/data/at/s6/6.pgm;5
/home/philipp/facerec/data/at/s6/9.pgm;5
/home/philipp/facerec/data/at/s6/5.pgm;5
/home/philipp/facerec/data/at/s6/3.pgm;5
/home/philipp/facerec/data/at/s6/4.pgm;5
/home/philipp/facerec/data/at/s6/10.pgm;5
/home/philipp/facerec/data/at/s6/8.pgm;5
/home/philipp/facerec/data/at/s6/1.pgm;5
/home/philipp/facerec/data/at/s22/2.pgm;21
/home/philipp/facerec/data/at/s22/7.pgm;21
/home/philipp/facerec/data/at/s22/6.pgm;21
/home/philipp/facerec/data/at/s22/9.pgm;21
/home/philipp/facerec/data/at/s22/5.pgm;21
/home/philipp/facerec/data/at/s22/3.pgm;21
/home/philipp/facerec/data/at/s22/4.pgm;21
/home/philipp/facerec/data/at/s22/10.pgm;21
/home/philipp/facerec/data/at/s22/8.pgm;21
/home/philipp/facerec/data/at/s22/1.pgm;21
/home/philipp/facerec/data/at/s15/2.pgm;14
/home/philipp/facerec/data/at/s15/7.pgm;14
/home/philipp/facerec/data/at/s15/6.pgm;14
/home/philipp/facerec/data/at/s15/9.pgm;14
/home/philipp/facerec/data/at/s15/5.pgm;14
/home/philipp/facerec/data/at/s15/3.pgm;14
/home/philipp/facerec/data/at/s15/4.pgm;14
/home/philipp/facerec/data/at/s15/10.pgm;14
/home/philipp/facerec/data/at/s15/8.pgm;14
/home/philipp/facerec/data/at/s15/1.pgm;14
/home/philipp/facerec/data/at/s2/2.pgm;1
/home/philipp/facerec/data/at/s2/7.pgm;1
/home/philipp/facerec/data/at/s2/6.pgm;1
/home/philipp/facerec/data/at/s2/9.pgm;1
/home/philipp/facerec/data/at/s2/5.pgm;1
/home/philipp/facerec/data/at/s2/3.pgm;1
/home/philipp/facerec/data/at/s2/4.pgm;1
/home/philipp/facerec/data/at/s2/10.pgm;1
/home/philipp/facerec/data/at/s2/8.pgm;1
/home/philipp/facerec/data/at/s2/1.pgm;1
/home/philipp/facerec/data/at/s31/2.pgm;30
/home/philipp/facerec/data/at/s31/7.pgm;30
/home/philipp/facerec/data/at/s31/6.pgm;30
/home/philipp/facerec/data/at/s31/9.pgm;30
/home/philipp/facerec/data/at/s31/5.pgm;30
/home/philipp/facerec/data/at/s31/3.pgm;30
/home/philipp/facerec/data/at/s31/4.pgm;30
/home/philipp/facerec/data/at/s31/10.pgm;30
/home/philipp/facerec/data/at/s31/8.pgm;30
/home/philipp/facerec/data/at/s31/1.pgm;30
/home/philipp/facerec/data/at/s28/2.pgm;27
/home/philipp/facerec/data/at/s28/7.pgm;27
/home/philipp/facerec/data/at/s28/6.pgm;27
/home/philipp/facerec/data/at/s28/9.pgm;27
/home/philipp/facerec/data/at/s28/5.pgm;27
/home/philipp/facerec/data/at/s28/3.pgm;27
/home/philipp/facerec/data/at/s28/4.pgm;27
/home/philipp/facerec/data/at/s28/10.pgm;27
/home/philipp/facerec/data/at/s28/8.pgm;27
/home/philipp/facerec/data/at/s28/1.pgm;27
/home/philipp/facerec/data/at/s40/2.pgm;39
/home/philipp/facerec/data/at/s40/7.pgm;39
/home/philipp/facerec/data/at/s40/6.pgm;39
/home/philipp/facerec/data/at/s40/9.pgm;39
/home/philipp/facerec/data/at/s40/5.pgm;39
/home/philipp/facerec/data/at/s40/3.pgm;39
/home/philipp/facerec/data/at/s40/4.pgm;39
/home/philipp/facerec/data/at/s40/10.pgm;39
/home/philipp/facerec/data/at/s40/8.pgm;39
/home/philipp/facerec/data/at/s40/1.pgm;39
/home/philipp/facerec/data/at/s3/2.pgm;2
/home/philipp/facerec/data/at/s3/7.pgm;2
/home/philipp/facerec/data/at/s3/6.pgm;2
/home/philipp/facerec/data/at/s3/9.pgm;2
/home/philipp/facerec/data/at/s3/5.pgm;2
/home/philipp/facerec/data/at/s3/3.pgm;2
/home/philipp/facerec/data/at/s3/4.pgm;2
/home/philipp/facerec/data/at/s3/10.pgm;2
/home/philipp/facerec/data/at/s3/8.pgm;2
/home/philipp/facerec/data/at/s3/1.pgm;2
/home/philipp/facerec/data/at/s38/2.pgm;37
/home/philipp/facerec/data/at/s38/7.pgm;37
/home/philipp/facerec/data/at/s38/6.pgm;37
/home/philipp/facerec/data/at/s38/9.pgm;37
/home/philipp/facerec/data/at/s38/5.pgm;37
/home/philipp/facerec/data/at/s38/3.pgm;37
/home/philipp/facerec/data/at/s38/4.pgm;37
/home/philipp/facerec/data/at/s38/10.pgm;37
/home/philipp/facerec/data/at/s38/8.pgm;37
/home/philipp/facerec/data/at/s38/1.pgm;37
</pre> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 5 2022 16:19:56 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
