<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.13" name="generator"/>
<title>OpenCV: cv::cuda::BufferPool Class Reference</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script src="../../jquery.js" type="text/javascript"></script>
<script src="../../dynsections.js" type="text/javascript"></script>
<script src="../../tutorial-utils.js" type="text/javascript"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script src="../../search/searchdata.js" type="text/javascript"></script>
<script src="../../search/search.js" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
          distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
          distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js" type="text/javascript"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellpadding="0" cellspacing="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
    <span id="projectnumber">4.6.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script src="../../menudata.js" type="text/javascript"></script>
<script src="../../menu.js" type="text/javascript"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="navpath" id="nav-path">
  <ul>
<li class="navelem"><a class="el" href="../../d2/d75/namespacecv.html">cv</a></li><li class="navelem"><a class="el" href="../../d1/d1a/namespacecv_1_1cuda.html">cuda</a></li><li class="navelem"><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html">BufferPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> |
<a href="../../d7/dfb/classcv_1_1cuda_1_1BufferPool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cv::cuda::BufferPool Class Reference<div class="ingroups"><a class="el" href="../../d1/d1e/group__cuda.html">CUDA-accelerated Computer Vision</a> » <a class="el" href="../../d7/d05/group__cudacore.html">Core part</a> » <a class="el" href="../../d9/d41/group__cudacore__struct.html">Data Structures</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html" title="BufferPool for use with CUDA streams. ">BufferPool</a> for use with CUDA streams.  
 <a href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html#details">More...</a></p>
<p><code>#include &lt;opencv2/core/cuda.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0f1e0a518847d41663e7344927515761"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> (<a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html">Stream</a> &amp;stream)</td></tr>
<tr class="memdesc:a0f1e0a518847d41663e7344927515761"><td class="mdescLeft"> </td><td class="mdescRight">Gets the <a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html" title="BufferPool for use with CUDA streams. ">BufferPool</a> for the given stream.  <a href="#a0f1e0a518847d41663e7344927515761">More...</a><br/></td></tr>
<tr class="separator:a0f1e0a518847d41663e7344927515761"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d639258399df2b804a88afa334b022b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt; <a class="el" href="../../df/d98/classcv_1_1cuda_1_1GpuMat_1_1Allocator.html">GpuMat::Allocator</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html#a4d639258399df2b804a88afa334b022b">getAllocator</a> () const</td></tr>
<tr class="memdesc:a4d639258399df2b804a88afa334b022b"><td class="mdescLeft"> </td><td class="mdescRight">Returns the allocator associated with the stream.  <a href="#a4d639258399df2b804a88afa334b022b">More...</a><br/></td></tr>
<tr class="separator:a4d639258399df2b804a88afa334b022b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a715fecc85a804935c8c5a6c4eb4f905e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html#a715fecc85a804935c8c5a6c4eb4f905e">getBuffer</a> (int rows, int cols, int type)</td></tr>
<tr class="memdesc:a715fecc85a804935c8c5a6c4eb4f905e"><td class="mdescLeft"> </td><td class="mdescRight">Allocates a new <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html" title="Base storage class for GPU memory with reference counting. ">GpuMat</a> of given size and type.  <a href="#a715fecc85a804935c8c5a6c4eb4f905e">More...</a><br/></td></tr>
<tr class="separator:a715fecc85a804935c8c5a6c4eb4f905e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae3555cf098c2ca2b9112f18393f6095e"><td align="right" class="memItemLeft" valign="top"><a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html#ae3555cf098c2ca2b9112f18393f6095e">getBuffer</a> (<a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a> size, int type)</td></tr>
<tr class="memdesc:ae3555cf098c2ca2b9112f18393f6095e"><td class="mdescLeft"> </td><td class="mdescRight">Allocates a new <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html" title="Base storage class for GPU memory with reference counting. ">GpuMat</a> of given size and type.  <a href="#ae3555cf098c2ca2b9112f18393f6095e">More...</a><br/></td></tr>
<tr class="separator:ae3555cf098c2ca2b9112f18393f6095e"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html" title="BufferPool for use with CUDA streams. ">BufferPool</a> for use with CUDA streams. </p>
<p><a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html" title="BufferPool for use with CUDA streams. ">BufferPool</a> utilizes <a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a>'s allocator to create new buffers for <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html" title="Base storage class for GPU memory with reference counting. ">GpuMat</a>'s. It is only useful when enabled with <a class="el" href="../../d9/d41/group__cudacore__struct.html#ga7dbf253e43493eb870c9759cc35bbffb" title="BufferPool management (must be called before Stream creation) ">setBufferPoolUsage</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d9/d41/group__cudacore__struct.html#ga7dbf253e43493eb870c9759cc35bbffb">setBufferPoolUsage</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d9/d41/group__cudacore__struct.html#ga7dbf253e43493eb870c9759cc35bbffb" title="BufferPool management (must be called before Stream creation) ">setBufferPoolUsage</a> must be called <em>before</em> any <a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> declaration.</dd></dl>
<p>Users may specify custom allocator for <a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html" title="This class encapsulates a queue of asynchronous calls. ">Stream</a> and may implement their own stream based functions utilizing the same underlying GPU memory management.</p>
<p>If custom allocator is not specified, <a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html" title="BufferPool for use with CUDA streams. ">BufferPool</a> utilizes StackAllocator by default. StackAllocator allocates a chunk of GPU device memory beforehand, and when <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html" title="Base storage class for GPU memory with reference counting. ">GpuMat</a> is declared later on, it is given the pre-allocated memory. This kind of strategy reduces the number of calls for memory allocating APIs such as cudaMalloc or cudaMallocPitch.</p>
<p>Below is an example that utilizes <a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html" title="BufferPool for use with CUDA streams. ">BufferPool</a> with StackAllocator:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;opencv2/opencv.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d2/d75/namespacecv.html">cv</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../d1/d1a/namespacecv_1_1cuda.html">cv::cuda</a></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="../../d9/d41/group__cudacore__struct.html#ga7dbf253e43493eb870c9759cc35bbffb">setBufferPoolUsage</a>(<span class="keyword">true</span>);                               <span class="comment">// Tell OpenCV that we are going to utilize BufferPool</span></div><div class="line">    <a class="code" href="../../d9/d41/group__cudacore__struct.html#ga93da1d4c64558590950409266b1e2a92">setBufferPoolConfig</a>(<a class="code" href="../../d8/d40/group__cudacore__init.html#ga6ded4ed8e4fc483a9863d31f34ec9c0e">getDevice</a>(), 1024 * 1024 * 64, 2);  <span class="comment">// Allocate 64 MB, 2 stacks (default is 10 MB, 5 stacks)</span></div><div class="line"></div><div class="line">    <a class="code" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html">Stream</a> stream1, stream2;                                <span class="comment">// Each stream uses 1 stack</span></div><div class="line">    <a class="code" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html">BufferPool</a> pool1(stream1), pool2(stream2);</div><div class="line"></div><div class="line">    <a class="code" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> d_src1 = pool1.getBuffer(4096, 4096, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);   <span class="comment">// 16MB</span></div><div class="line">    <a class="code" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> d_dst1 = pool1.getBuffer(4096, 4096, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a>);   <span class="comment">// 48MB, pool1 is now full</span></div><div class="line"></div><div class="line">    <a class="code" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> d_src2 = pool2.getBuffer(1024, 1024, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);   <span class="comment">// 1MB</span></div><div class="line">    <a class="code" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> d_dst2 = pool2.getBuffer(1024, 1024, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a>);   <span class="comment">// 3MB</span></div><div class="line"></div><div class="line">    <a class="code" href="../../db/d8c/group__cudaimgproc__color.html#ga48d0f208181d5ca370d8ff6b62cbe826">cvtColor</a>(d_src1, d_dst1, CV_GRAY2BGR, 0, stream1);</div><div class="line">    <a class="code" href="../../db/d8c/group__cudaimgproc__color.html#ga48d0f208181d5ca370d8ff6b62cbe826">cvtColor</a>(d_src2, d_dst2, CV_GRAY2BGR, 0, stream2);</div><div class="line">}</div></div><!-- fragment --><p>If we allocate another <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html" title="Base storage class for GPU memory with reference counting. ">GpuMat</a> on pool1 in the above example, it will be carried out by the DefaultAllocator since the stack for pool1 is full.</p>
<div class="fragment"><div class="line">GpuMat d_add1 = pool1.getBuffer(1024, 1024, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);   <span class="comment">// Stack for pool1 is full, memory is allocated with DefaultAllocator</span></div></div><!-- fragment --><p>If a third stream is declared in the above example, allocating with <a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html#a715fecc85a804935c8c5a6c4eb4f905e" title="Allocates a new GpuMat of given size and type. ">getBuffer</a> within that stream will also be carried out by the DefaultAllocator because we've run out of stacks.</p>
<div class="fragment"><div class="line">Stream stream3;                                         <span class="comment">// Only 2 stacks were allocated, we've run out of stacks</span></div><div class="line"><a class="code" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> pool3(stream3);</div><div class="line">GpuMat d_src3 = pool3.getBuffer(1024, 1024, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);   <span class="comment">// Memory is allocated with DefaultAllocator</span></div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>When utilizing StackAllocator, deallocation order is important.</dd></dl>
<p>Just like a stack, deallocation must be done in LIFO order. Below is an example of erroneous usage that violates LIFO rule. If OpenCV is compiled in Debug mode, this sample code will emit CV_Assert error.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="../../d9/d41/group__cudacore__struct.html#ga7dbf253e43493eb870c9759cc35bbffb">setBufferPoolUsage</a>(<span class="keyword">true</span>);                               <span class="comment">// Tell OpenCV that we are going to utilize BufferPool</span></div><div class="line">    Stream stream;                                          <span class="comment">// A default size (10 MB) stack is allocated to this stream</span></div><div class="line">    <a class="code" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> pool(stream);</div><div class="line"></div><div class="line">    GpuMat mat1 = pool.getBuffer(1024, 1024, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);      <span class="comment">// Allocate mat1 (1MB)</span></div><div class="line">    GpuMat mat2 = pool.getBuffer(1024, 1024, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);      <span class="comment">// Allocate mat2 (1MB)</span></div><div class="line"></div><div class="line">    mat1.release();                                         <span class="comment">// erroneous usage : mat2 must be deallocated before mat1</span></div><div class="line">}</div></div><!-- fragment --><p>Since C++ local variables are destroyed in the reverse order of construction, the code sample below satisfies the LIFO rule. Local <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html" title="Base storage class for GPU memory with reference counting. ">GpuMat</a>'s are deallocated and the corresponding memory is automatically returned to the pool for later usage.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="../../d9/d41/group__cudacore__struct.html#ga7dbf253e43493eb870c9759cc35bbffb">setBufferPoolUsage</a>(<span class="keyword">true</span>);                               <span class="comment">// Tell OpenCV that we are going to utilize BufferPool</span></div><div class="line">    <a class="code" href="../../d9/d41/group__cudacore__struct.html#ga93da1d4c64558590950409266b1e2a92">setBufferPoolConfig</a>(<a class="code" href="../../d8/d40/group__cudacore__init.html#ga6ded4ed8e4fc483a9863d31f34ec9c0e">getDevice</a>(), 1024 * 1024 * 64, 2);  <span class="comment">// Allocate 64 MB, 2 stacks (default is 10 MB, 5 stacks)</span></div><div class="line"></div><div class="line">    Stream stream1, stream2;                                <span class="comment">// Each stream uses 1 stack</span></div><div class="line">    <a class="code" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html#a0f1e0a518847d41663e7344927515761">BufferPool</a> pool1(stream1), pool2(stream2);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++)</div><div class="line">    {</div><div class="line">        GpuMat d_src1 = pool1.getBuffer(4096, 4096, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);   <span class="comment">// 16MB</span></div><div class="line">        GpuMat d_dst1 = pool1.getBuffer(4096, 4096, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a>);   <span class="comment">// 48MB, pool1 is now full</span></div><div class="line"></div><div class="line">        GpuMat d_src2 = pool2.getBuffer(1024, 1024, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);   <span class="comment">// 1MB</span></div><div class="line">        GpuMat d_dst2 = pool2.getBuffer(1024, 1024, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a>);   <span class="comment">// 3MB</span></div><div class="line"></div><div class="line">        d_src1.<a class="code" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html#ab263999dea4f7f28d4dd4ced6d2e970b">setTo</a>(<a class="code" href="../../dc/d84/group__core__basic.html#ga599fe92e910c027be274233eccad7beb">Scalar</a>(i), stream1);</div><div class="line">        d_src2.<a class="code" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html#ab263999dea4f7f28d4dd4ced6d2e970b">setTo</a>(<a class="code" href="../../dc/d84/group__core__basic.html#ga599fe92e910c027be274233eccad7beb">Scalar</a>(i), stream2);</div><div class="line"></div><div class="line">        <a class="code" href="../../db/d8c/group__cudaimgproc__color.html#ga48d0f208181d5ca370d8ff6b62cbe826">cvtColor</a>(d_src1, d_dst1, CV_GRAY2BGR, 0, stream1);</div><div class="line">        <a class="code" href="../../db/d8c/group__cudaimgproc__color.html#ga48d0f208181d5ca370d8ff6b62cbe826">cvtColor</a>(d_src2, d_dst2, CV_GRAY2BGR, 0, stream2);</div><div class="line">                                                                <span class="comment">// The order of destruction of the local variables is:</span></div><div class="line">                                                                <span class="comment">//   d_dst2 =&gt; d_src2 =&gt; d_dst1 =&gt; d_src1</span></div><div class="line">                                                                <span class="comment">// LIFO rule is satisfied, this code runs without error</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0f1e0a518847d41663e7344927515761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1e0a518847d41663e7344927515761">◆ </a></span>BufferPool()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::cuda::BufferPool::BufferPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/df3/classcv_1_1cuda_1_1Stream.html">Stream</a> &amp; </td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the <a class="el" href="../../d5/d08/classcv_1_1cuda_1_1BufferPool.html" title="BufferPool for use with CUDA streams. ">BufferPool</a> for the given stream. </p>
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4d639258399df2b804a88afa334b022b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d639258399df2b804a88afa334b022b">◆ </a></span>getAllocator()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d84/group__core__basic.html#ga6395ca871a678020c4a31fadf7e8cc63">Ptr</a>&lt;<a class="el" href="../../df/d98/classcv_1_1cuda_1_1GpuMat_1_1Allocator.html">GpuMat::Allocator</a>&gt; cv::cuda::BufferPool::getAllocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.BufferPool.getAllocator(</td><td class="paramname"></td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p>Returns the allocator associated with the stream. </p>
</div>
</div>
<a id="a715fecc85a804935c8c5a6c4eb4f905e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715fecc85a804935c8c5a6c4eb4f905e">◆ </a></span>getBuffer() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> cv::cuda::BufferPool::getBuffer </td>
          <td>(</td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>type</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.BufferPool.getBuffer(</td><td class="paramname">rows, cols, type</td><td>) -&gt; </td><td>retval</td></tr><tr><td style="width: 20px;"></td><td>cv.cuda.BufferPool.getBuffer(</td><td class="paramname">size, type</td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p>Allocates a new <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html" title="Base storage class for GPU memory with reference counting. ">GpuMat</a> of given size and type. </p>
</div>
</div>
<a id="ae3555cf098c2ca2b9112f18393f6095e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3555cf098c2ca2b9112f18393f6095e">◆ </a></span>getBuffer() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html">GpuMat</a> cv::cuda::BufferPool::getBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../dc/d84/group__core__basic.html#ga346f563897249351a34549137c8532a0">Size</a> </td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int </td>
          <td class="paramname"><em>type</em> </td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table><table class="python_language"><tr><th colspan="999" style="text-align:left">Python:</th></tr><tr><td style="width: 20px;"></td><td>cv.cuda.BufferPool.getBuffer(</td><td class="paramname">rows, cols, type</td><td>) -&gt; </td><td>retval</td></tr><tr><td style="width: 20px;"></td><td>cv.cuda.BufferPool.getBuffer(</td><td class="paramname">size, type</td><td>) -&gt; </td><td>retval</td></tr></table>
</div><div class="memdoc">
<p>Allocates a new <a class="el" href="../../d0/d60/classcv_1_1cuda_1_1GpuMat.html" title="Base storage class for GPU memory with reference counting. ">GpuMat</a> of given size and type. </p>
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>opencv2/core/<a class="el" href="../../d8/dd1/modules_2core_2include_2opencv2_2core_2cuda_8hpp.html">cuda.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 5 2022 16:20:01 for OpenCV by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="../../doxygen.png"/>
</a> 1.8.13
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
