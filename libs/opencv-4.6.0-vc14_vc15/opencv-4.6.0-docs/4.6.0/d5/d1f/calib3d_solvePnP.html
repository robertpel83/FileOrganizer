<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>OpenCV: Perspective-n-Point (PnP) pose computation</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
          distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
          distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.6.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Perspective-n-Point (PnP) pose computation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Pose computation overview</h2>
<p>The pose computation problem <a class="el" href="../../d0/de3/citelist.html#CITEREF_Marchand16">[166]</a> consists in solving for the rotation and translation that minimizes the reprojection error from 3D-2D point correspondences.</p>
<p>The <code>solvePnP</code> and related functions estimate the object pose given a set of object points, their corresponding image projections, as well as the camera intrinsic matrix and the distortion coefficients, see the figure below (more precisely, the X-axis of the camera frame is pointing to the right, the Y-axis downward and the Z-axis forward).</p>
<div class="image">
<img src="../../pnp.jpg" alt="pnp.jpg"/>
</div>
<p>Points expressed in the world frame \( \bf{X}_w \) are projected into the image plane \( \left[ u, v \right] \) using the perspective projection model \( \Pi \) and the camera intrinsic parameters matrix \( \bf{A} \) (also denoted \( \bf{K} \) in the literature):</p>
<p class="formulaDsp">
\[ \begin{align*} \begin{bmatrix} u \\ v \\ 1 \end{bmatrix} &amp;= \bf{A} \hspace{0.1em} \Pi \hspace{0.2em} ^{c}\bf{T}_w \begin{bmatrix} X_{w} \\ Y_{w} \\ Z_{w} \\ 1 \end{bmatrix} \\ \begin{bmatrix} u \\ v \\ 1 \end{bmatrix} &amp;= \begin{bmatrix} f_x &amp; 0 &amp; c_x \\ 0 &amp; f_y &amp; c_y \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \begin{bmatrix} r_{11} &amp; r_{12} &amp; r_{13} &amp; t_x \\ r_{21} &amp; r_{22} &amp; r_{23} &amp; t_y \\ r_{31} &amp; r_{32} &amp; r_{33} &amp; t_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} X_{w} \\ Y_{w} \\ Z_{w} \\ 1 \end{bmatrix} \end{align*} \]
</p>
<p>The estimated pose is thus the rotation (<code>rvec</code>) and the translation (<code>tvec</code>) vectors that allow transforming a 3D point expressed in the world frame into the camera frame:</p>
<p class="formulaDsp">
\[ \begin{align*} \begin{bmatrix} X_c \\ Y_c \\ Z_c \\ 1 \end{bmatrix} &amp;= \hspace{0.2em} ^{c}\bf{T}_w \begin{bmatrix} X_{w} \\ Y_{w} \\ Z_{w} \\ 1 \end{bmatrix} \\ \begin{bmatrix} X_c \\ Y_c \\ Z_c \\ 1 \end{bmatrix} &amp;= \begin{bmatrix} r_{11} &amp; r_{12} &amp; r_{13} &amp; t_x \\ r_{21} &amp; r_{22} &amp; r_{23} &amp; t_y \\ r_{31} &amp; r_{32} &amp; r_{33} &amp; t_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} X_{w} \\ Y_{w} \\ Z_{w} \\ 1 \end{bmatrix} \end{align*} \]
</p>
<h2>Pose computation methods</h2>
<p><a class="anchor" id="calib3d_solvePnP_flags"></a> Refer to the <a class="el" href="../../d9/d0c/group__calib3d.html#ga357634492a94efe8858d0ce1509da869">cv::SolvePnPMethod</a> enum documentation for the list of possible values. Some details about each method are described below:</p>
<ul>
<li><a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869a9f589872a7f7d687dc58294e01ea33a5">cv::SOLVEPNP_ITERATIVE</a> Iterative method is based on a Levenberg-Marquardt optimization. In this case the function finds such a pose that minimizes reprojection error, that is the sum of squared distances between the observed projections "imagePoints" and the projected (using <a class="el" href="../../d9/d0c/group__calib3d.html#ga1019495a2c8d1743ed5cc23fa0daff8c" title="Projects 3D points to an image plane. ">cv::projectPoints</a> ) "objectPoints". Initial solution for non-planar "objectPoints" needs at least 6 points and uses the DLT algorithm. Initial solution for planar "objectPoints" needs at least 4 points and uses pose from homography decomposition.</li>
<li><a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869af33a85ca698777ff9bd1de916bf5959a" title="Complete Solution Classification for the Perspective-Three-Point Problem . ">cv::SOLVEPNP_P3P</a> Method is based on the paper of X.S. Gao, X.-R. Hou, J. Tang, H.-F. Chang "Complete Solution Classification for the Perspective-Three-Point Problem" (<a class="el" href="../../d0/de3/citelist.html#CITEREF_gao2003complete">[86]</a>). In this case the function requires exactly four object and image points.</li>
<li><a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869a8d48dece2da6492d91fa2de0a04679f9" title="An Efficient Algebraic Solution to the Perspective-Three-Point Problem . ">cv::SOLVEPNP_AP3P</a> Method is based on the paper of T. Ke, S. Roumeliotis "An Efficient Algebraic Solution to the Perspective-Three-Point Problem" (<a class="el" href="../../d0/de3/citelist.html#CITEREF_Ke17">[129]</a>). In this case the function requires exactly four object and image points.</li>
<li><a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869ae25763f5155defc67ef0f68b74d6c074" title="EPnP: Efficient Perspective-n-Point Camera Pose Estimation . ">cv::SOLVEPNP_EPNP</a> Method has been introduced by F. Moreno-Noguer, V. Lepetit and P. Fua in the paper "EPnP: Efficient Perspective-n-Point Camera Pose Estimation" (<a class="el" href="../../d0/de3/citelist.html#CITEREF_lepetit2009epnp">[141]</a>).</li>
<li><a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869aa51f13248282b8778003b9a4cf8ac07e">cv::SOLVEPNP_DLS</a> <b>Broken implementation. Using this flag will fallback to EPnP.</b> <br />
Method is based on the paper of J. Hesch and S. Roumeliotis. "A Direct Least-Squares (DLS) Method for PnP" (<a class="el" href="../../d0/de3/citelist.html#CITEREF_hesch2011direct">[112]</a>).</li>
<li><a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869a2859c9ce1430662096d3cc3b5462847f">cv::SOLVEPNP_UPNP</a> <b>Broken implementation. Using this flag will fallback to EPnP.</b> <br />
Method is based on the paper of A. Penate-Sanchez, J. Andrade-Cetto, F. Moreno-Noguer. "Exhaustive Linearization for Robust Camera Pose and Focal Length
Estimation" (<a class="el" href="../../d0/de3/citelist.html#CITEREF_penate2013exhaustive">[195]</a>). In this case the function also estimates the parameters \(f_x\) and \(f_y\) assuming that both have the same value. Then the cameraMatrix is updated with the estimated focal length.</li>
<li><a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869acbd7d9f9513a22a59412661a9d31ca3d">cv::SOLVEPNP_IPPE</a> Method is based on the paper of T. Collins and A. Bartoli. "Infinitesimal Plane-Based Pose Estimation" (<a class="el" href="../../d0/de3/citelist.html#CITEREF_Collins14">[50]</a>). This method requires coplanar object points.</li>
<li><a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869ac5d28b2805d3ac32fd477eee4479406f">cv::SOLVEPNP_IPPE_SQUARE</a> Method is based on the paper of Toby Collins and Adrien Bartoli. "Infinitesimal Plane-Based Pose Estimation" (<a class="el" href="../../d0/de3/citelist.html#CITEREF_Collins14">[50]</a>). This method is suitable for marker pose estimation. It requires 4 coplanar object points defined in the following order:<ul>
<li>point 0: [-squareLength / 2, squareLength / 2, 0]</li>
<li>point 1: [ squareLength / 2, squareLength / 2, 0]</li>
<li>point 2: [ squareLength / 2, -squareLength / 2, 0]</li>
<li>point 3: [-squareLength / 2, -squareLength / 2, 0]</li>
</ul>
</li>
<li><a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869a9229a3332f6c4969251c31d2931b0729" title="SQPnP: A Consistently Fast and Globally OptimalSolution to the Perspective-n-Point Problem ...">cv::SOLVEPNP_SQPNP</a> Method is based on the paper "A Consistently Fast and Globally Optimal Solution to the
Perspective-n-Point Problem" by G. Terzakis and M.Lourakis (<a class="el" href="../../d0/de3/citelist.html#CITEREF_Terzakis2020SQPnP">[247]</a>). It requires 3 or more points.</li>
</ul>
<h2>P3P</h2>
<p>The <a class="el" href="../../d9/d0c/group__calib3d.html#gae5af86788e99948d40b39a03f6acf623" title="Finds an object pose from 3 3D-2D point correspondences. ">cv::solveP3P()</a> computes an object pose from exactly 3 3D-2D point correspondences. A P3P problem has up to 4 solutions.</p>
<dl class="section note"><dt>Note</dt><dd>The solutions are sorted by reprojection errors (lowest to highest).</dd></dl>
<h2>PnP</h2>
<p>The <a class="el" href="../../d9/d0c/group__calib3d.html#ga549c2075fac14829ff4a58bc931c033d" title="Finds an object pose from 3D-2D point correspondences. ">cv::solvePnP()</a> returns the rotation and the translation vectors that transform a 3D point expressed in the object coordinate frame to the camera coordinate frame, using different methods:</p><ul>
<li>P3P methods (<a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869af33a85ca698777ff9bd1de916bf5959a" title="Complete Solution Classification for the Perspective-Three-Point Problem . ">cv::SOLVEPNP_P3P</a>, <a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869a8d48dece2da6492d91fa2de0a04679f9" title="An Efficient Algebraic Solution to the Perspective-Three-Point Problem . ">cv::SOLVEPNP_AP3P</a>): need 4 input points to return a unique solution.</li>
<li><a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869acbd7d9f9513a22a59412661a9d31ca3d">cv::SOLVEPNP_IPPE</a> Input points must be &gt;= 4 and object points must be coplanar.</li>
<li><a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869ac5d28b2805d3ac32fd477eee4479406f">cv::SOLVEPNP_IPPE_SQUARE</a> Special case suitable for marker pose estimation. Number of input points must be 4. Object points must be defined in the following order:<ul>
<li>point 0: [-squareLength / 2, squareLength / 2, 0]</li>
<li>point 1: [ squareLength / 2, squareLength / 2, 0]</li>
<li>point 2: [ squareLength / 2, -squareLength / 2, 0]</li>
<li>point 3: [-squareLength / 2, -squareLength / 2, 0]</li>
</ul>
</li>
<li>for all the other flags, number of input points must be &gt;= 4 and object points can be in any configuration.</li>
</ul>
<h2>Generic PnP</h2>
<p>The <a class="el" href="../../d9/d0c/group__calib3d.html#ga624af8a6641b9bdb487f63f694e8bb90" title="Finds an object pose from 3D-2D point correspondences. ">cv::solvePnPGeneric()</a> allows retrieving all the possible solutions.</p>
<p>Currently, only <a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869af33a85ca698777ff9bd1de916bf5959a" title="Complete Solution Classification for the Perspective-Three-Point Problem . ">cv::SOLVEPNP_P3P</a>, <a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869a8d48dece2da6492d91fa2de0a04679f9" title="An Efficient Algebraic Solution to the Perspective-Three-Point Problem . ">cv::SOLVEPNP_AP3P</a>, <a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869acbd7d9f9513a22a59412661a9d31ca3d">cv::SOLVEPNP_IPPE</a>, <a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869ac5d28b2805d3ac32fd477eee4479406f">cv::SOLVEPNP_IPPE_SQUARE</a>, <a class="el" href="../../d9/d0c/group__calib3d.html#gga357634492a94efe8858d0ce1509da869a9229a3332f6c4969251c31d2931b0729" title="SQPnP: A Consistently Fast and Globally OptimalSolution to the Perspective-n-Point Problem ...">cv::SOLVEPNP_SQPNP</a> can return multiple solutions.</p>
<h2>RANSAC PnP</h2>
<p>The <a class="el" href="../../d9/d0c/group__calib3d.html#ga50620f0e26e02caa2e9adc07b5fbf24e" title="Finds an object pose from 3D-2D point correspondences using the RANSAC scheme. ">cv::solvePnPRansac()</a> computes the object pose wrt. the camera frame using a RANSAC scheme to deal with outliers.</p>
<p>More information can be found in <a class="el" href="../../d0/de3/citelist.html#CITEREF_Zuliani2014RANSACFD">[304]</a></p>
<h2>Pose refinement</h2>
<p>Pose refinement consists in estimating the rotation and translation that minimizes the reprojection error using a non-linear minimization method and starting from an initial estimate of the solution. OpenCV proposes <a class="el" href="../../d9/d0c/group__calib3d.html#ga650ba4d286a96d992f82c3e6dfa525fa" title="Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coo...">cv::solvePnPRefineLM()</a> and <a class="el" href="../../d9/d0c/group__calib3d.html#ga17491c0282e4af874f6206a9166774a5" title="Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coo...">cv::solvePnPRefineVVS()</a> for this problem.</p>
<p><a class="el" href="../../d9/d0c/group__calib3d.html#ga650ba4d286a96d992f82c3e6dfa525fa" title="Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coo...">cv::solvePnPRefineLM()</a> uses a non-linear Levenberg-Marquardt minimization scheme <a class="el" href="../../d0/de3/citelist.html#CITEREF_Madsen04">[162]</a> <a class="el" href="../../d0/de3/citelist.html#CITEREF_Eade13">[66]</a> and the current implementation computes the rotation update as a perturbation and not on SO(3).</p>
<p><a class="el" href="../../d9/d0c/group__calib3d.html#ga17491c0282e4af874f6206a9166774a5" title="Refine a pose (the translation and the rotation that transform a 3D point expressed in the object coo...">cv::solvePnPRefineVVS()</a> uses a Gauss-Newton non-linear minimization scheme <a class="el" href="../../d0/de3/citelist.html#CITEREF_Marchand16">[166]</a> and with an update of the rotation part computed using the exponential map.</p>
<dl class="section note"><dt>Note</dt><dd>at least three 3D-2D point correspondences are necessary. </dd></dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 5 2022 16:19:50 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
