<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>OpenCV: Vectorizing your code using Universal Intrinsics</title>
<link href="../../opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../tutorial-utils.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          cameramatrix: ["#1 = \\begin{bmatrix} f_x & 0 & c_x\\\\ 0 & f_y & c_y\\\\ 0 & 0 & 1 \\end{bmatrix}", 1],
          distcoeffs: ["(k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6 [, s_1, s_2, s_3, s_4[, \\tau_x, \\tau_y]]]]) \\text{ of 4, 5, 8, 12 or 14 elements}"],
          distcoeffsfisheye: ["(k_1, k_2, k_3, k_4)"],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.6.0</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/df8/tutorial_root.html">OpenCV Tutorials</a></li><li class="navelem"><a class="el" href="../../de/d7a/tutorial_table_of_content_core.html">The Core Functionality (core module)</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Vectorizing your code using Universal Intrinsics </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Prev Tutorial:</b> <a class="el" href="../../dc/ddf/tutorial_how_to_use_OpenCV_parallel_for_new.html">How to use the OpenCV parallel_for_ to parallelize your code</a></p>
<table class="doxtable">
<tr>
<th align="right"></th><th align="left"></th></tr>
<tr>
<td align="right">Compatibility </td><td align="left">OpenCV &gt;= 3.0 </td></tr>
</table>
<h2>Goal </h2>
<p>The goal of this tutorial is to provide a guide to using the <a class="el" href="../../df/d91/group__core__hal__intrin.html">Universal intrinsics</a> feature to vectorize your C++ code for a faster runtime. We'll briefly look into <em>SIMD intrinsics</em> and how to work with wide <em>registers</em>, followed by a tutorial on the basic operations using wide registers.</p>
<h2>Theory </h2>
<p>In this section, we will briefly look into a few concepts to better help understand the functionality.</p>
<h3>Intrinsics</h3>
<p>Intrinsics are functions which are separately handled by the compiler. These functions are often optimized to perform in the most efficient ways possible and hence run faster than normal implementations. However, since these functions depend on the compiler, it makes it difficult to write portable applications.</p>
<h3>SIMD</h3>
<p>SIMD stands for <b>Single Instruction, Multiple Data</b>. SIMD Intrinsics allow the processor to vectorize calculations. The data is stored in what are known as <em>registers</em>. A <em>register</em> may be <em>128-bits</em>, <em>256-bits</em> or <em>512-bits</em> wide. Each <em>register</em> stores <b>multiple values</b> of the <b>same data type</b>. The size of the register and the size of each value determines the number of values stored in total.</p>
<p>Depending on what <em>Instruction Sets</em> your CPU supports, you may be able to use the different registers. To learn more, look <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture">here</a></p>
<h2>Universal Intrinsics </h2>
<p>OpenCVs universal intrinsics provides an abstraction to SIMD vectorization methods and allows the user to use intrinsics without the need to write system specific code.</p>
<p>OpenCV Universal Intrinsics support the following instruction sets:</p><ul>
<li><em>128 bit</em> registers of various types support is implemented for a wide range of architectures including<ul>
<li>x86(SSE/SSE2/SSE4.2),</li>
<li>ARM(NEON),</li>
<li>PowerPC(VSX),</li>
<li>MIPS(MSA).</li>
</ul>
</li>
<li><em>256 bit</em> registers are supported on x86(AVX2) and</li>
<li><em>512 bit</em> registers are supported on x86(AVX512)</li>
</ul>
<p><b>We will now introduce the available structures and functions:</b></p><ul>
<li>Register structures</li>
<li>Load and store</li>
<li>Mathematical Operations</li>
<li>Reduce and Mask</li>
</ul>
<h3>Register Structures</h3>
<p>The Universal Intrinsics set implements every register as a structure based on the particular SIMD register. All types contain the <code>nlanes</code> enumeration which gives the exact number of values that the type can hold. This eliminates the need to hardcode the number of values during implementations.</p>
<dl class="section note"><dt>Note</dt><dd>Each register structure is under the <code>cv</code> namespace.</dd></dl>
<p>There are <b>two types</b> of registers:</p>
<ul>
<li><p class="startli"><b>Variable sized registers</b>: These structures do not have a fixed size and their exact bit length is deduced during compilation, based on the available SIMD capabilities. Consequently, the value of the <code>nlanes</code> enum is determined in compile time. <br />
</p>
<p class="startli">Each structure follows the following convention: </p><pre class="fragment">v_[type of value][size of each value in bits]
</pre><p class="startli">For instance, <b>v_uint8 holds 8-bit unsigned integers</b> and <b>v_float32 holds 32-bit floating point values</b>. We then declare a register like we would declare any object in C++</p>
<p class="startli">Based on the available SIMD instruction set, a particular register will hold different number of values. For example: If your computer supports a maximum of 256bit registers,</p><ul>
<li><em>v_uint8</em> will hold 32 8-bit unsigned integers</li>
<li><em>v_float64</em> will hold 4 64-bit floats (doubles) <pre class="fragment">  v_uint8 a;                            // a is a register supporting uint8(char) data
  int n = a.nlanes;                     // n holds 32
</pre></li>
</ul>
<p class="startli">Available data type and sizes: </p><table class="doxtable">
<tr>
<th align="right">Type</th><th align="left">Size in bits  </th></tr>
<tr>
<td align="right">uint</td><td align="left">8, 16, 32, 64 </td></tr>
<tr>
<td align="right">int </td><td align="left">8, 16, 32, 64 </td></tr>
<tr>
<td align="right">float </td><td align="left">32, 64 </td></tr>
</table>
</li>
<li><p class="startli"><b>Constant sized registers</b>: These structures have a fixed bit size and hold a constant number of values. We need to know what SIMD instruction set is supported by the system and select compatible registers. Use these only if exact bit length is necessary. <br />
</p>
<p class="startli">Each structure follows the convention: </p><pre class="fragment">v_[type of value][size of each value in bits]x[number of values]
</pre><p class="startli">Suppose we want to store</p><ul>
<li>32-bit(<em>size in bits</em>) signed integers in a <b>128 bit register</b>. Since the register size is already known, we can find out the <em>number of data points in register</em> (<em>128/32 = 4</em>): <pre class="fragment">  v_int32x8 reg1                       // holds 8 32-bit signed integers.
</pre></li>
<li>64-bit floats in 512 bit register: <pre class="fragment">  v_float64x8 reg2                     // reg2.nlanes = 8
</pre></li>
</ul>
</li>
</ul>
<h3>Load and Store operations</h3>
<p>Now that we know how registers work, let us look at the functions used for filling these registers with values.</p>
<ul>
<li><p class="startli"><b>Load</b>: Load functions allow you to <em>load</em> values into a register.</p><ul>
<li><em>Constructors</em> - When declaring a register structure, we can either provide a memory address from where the register will pick up contiguous values, or provide the values explicitly as multiple arguments (Explicit multiple arguments is available only for Constant Sized Registers): <pre class="fragment">  float ptr[32] = {1, 2, 3 ..., 32};   // ptr is a pointer to a contiguous memory block of 32 floats

  // Variable Sized Registers //
  int x = v_float32().nlanes;          // set x as the number of values the register can hold

  v_float32 reg1(ptr);                 // reg1 stores first x values according to the maximum register size available.
  v_float32 reg2(ptr + x);             // reg stores the next x values

  // Constant Sized Registers //
  v_float32x4 reg1(ptr);               // reg1 stores the first 4 floats (1, 2, 3, 4)
  v_float32x4 reg2(ptr + 4);           // reg2 stores the next 4 floats (5, 6, 7, 8)

  // Or we can explicitly write down the values.
  v_float32x4(1, 2, 3, 4);
</pre></li>
</ul>
<p class="startli"><br />
</p><ul>
<li><p class="startli"><em>Load Function</em> - We can use the load method and provide the memory address of the data: </p><pre class="fragment">  float ptr[32] = {1, 2, 3, ..., 32};
  v_float32 reg_var;
  reg_var = vx_load(ptr);              // loads values from ptr[0] upto ptr[reg_var.nlanes - 1]

  v_float32x4 reg_128;
  reg_128 = v_load(ptr);               // loads values from ptr[0] upto ptr[3]

  v_float32x8 reg_256;
  reg_256 = v256_load(ptr);            // loads values from ptr[0] upto ptr[7]

  v_float32x16 reg_512;
  reg_512 = v512_load(ptr);            // loads values from ptr[0] upto ptr[15]
</pre><dl class="section note"><dt>Note</dt><dd>The load function assumes data is unaligned. If your data is aligned, you may use the <code><a class="el" href="../../df/d91/group__core__hal__intrin.html#ga5878b9336b849375df7b51e214dffb09">vx_load_aligned()</a></code> function. <br />
</dd></dl>
</li>
</ul>
</li>
<li><b>Store</b>: Store functions allow you to <em>store</em> the values from a register into a particular memory location.<ul>
<li>To store values from a register into a memory location, you may use the <em><a class="el" href="../../df/d91/group__core__hal__intrin.html#ga275dfa9c8935f5e9a1031121cde460f4" title="Store data to memory. ">v_store()</a></em> function: <pre class="fragment">  float ptr[4];
  v_store(ptr, reg); // store the first 128 bits(interpreted as 4x32-bit floats) of reg into ptr.
</pre> <br />
 <dl class="section note"><dt>Note</dt><dd>Ensure <b>ptr</b> has the same type as register. You can also cast the register into the proper type before carrying out operations. Simply typecasting the pointer to a particular type will lead wrong interpretation of data.</dd></dl>
<h3>Binary and Unary Operators</h3>
</li>
</ul>
</li>
</ul>
<p>The universal intrinsics set provides element wise binary and unary operations.</p>
<ul>
<li><b>Arithmetics</b>: We can add, subtract, multiply and divide two registers element-wise. The registers must be of the same width and hold the same type. To multiply two registers, for example: <pre class="fragment">  v_float32 a, b;                          // {a1, ..., an}, {b1, ..., bn}
  v_float32 c;
  c = a + b                                // {a1 + b1, ..., an + bn}
  c = a * b;                               // {a1 * b1, ..., an * bn}
</pre></li>
</ul>
<p><br />
</p>
<ul>
<li><b>Bitwise Logic and Shifts</b>: We can left shift or right shift the bits of each element of the register. We can also apply bitwise &amp;, |, ^ and ~ operators between two registers element-wise: <pre class="fragment">  v_int32 as;                              // {a1, ..., an}
  v_int32 al = as &lt;&lt; 2;                    // {a1 &lt;&lt; 2, ..., an &lt;&lt; 2}
  v_int32 bl = as &gt;&gt; 2;                    // {a1 &gt;&gt; 2, ..., an &gt;&gt; 2}

  v_int32 a, b;
  v_int32 a_and_b = a &amp; b;                 // {a1 &amp; b1, ..., an &amp; bn}
</pre></li>
</ul>
<p><br />
</p>
<ul>
<li><b>Comparison Operators</b>: We can compare values between two registers using the &lt;, &gt;, &lt;= , &gt;=, == and != operators. Since each register contains multiple values, we don't get a single bool for these operations. Instead, for true values, all bits are converted to one (0xff for 8 bits, 0xffff for 16 bits, etc), while false values return bits converted to zero. <pre class="fragment">  // let us consider the following code is run in a 128-bit register
  v_uint8 a;                               // a = {0, 1, 2, ..., 15}
  v_uint8 b;                               // b = {15, 14, 13, ..., 0}

  v_uint8 c = a &lt; b;

  /*
      let us look at the first 4 values in binary

      a = |00000000|00000001|00000010|00000011|
      b = |00001111|00001110|00001101|00001100|
      c = |11111111|11111111|11111111|11111111|

      If we store the values of c and print them as integers, we will get 255 for true values and 0 for false values.
  */
  ---
  // In a computer supporting 256-bit registers
  v_int32 a;                               // a = {1, 2, 3, 4, 5, 6, 7, 8}
  v_int32 b;                               // b = {8, 7, 6, 5, 4, 3, 2, 1}

  v_int32 c = (a &lt; b);                     // c = {-1, -1, -1, -1, 0, 0, 0, 0}

  /*
      The true values are 0xffffffff, which in signed 32-bit integer representation is equal to -1.
  */
</pre> <br />
</li>
<li><b>Min/Max operations</b>: We can use the <em><a class="el" href="../../df/d91/group__core__hal__intrin.html#gaf7cf8641863e5a56b642a363f539c836" title="Choose min values for each pair. ">v_min()</a></em> and <em><a class="el" href="../../df/d91/group__core__hal__intrin.html#ga69ee01fdfd9d57067e2a967db5e8bd45" title="Choose max values for each pair. ">v_max()</a></em> functions to return registers containing element-wise min, or max, of the two registers: <pre class="fragment">  v_int32 a;                               // {a1, ..., an}
  v_int32 b;                               // {b1, ..., bn}

  v_int32 mn = v_min(a, b);                // {min(a1, b1), ..., min(an, bn)}
  v_int32 mx = v_max(a, b);                // {max(a1, b1), ..., max(an, bn)}
</pre> <br />
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Comparison and Min/Max operators are not available for 64 bit integers. Bitwise shift and logic operators are available only for integer values. Bitwise shift is available only for 16, 32 and 64 bit registers.</dd></dl>
<h3>Reduce and Mask</h3>
<ul>
<li><b>Reduce Operations</b>: The <em><a class="el" href="../../df/d91/group__core__hal__intrin.html#ga7ce066014a77ab386204688b30281c71" title="Find one min value. ">v_reduce_min()</a></em>, <em><a class="el" href="../../df/d91/group__core__hal__intrin.html#gac2b31f9518aea3ea0f113c7ff163d2a9" title="Find one max value. ">v_reduce_max()</a></em> and <em><a class="el" href="../../df/d91/group__core__hal__intrin.html#ga38ffc32658e008a149f259b1637cb0be" title="Sum packed values. ">v_reduce_sum()</a></em> return a single value denoting the min, max or sum of the entire register: <pre class="fragment">  v_int32 a;                                //  a = {a1, ..., a4}
  int mn = v_reduce_min(a);                 // mn = min(a1, ..., an)
  int sum = v_reduce_sum(a);                // sum = a1 + ... + an
</pre> <br />
</li>
<li><b>Mask Operations</b>: Mask operations allow us to replicate conditionals in wide registers. These include:<ul>
<li><em><a class="el" href="../../df/d91/group__core__hal__intrin.html#gad4a93a907f23a3e9028172d09b4822f8" title="Check if all packed values are less than zero. ">v_check_all()</a></em> - Returns a bool, which is true if all the values in the register are less than zero.</li>
<li><em><a class="el" href="../../df/d91/group__core__hal__intrin.html#ga03282d0b7c46861f1ecc7329a40634b3" title="Check if any of packed values is less than zero. ">v_check_any()</a></em> - Returns a bool, which is true if any value in the register is less than zero.</li>
<li><em><a class="el" href="../../df/d91/group__core__hal__intrin.html#gae440a2520e3b796df0be134e2fe6a7b0" title="Per-element select (blend operation) ">v_select()</a></em> - Returns a register, which blends two registers, based on a mask. <pre class="fragment">  v_uint8 a;                           // {a1, .., an}
  v_uint8 b;                           // {b1, ..., bn}

  v_int32x4 mask:                      // {0xff, 0, 0, 0xff, ..., 0xff, 0}

  v_uint8 Res = v_select(mask, a, b)   // {a1, b2, b3, a4, ..., an-1, bn}

  /*
      "Res" will contain the value from "a" if mask is true (all bits set to 1),
      and value from "b" if mask is false (all bits set to 0)

      We can use comparison operators to generate mask and v_select to obtain results based on conditionals.
      It is common to set all values of b to 0. Thus, v_select will give values of "a" or 0 based on the mask.
  */
</pre></li>
</ul>
</li>
</ul>
<h2>Demonstration</h2>
<p>In the following section, we will vectorize a simple convolution function for single channel and compare the results to a scalar implementation. </p><dl class="section note"><dt>Note</dt><dd>Not all algorithms are improved by manual vectorization. In fact, in certain cases, the compiler may <em>autovectorize</em> the code, thus producing faster results for scalar implementations.</dd></dl>
<p>You may learn more about convolution from the previous tutorial. We use the same naive implementation from the previous tutorial and compare it to the vectorized version.</p>
<p>The full tutorial code is <a href="https://github.com/opencv/opencv/tree/4.x/samples/cpp/tutorial_code/univ_intrin/univ_intrin.cpp">here</a>.</p>
<h3>Vectorizing Convolution</h3>
<p>We will first implement a 1-D convolution and then vectorize it. The 2-D vectorized convolution will perform 1-D convolution across the rows to produce the correct results.</p>
<h4>1-D Convolution: Scalar</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> conv1d(Mat src, Mat &amp;dst, Mat kernel)</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> len = src.cols;</div><div class="line">    dst = Mat(1, len, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> sz = kernel.cols / 2;</div><div class="line">    <a class="code" href="../../d2/de8/group__core__array.html#ga2ac1049c2c3dd25c2b41bffe17658a36">copyMakeBorder</a>(src, src, 0, 0, sz, sz, <a class="code" href="../../d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aa1de4cff95e3377d6d0cbe7569bd4e9f">BORDER_REPLICATE</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; i++)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">double</span> value = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = -sz; k &lt;= sz; k++)</div><div class="line">            value += src.ptr&lt;uchar&gt;(0)[i + k + sz] * kernel.ptr&lt;<span class="keywordtype">float</span>&gt;(0)[k + sz];</div><div class="line"></div><div class="line">        dst.ptr&lt;uchar&gt;(0)[i] = <a class="code" href="../../db/de0/group__core__utils.html#ga2858f5fe522e46a2e17662669199f6ff">saturate_cast&lt;uchar&gt;</a>(value);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><ol type="1">
<li>We first set up variables and make a border on both sides of the src matrix, to take care of edge cases. <div class="fragment"><div class="line">    <span class="keywordtype">int</span> len = src.cols;</div><div class="line">    dst = Mat(1, len, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> sz = kernel.cols / 2;</div><div class="line">    <a class="code" href="../../d2/de8/group__core__array.html#ga2ac1049c2c3dd25c2b41bffe17658a36">copyMakeBorder</a>(src, src, 0, 0, sz, sz, <a class="code" href="../../d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aa1de4cff95e3377d6d0cbe7569bd4e9f">BORDER_REPLICATE</a>);</div></div><!-- fragment --></li>
<li>For the main loop, we select an index <em>i</em> and offset it on both sides along with the kernel, using the k variable. We store the value in <em>value</em> and add it to the <em>dst</em> matrix. <div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; len; i++)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">double</span> value = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = -sz; k &lt;= sz; k++)</div><div class="line">            value += src.ptr&lt;uchar&gt;(0)[i + k + sz] * kernel.ptr&lt;<span class="keywordtype">float</span>&gt;(0)[k + sz];</div><div class="line"></div><div class="line">        dst.ptr&lt;uchar&gt;(0)[i] = <a class="code" href="../../db/de0/group__core__utils.html#ga2858f5fe522e46a2e17662669199f6ff">saturate_cast&lt;uchar&gt;</a>(value);</div><div class="line">    }</div></div><!-- fragment --> <h4>1-D Convolution: Vector</h4>
</li>
</ol>
<p>We will now look at the vectorized version of 1-D convolution. </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> conv1dsimd(Mat src, Mat kernel, <span class="keywordtype">float</span> *ans, <span class="keywordtype">int</span> row = 0, <span class="keywordtype">int</span> rowk = 0, <span class="keywordtype">int</span> len = -1)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (len == -1)</div><div class="line">        len = src.cols;</div><div class="line"></div><div class="line">    Mat src_32, kernel_32;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> alpha = 1;</div><div class="line">    src.convertTo(src_32, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga32ec76240e43e4c9c7b2e2785180a7e6">CV_32FC1</a>, alpha);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> ksize = kernel.cols, sz = kernel.cols / 2;</div><div class="line">    <a class="code" href="../../d2/de8/group__core__array.html#ga2ac1049c2c3dd25c2b41bffe17658a36">copyMakeBorder</a>(src_32, src_32, 0, 0, sz, sz, <a class="code" href="../../d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aa1de4cff95e3377d6d0cbe7569bd4e9f">BORDER_REPLICATE</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> step = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a>().nlanes;</div><div class="line">    <span class="keywordtype">float</span> *sptr = src_32.ptr&lt;<span class="keywordtype">float</span>&gt;(row), *kptr = kernel.ptr&lt;<span class="keywordtype">float</span>&gt;(rowk);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; ksize; k++)</div><div class="line">    {</div><div class="line">        <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a> kernel_wide = <a class="code" href="../../df/d91/group__core__hal__intrin.html#ga5ad84d858432f9a8129bdd06b2f5eaeb">vx_setall_f32</a>(kptr[k]);</div><div class="line">        <span class="keywordtype">int</span> i;</div><div class="line">        <span class="keywordflow">for</span> (i = 0; i + step &lt; len; i += step)</div><div class="line">        {</div><div class="line">            <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a> window = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaa83207e1d84d65b39bb66426d4a99bc2">vx_load</a>(sptr + i + k);</div><div class="line">            <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a> sum = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaa83207e1d84d65b39bb66426d4a99bc2">vx_load</a>(ans + i) + kernel_wide * window;</div><div class="line">            <a class="code" href="../../df/d91/group__core__hal__intrin.html#ga275dfa9c8935f5e9a1031121cde460f4">v_store</a>(ans + i, sum);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (; i &lt; len; i++)</div><div class="line">        {</div><div class="line">            *(ans + i) += sptr[i + k]*kptr[k];</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><ol type="1">
<li>In our case, the kernel is a float. Since the kernel's datatype is the largest, we convert src to float32, forming <em>src_32</em>. We also make a border like we did for the naive case. <div class="fragment"><div class="line">    Mat src_32, kernel_32;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> alpha = 1;</div><div class="line">    src.convertTo(src_32, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga32ec76240e43e4c9c7b2e2785180a7e6">CV_32FC1</a>, alpha);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> ksize = kernel.cols, sz = kernel.cols / 2;</div><div class="line">    <a class="code" href="../../d2/de8/group__core__array.html#ga2ac1049c2c3dd25c2b41bffe17658a36">copyMakeBorder</a>(src_32, src_32, 0, 0, sz, sz, <a class="code" href="../../d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aa1de4cff95e3377d6d0cbe7569bd4e9f">BORDER_REPLICATE</a>);</div></div><!-- fragment --></li>
<li>Now, for each column in the <em>kernel</em>, we calculate the scalar product of the value with all <em>window</em> vectors of length <code>step</code>. We add these values to the already stored values in ans <div class="fragment"><div class="line">    <span class="keywordtype">int</span> step = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a>().nlanes;</div><div class="line">    <span class="keywordtype">float</span> *sptr = src_32.ptr&lt;<span class="keywordtype">float</span>&gt;(row), *kptr = kernel.ptr&lt;<span class="keywordtype">float</span>&gt;(rowk);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; ksize; k++)</div><div class="line">    {</div><div class="line">        <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a> kernel_wide = <a class="code" href="../../df/d91/group__core__hal__intrin.html#ga5ad84d858432f9a8129bdd06b2f5eaeb">vx_setall_f32</a>(kptr[k]);</div><div class="line">        <span class="keywordtype">int</span> i;</div><div class="line">        <span class="keywordflow">for</span> (i = 0; i + step &lt; len; i += step)</div><div class="line">        {</div><div class="line">            <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a> window = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaa83207e1d84d65b39bb66426d4a99bc2">vx_load</a>(sptr + i + k);</div><div class="line">            <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a> sum = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaa83207e1d84d65b39bb66426d4a99bc2">vx_load</a>(ans + i) + kernel_wide * window;</div><div class="line">            <a class="code" href="../../df/d91/group__core__hal__intrin.html#ga275dfa9c8935f5e9a1031121cde460f4">v_store</a>(ans + i, sum);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (; i &lt; len; i++)</div><div class="line">        {</div><div class="line">            *(ans + i) += sptr[i + k]*kptr[k];</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>We declare a pointer to the src_32 and kernel and run a loop for each kernel element <div class="fragment"><div class="line">    <span class="keywordtype">int</span> step = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a>().nlanes;</div><div class="line">    <span class="keywordtype">float</span> *sptr = src_32.ptr&lt;<span class="keywordtype">float</span>&gt;(row), *kptr = kernel.ptr&lt;<span class="keywordtype">float</span>&gt;(rowk);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; ksize; k++)</div><div class="line">    {</div></div><!-- fragment --></li>
<li>We load a register with the current kernel element. A window is shifted from <em>0</em> to <em>len - step</em> and its product with the kernel_wide array is added to the values stored in <em>ans</em>. We store the values back into <em>ans</em> <div class="fragment"><div class="line">        <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a> kernel_wide = <a class="code" href="../../df/d91/group__core__hal__intrin.html#ga5ad84d858432f9a8129bdd06b2f5eaeb">vx_setall_f32</a>(kptr[k]);</div><div class="line">        <span class="keywordtype">int</span> i;</div><div class="line">        <span class="keywordflow">for</span> (i = 0; i + step &lt; len; i += step)</div><div class="line">        {</div><div class="line">            <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a> window = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaa83207e1d84d65b39bb66426d4a99bc2">vx_load</a>(sptr + i + k);</div><div class="line">            <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a> sum = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaa83207e1d84d65b39bb66426d4a99bc2">vx_load</a>(ans + i) + kernel_wide * window;</div><div class="line">            <a class="code" href="../../df/d91/group__core__hal__intrin.html#ga275dfa9c8935f5e9a1031121cde460f4">v_store</a>(ans + i, sum);</div><div class="line">        }</div></div><!-- fragment --></li>
<li>Since the length might not be divisible by steps, we take care of the remaining values directly. The number of <em>tail</em> values will always be less than <em>step</em> and will not affect the performance significantly. We store all the values to <em>ans</em> which is a float pointer. We can also directly store them in a <code>Mat</code> object <div class="fragment"><div class="line">        <span class="keywordflow">for</span> (; i &lt; len; i++)</div><div class="line">        {</div><div class="line">            *(ans + i) += sptr[i + k]*kptr[k];</div><div class="line">        }</div></div><!-- fragment --></li>
<li>Here is an iterative example: <pre class="fragment">  For example:
  kernel: {k1, k2, k3}
  src:           ...|a1|a2|a3|a4|...


  iter1:
  for each idx i in (0, len), 'step' idx at a time
      kernel_wide:          |k1|k1|k1|k1|
      window:               |a0|a1|a2|a3|
      ans:               ...| 0| 0| 0| 0|...
      sum =  ans + window * kernel_wide
          =  |a0 * k1|a1 * k1|a2 * k1|a3 * k1|

  iter2:
      kernel_wide:          |k2|k2|k2|k2|
      window:               |a1|a2|a3|a4|
      ans:               ...|a0 * k1|a1 * k1|a2 * k1|a3 * k1|...
      sum =  ans + window * kernel_wide
          =  |a0 * k1 + a1 * k2|a1 * k1 + a2 * k2|a2 * k1 + a3 * k2|a3 * k1 + a4 * k2|

  iter3:
      kernel_wide:          |k3|k3|k3|k3|
      window:               |a2|a3|a4|a5|
      ans:               ...|a0 * k1 + a1 * k2|a1 * k1 + a2 * k2|a2 * k1 + a3 * k2|a3 * k1 + a4 * k2|...
      sum =  sum + window * kernel_wide
          =  |a0*k1 + a1*k2 + a2*k3|a1*k1 + a2*k2 + a3*k3|a2*k1 + a3*k2 + a4*k3|a3*k1 + a4*k2 + a5*k3|
</pre></li>
</ul>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The function parameters also include <em>row</em>, <em>rowk</em> and <em>len</em>. These values are used when using the function as an intermediate step of 2-D convolution</dd></dl>
<h4>2-D Convolution</h4>
<p>Suppose our kernel has <em>ksize</em> rows. To compute the values for a particular row, we compute the 1-D convolution of the previous <em>ksize/2</em> and the next <em>ksize/2</em> rows, with the corresponding kernel row. The final values is simply the sum of the individual 1-D convolutions </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> convolute_simd(Mat src, Mat &amp;dst, Mat kernel)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> rows = src.rows, cols = src.cols;</div><div class="line">    <span class="keywordtype">int</span> ksize = kernel.rows, sz = ksize / 2;</div><div class="line">    dst = Mat(rows, cols, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga32ec76240e43e4c9c7b2e2785180a7e6">CV_32FC1</a>);</div><div class="line"></div><div class="line">    <a class="code" href="../../d2/de8/group__core__array.html#ga2ac1049c2c3dd25c2b41bffe17658a36">copyMakeBorder</a>(src, src, sz, sz, 0, 0, <a class="code" href="../../d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aa1de4cff95e3377d6d0cbe7569bd4e9f">BORDER_REPLICATE</a>);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> step = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a>().nlanes;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows; i++)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; ksize; k++)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">float</span> ans[N] = {0};</div><div class="line">            conv1dsimd(src, kernel, ans, i + k, k, cols);</div><div class="line">            <span class="keywordtype">int</span> j;</div><div class="line">            <span class="keywordflow">for</span> (j = 0; j + step &lt; cols; j += step)</div><div class="line">            {</div><div class="line">                <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a> sum = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaa83207e1d84d65b39bb66426d4a99bc2">vx_load</a>(&amp;dst.ptr&lt;<span class="keywordtype">float</span>&gt;(i)[j]) + <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaa83207e1d84d65b39bb66426d4a99bc2">vx_load</a>(&amp;ans[j]);</div><div class="line">                <a class="code" href="../../df/d91/group__core__hal__intrin.html#ga275dfa9c8935f5e9a1031121cde460f4">v_store</a>(&amp;dst.ptr&lt;<span class="keywordtype">float</span>&gt;(i)[j], sum);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (; j &lt; cols; j++)</div><div class="line">                dst.ptr&lt;<span class="keywordtype">float</span>&gt;(i)[j] += ans[j];</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> alpha = 1;</div><div class="line">    dst.convertTo(dst, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>, alpha);</div><div class="line">}</div></div><!-- fragment --><ol type="1">
<li>We first initialize variables and make a border above and below the <em>src</em> matrix. The left and right sides are handled by the 1-D convolution function. <div class="fragment"><div class="line">    <span class="keywordtype">int</span> rows = src.rows, cols = src.cols;</div><div class="line">    <span class="keywordtype">int</span> ksize = kernel.rows, sz = ksize / 2;</div><div class="line">    dst = Mat(rows, cols, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga32ec76240e43e4c9c7b2e2785180a7e6">CV_32FC1</a>);</div><div class="line"></div><div class="line">    <a class="code" href="../../d2/de8/group__core__array.html#ga2ac1049c2c3dd25c2b41bffe17658a36">copyMakeBorder</a>(src, src, sz, sz, 0, 0, <a class="code" href="../../d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aa1de4cff95e3377d6d0cbe7569bd4e9f">BORDER_REPLICATE</a>);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> step = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a>().nlanes;</div></div><!-- fragment --></li>
<li>For each row, we calculate the 1-D convolution of the rows above and below it. we then add the values to the <em>dst</em> matrix. <div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; rows; i++)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; ksize; k++)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">float</span> ans[N] = {0};</div><div class="line">            conv1dsimd(src, kernel, ans, i + k, k, cols);</div><div class="line">            <span class="keywordtype">int</span> j;</div><div class="line">            <span class="keywordflow">for</span> (j = 0; j + step &lt; cols; j += step)</div><div class="line">            {</div><div class="line">                <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaadee0b1a1a203120f8245531046b7d75">v_float32</a> sum = <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaa83207e1d84d65b39bb66426d4a99bc2">vx_load</a>(&amp;dst.ptr&lt;<span class="keywordtype">float</span>&gt;(i)[j]) + <a class="code" href="../../df/d91/group__core__hal__intrin.html#gaa83207e1d84d65b39bb66426d4a99bc2">vx_load</a>(&amp;ans[j]);</div><div class="line">                <a class="code" href="../../df/d91/group__core__hal__intrin.html#ga275dfa9c8935f5e9a1031121cde460f4">v_store</a>(&amp;dst.ptr&lt;<span class="keywordtype">float</span>&gt;(i)[j], sum);</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (; j &lt; cols; j++)</div><div class="line">                dst.ptr&lt;<span class="keywordtype">float</span>&gt;(i)[j] += ans[j];</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></li>
<li>We finally convert the <em>dst</em> matrix to a <em>8-bit</em> <code>unsigned char</code> matrix <div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> alpha = 1;</div><div class="line">    dst.convertTo(dst, <a class="code" href="../../d1/d1b/group__core__hal__interface.html#ga81df635441b21f532fdace401e04f588">CV_8UC1</a>, alpha);</div></div><!-- fragment --> <h2>Results </h2>
</li>
</ol>
<p>In the tutorial, we used a horizontal gradient kernel. We obtain the same output image for both methods.</p>
<p>Improvement in runtime varies and will depend on the SIMD capabilities available in your CPU. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 5 2022 16:19:50 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
